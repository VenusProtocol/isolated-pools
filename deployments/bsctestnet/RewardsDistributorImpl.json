{
  "address": "0xfAE44cf6309598c2557Bb265BF0401D594db97DA",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "loopsLimit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "requiredLoops",
          "type": "uint256"
        }
      ],
      "name": "MaxLoopsLimitExceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "calledContract",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "methodSignature",
          "type": "string"
        }
      ],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newBlock",
          "type": "uint32"
        }
      ],
      "name": "BorrowLastRewardingBlockUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newSpeed",
          "type": "uint256"
        }
      ],
      "name": "ContributorRewardTokenSpeedUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardAccrued",
          "type": "uint256"
        }
      ],
      "name": "ContributorRewardsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract VToken",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenDelta",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenTotal",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenBorrowIndex",
          "type": "uint256"
        }
      ],
      "name": "DistributedBorrowerRewardToken",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract VToken",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "supplier",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenDelta",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenTotal",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardTokenSupplyIndex",
          "type": "uint256"
        }
      ],
      "name": "DistributedSupplierRewardToken",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        }
      ],
      "name": "MarketInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldMaxLoopsLimit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newmaxLoopsLimit",
          "type": "uint256"
        }
      ],
      "name": "MaxLoopsLimitUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldAccessControlManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAccessControlManager",
          "type": "address"
        }
      ],
      "name": "NewAccessControlManager",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "mantissa",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct ExponentialNoError.Exp",
          "name": "marketBorrowIndex",
          "type": "tuple"
        }
      ],
      "name": "RewardTokenBorrowIndexUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract VToken",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newSpeed",
          "type": "uint256"
        }
      ],
      "name": "RewardTokenBorrowSpeedUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RewardTokenGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        }
      ],
      "name": "RewardTokenSupplyIndexUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract VToken",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newSpeed",
          "type": "uint256"
        }
      ],
      "name": "RewardTokenSupplySpeedUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newBlock",
          "type": "uint32"
        }
      ],
      "name": "SupplyLastRewardingBlockUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "INITIAL_INDEX",
      "outputs": [
        {
          "internalType": "uint224",
          "name": "",
          "type": "uint224"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "accessControlManager",
      "outputs": [
        {
          "internalType": "contract IAccessControlManagerV8",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "holder",
          "type": "address"
        },
        {
          "internalType": "contract VToken[]",
          "name": "vTokens",
          "type": "address[]"
        }
      ],
      "name": "claimRewardToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "holder",
          "type": "address"
        }
      ],
      "name": "claimRewardToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "borrower",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "mantissa",
              "type": "uint256"
            }
          ],
          "internalType": "struct ExponentialNoError.Exp",
          "name": "marketBorrowIndex",
          "type": "tuple"
        }
      ],
      "name": "distributeBorrowerRewardToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "supplier",
          "type": "address"
        }
      ],
      "name": "distributeSupplierRewardToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBlockNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "grantRewardToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Comptroller",
          "name": "comptroller_",
          "type": "address"
        },
        {
          "internalType": "contract IERC20Upgradeable",
          "name": "rewardToken_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "loopsLimit_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "accessControlManager_",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        }
      ],
      "name": "initializeMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "lastContributorBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLoopsLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardToken",
      "outputs": [
        {
          "internalType": "contract IERC20Upgradeable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenAccrued",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenBorrowSpeeds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenBorrowState",
      "outputs": [
        {
          "internalType": "uint224",
          "name": "index",
          "type": "uint224"
        },
        {
          "internalType": "uint32",
          "name": "block",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "lastRewardingBlock",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenBorrowerIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenContributorSpeeds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenSupplierIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenSupplySpeeds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rewardTokenSupplyState",
      "outputs": [
        {
          "internalType": "uint224",
          "name": "index",
          "type": "uint224"
        },
        {
          "internalType": "uint32",
          "name": "block",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "lastRewardingBlock",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "accessControlManager_",
          "type": "address"
        }
      ],
      "name": "setAccessControlManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "rewardTokenSpeed",
          "type": "uint256"
        }
      ],
      "name": "setContributorRewardTokenSpeed",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract VToken[]",
          "name": "vTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint32[]",
          "name": "supplyLastRewardingBlocks",
          "type": "uint32[]"
        },
        {
          "internalType": "uint32[]",
          "name": "borrowLastRewardingBlocks",
          "type": "uint32[]"
        }
      ],
      "name": "setLastRewardingBlocks",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "setMaxLoopsLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract VToken[]",
          "name": "vTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "supplySpeeds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "borrowSpeeds",
          "type": "uint256[]"
        }
      ],
      "name": "setRewardTokenSpeeds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        }
      ],
      "name": "updateContributorRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "mantissa",
              "type": "uint256"
            }
          ],
          "internalType": "struct ExponentialNoError.Exp",
          "name": "marketBorrowIndex",
          "type": "tuple"
        }
      ],
      "name": "updateRewardTokenBorrowIndex",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vToken",
          "type": "address"
        }
      ],
      "name": "updateRewardTokenSupplyIndex",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x629ea501976d3fb987167b5e07000fbcc808f077108858fc103656a212aaf3cc",
  "receipt": {
    "to": null,
    "from": "0x2Ce1d0ffD7E869D9DF33e28552b12DdDed326706",
    "contractAddress": "0xfAE44cf6309598c2557Bb265BF0401D594db97DA",
    "transactionIndex": 5,
    "gasUsed": "2650342",
    "logsBloom": "0x00000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xaaf72deff7e59e61ba3575d6234b02dc09281e2583115f036ed42fac71761028",
    "transactionHash": "0x629ea501976d3fb987167b5e07000fbcc808f077108858fc103656a212aaf3cc",
    "logs": [
      {
        "transactionIndex": 5,
        "blockNumber": 31456336,
        "transactionHash": "0x629ea501976d3fb987167b5e07000fbcc808f077108858fc103656a212aaf3cc",
        "address": "0xfAE44cf6309598c2557Bb265BF0401D594db97DA",
        "topics": ["0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 9,
        "blockHash": "0xaaf72deff7e59e61ba3575d6234b02dc09281e2583115f036ed42fac71761028"
      }
    ],
    "blockNumber": 31456336,
    "cumulativeGasUsed": "3037048",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "014ac95d16ca74a5ed2395721633a333",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loopsLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredLoops\",\"type\":\"uint256\"}],\"name\":\"MaxLoopsLimitExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calledContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"methodSignature\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newBlock\",\"type\":\"uint32\"}],\"name\":\"BorrowLastRewardingBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSpeed\",\"type\":\"uint256\"}],\"name\":\"ContributorRewardTokenSpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAccrued\",\"type\":\"uint256\"}],\"name\":\"ContributorRewardsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract VToken\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenBorrowIndex\",\"type\":\"uint256\"}],\"name\":\"DistributedBorrowerRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract VToken\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardTokenSupplyIndex\",\"type\":\"uint256\"}],\"name\":\"DistributedSupplierRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"}],\"name\":\"MarketInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxLoopsLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newmaxLoopsLimit\",\"type\":\"uint256\"}],\"name\":\"MaxLoopsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAccessControlManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAccessControlManager\",\"type\":\"address\"}],\"name\":\"NewAccessControlManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ExponentialNoError.Exp\",\"name\":\"marketBorrowIndex\",\"type\":\"tuple\"}],\"name\":\"RewardTokenBorrowIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract VToken\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSpeed\",\"type\":\"uint256\"}],\"name\":\"RewardTokenBorrowSpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardTokenGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"}],\"name\":\"RewardTokenSupplyIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract VToken\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSpeed\",\"type\":\"uint256\"}],\"name\":\"RewardTokenSupplySpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newBlock\",\"type\":\"uint32\"}],\"name\":\"SupplyLastRewardingBlockUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_INDEX\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlManager\",\"outputs\":[{\"internalType\":\"contract IAccessControlManagerV8\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"contract VToken[]\",\"name\":\"vTokens\",\"type\":\"address[]\"}],\"name\":\"claimRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"claimRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct ExponentialNoError.Exp\",\"name\":\"marketBorrowIndex\",\"type\":\"tuple\"}],\"name\":\"distributeBorrowerRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"}],\"name\":\"distributeSupplierRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"grantRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Comptroller\",\"name\":\"comptroller_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loopsLimit_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"}],\"name\":\"initializeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastContributorBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLoopsLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenBorrowSpeeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenBorrowState\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"index\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"block\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastRewardingBlock\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenBorrowerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenContributorSpeeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenSupplierIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenSupplySpeeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokenSupplyState\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"index\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"block\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastRewardingBlock\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"}],\"name\":\"setAccessControlManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardTokenSpeed\",\"type\":\"uint256\"}],\"name\":\"setContributorRewardTokenSpeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract VToken[]\",\"name\":\"vTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"supplyLastRewardingBlocks\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"borrowLastRewardingBlocks\",\"type\":\"uint32[]\"}],\"name\":\"setLastRewardingBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setMaxLoopsLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract VToken[]\",\"name\":\"vTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"supplySpeeds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowSpeeds\",\"type\":\"uint256[]\"}],\"name\":\"setRewardTokenSpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"updateContributorRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct ExponentialNoError.Exp\",\"name\":\"marketBorrowIndex\",\"type\":\"tuple\"}],\"name\":\"updateRewardTokenBorrowIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vToken\",\"type\":\"address\"}],\"name\":\"updateRewardTokenSupplyIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Venus\",\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"claimRewardToken(address)\":{\"params\":{\"holder\":\"The address to claim REWARD TOKEN for\"}},\"claimRewardToken(address,address[])\":{\"params\":{\"holder\":\"The address to claim REWARD TOKEN for\",\"vTokens\":\"The list of markets to claim REWARD TOKEN in\"}},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"distributeBorrowerRewardToken(address,address,(uint256))\":{\"details\":\"This function should only be called when the user has a borrow position in the market      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)      We avoid an external call to check if they are in the market to save gas because this function is called in many places\",\"params\":{\"borrower\":\"The address of the borrower to distribute REWARD TOKEN to\",\"marketBorrowIndex\":\"The current global borrow index of vToken\",\"vToken\":\"The market in which the borrower is interacting\"}},\"grantRewardToken(address,uint256)\":{\"details\":\"Note: If there is not enough REWARD TOKEN, we do not perform the transfer all\",\"params\":{\"amount\":\"The amount of REWARD TOKEN to (possibly) transfer\",\"recipient\":\"The address of the recipient to transfer REWARD TOKEN to\"}},\"initialize(address,address,uint256,address)\":{\"details\":\"Initializes the deployer to owner\",\"params\":{\"accessControlManager_\":\"AccessControlManager contract address\",\"comptroller_\":\"Comptroller to attach the reward distributor to\",\"loopsLimit_\":\"Maximum number of iterations for the loops in this contract\",\"rewardToken_\":\"Reward token to distribute\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setAccessControlManager(address)\":{\"custom:access\":\"Only Governance\",\"custom:event\":\"Emits NewAccessControlManager event\",\"details\":\"Admin function to set address of AccessControlManager\",\"params\":{\"accessControlManager_\":\"The new address of the AccessControlManager\"}},\"setContributorRewardTokenSpeed(address,uint256)\":{\"params\":{\"contributor\":\"The contributor whose REWARD TOKEN speed to update\",\"rewardTokenSpeed\":\"New REWARD TOKEN speed for contributor\"}},\"setLastRewardingBlocks(address[],uint32[],uint32[])\":{\"params\":{\"borrowLastRewardingBlocks\":\"New borrow-side REWARD TOKEN last rewarding block for the corresponding market\",\"supplyLastRewardingBlocks\":\"New supply-side REWARD TOKEN last rewarding block for the corresponding market\",\"vTokens\":\"The markets whose REWARD TOKEN last rewarding block to update\"}},\"setMaxLoopsLimit(uint256)\":{\"params\":{\"limit\":\"Limit for the max loops can execute at a time\"}},\"setRewardTokenSpeeds(address[],uint256[],uint256[])\":{\"params\":{\"borrowSpeeds\":\"New borrow-side REWARD TOKEN speed for the corresponding market\",\"supplySpeeds\":\"New supply-side REWARD TOKEN speed for the corresponding market\",\"vTokens\":\"The markets whose REWARD TOKEN speed to update\"}},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"},\"updateContributorRewards(address)\":{\"params\":{\"contributor\":\"The address to calculate contributor rewards for\"}}},\"title\":\"`RewardsDistributor`\",\"version\":1},\"userdoc\":{\"errors\":{\"MaxLoopsLimitExceeded(uint256,uint256)\":[{\"notice\":\"Thrown an error on maxLoopsLimit exceeds for any loop\"}],\"Unauthorized(address,address,string)\":[{\"notice\":\"Thrown when the action is prohibited by AccessControlManager\"}]},\"events\":{\"BorrowLastRewardingBlockUpdated(address,uint32)\":{\"notice\":\"Emitted when a reward token last rewarding block for borrow is updated\"},\"ContributorRewardTokenSpeedUpdated(address,uint256)\":{\"notice\":\"Emitted when a new REWARD TOKEN speed is set for a contributor\"},\"ContributorRewardsUpdated(address,uint256)\":{\"notice\":\"Emitted when a reward for contributor is updated\"},\"DistributedBorrowerRewardToken(address,address,uint256,uint256,uint256)\":{\"notice\":\"Emitted when REWARD TOKEN is distributed to a borrower\"},\"DistributedSupplierRewardToken(address,address,uint256,uint256,uint256)\":{\"notice\":\"Emitted when REWARD TOKEN is distributed to a supplier\"},\"MarketInitialized(address)\":{\"notice\":\"Emitted when a market is initialized\"},\"MaxLoopsLimitUpdated(uint256,uint256)\":{\"notice\":\"Emitted when max loops limit is set\"},\"NewAccessControlManager(address,address)\":{\"notice\":\"Emitted when access control manager contract address is changed\"},\"RewardTokenBorrowIndexUpdated(address,(uint256))\":{\"notice\":\"Emitted when a reward token borrow index is updated\"},\"RewardTokenBorrowSpeedUpdated(address,uint256)\":{\"notice\":\"Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\"},\"RewardTokenGranted(address,uint256)\":{\"notice\":\"Emitted when REWARD TOKEN is granted by admin\"},\"RewardTokenSupplyIndexUpdated(address)\":{\"notice\":\"Emitted when a reward token supply index is updated\"},\"RewardTokenSupplySpeedUpdated(address,uint256)\":{\"notice\":\"Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\"},\"SupplyLastRewardingBlockUpdated(address,uint32)\":{\"notice\":\"Emitted when a reward token last rewarding block for supply is updated\"}},\"kind\":\"user\",\"methods\":{\"INITIAL_INDEX()\":{\"notice\":\"The initial REWARD TOKEN index for a market\"},\"accessControlManager()\":{\"notice\":\"Returns the address of the access control manager contract\"},\"claimRewardToken(address)\":{\"notice\":\"Claim all the rewardToken accrued by holder in all markets\"},\"claimRewardToken(address,address[])\":{\"notice\":\"Claim all the rewardToken accrued by holder in the specified markets\"},\"distributeBorrowerRewardToken(address,address,(uint256))\":{\"notice\":\"Calculate reward token accrued by a borrower and possibly transfer it to them         Borrowers will begin to accrue after the first interaction with the protocol.\"},\"grantRewardToken(address,uint256)\":{\"notice\":\"Transfer REWARD TOKEN to the recipient\"},\"initialize(address,address,uint256,address)\":{\"notice\":\"RewardsDistributor initializer\"},\"lastContributorBlock(address)\":{\"notice\":\"Last block at which a contributor's REWARD TOKEN rewards have been allocated\"},\"rewardTokenAccrued(address)\":{\"notice\":\"The REWARD TOKEN accrued but not yet transferred to each user\"},\"rewardTokenBorrowSpeeds(address)\":{\"notice\":\"The rate at which rewardToken is distributed to the corresponding borrow market (per block)\"},\"rewardTokenBorrowState(address)\":{\"notice\":\"The REWARD TOKEN market borrow state for each market\"},\"rewardTokenBorrowerIndex(address,address)\":{\"notice\":\"The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\"},\"rewardTokenContributorSpeeds(address)\":{\"notice\":\"The portion of REWARD TOKEN that each contributor receives per block\"},\"rewardTokenSupplierIndex(address,address)\":{\"notice\":\"The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\"},\"rewardTokenSupplySpeeds(address)\":{\"notice\":\"The rate at which rewardToken is distributed to the corresponding supply market (per block)\"},\"rewardTokenSupplyState(address)\":{\"notice\":\"The REWARD TOKEN market supply state for each market\"},\"setAccessControlManager(address)\":{\"notice\":\"Sets the address of AccessControlManager\"},\"setContributorRewardTokenSpeed(address,uint256)\":{\"notice\":\"Set REWARD TOKEN speed for a single contributor\"},\"setLastRewardingBlocks(address[],uint32[],uint32[])\":{\"notice\":\"Set REWARD TOKEN last rewarding block for the specified markets\"},\"setMaxLoopsLimit(uint256)\":{\"notice\":\"Set the limit for the loops can iterate to avoid the DOS\"},\"setRewardTokenSpeeds(address[],uint256[],uint256[])\":{\"notice\":\"Set REWARD TOKEN borrow and supply speeds for the specified markets\"},\"updateContributorRewards(address)\":{\"notice\":\"Calculate additional accrued REWARD TOKEN for a contributor since last accrual\"}},\"notice\":\"Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol. Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool. Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward token to be released each block for borrowers and suppliers, which is distributed based on a user\\u2019s percentage of the borrows or supplies respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting their contributor reward token speed, which similarly allocates a fixed amount of reward token per block. The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Rewards/RewardsDistributor.sol\":\"RewardsDistributor\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x84efb8889801b0ac817324aff6acc691d07bbee816b671817132911d287a8c63\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x4075622496acc77fd6d4de4cc30a8577a744d5c75afad33fdeacf1704d6eda98\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xd60f939a3ca0199014d079b4dd66aa757954334947d81eb5c1d35d7a83061ab3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x4dae161227d332808312ee2caf6384929321b83c16cc89b5642985fbec6b814c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\nimport \\\"./IAccessControlManagerV8.sol\\\";\\n\\n/**\\n * @title Venus Access Control Contract.\\n * @dev The AccessControlledV8 contract is a wrapper around the OpenZeppelin AccessControl contract\\n *      It provides a standardized way to control access to methods within the Venus Smart Contract Ecosystem.\\n *      The contract allows the owner to set an AccessControlManager contract address.\\n *      It can restrict method calls based on the sender's role and the method's signature.\\n */\\n\\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\\n    /// @notice Access control manager contract\\n    IAccessControlManagerV8 private _accessControlManager;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when access control manager contract address is changed\\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\\n\\n    /// @notice Thrown when the action is prohibited by AccessControlManager\\n    error Unauthorized(address sender, address calledContract, string methodSignature);\\n\\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n    }\\n\\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Sets the address of AccessControlManager\\n     * @dev Admin function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     * @custom:event Emits NewAccessControlManager event\\n     * @custom:access Only Governance\\n     */\\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the access control manager contract\\n     */\\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\\n        return _accessControlManager;\\n    }\\n\\n    /**\\n     * @dev Internal function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     */\\n    function _setAccessControlManager(address accessControlManager_) internal {\\n        require(address(accessControlManager_) != address(0), \\\"invalid acess control manager address\\\");\\n        address oldAccessControlManager = address(_accessControlManager);\\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Reverts if the call is not allowed by AccessControlManager\\n     * @param signature Method signature\\n     */\\n    function _checkAccessAllowed(string memory signature) internal view {\\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\\n\\n        if (!isAllowedToCall) {\\n            revert Unauthorized(msg.sender, address(this), signature);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x618d942756b93e02340a42f3c80aa99fc56be1a96861f5464dc23a76bf30b3a5\",\"license\":\"BSD-3-Clause\"},\"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IAccessControlManagerV8 is IAccessControl {\\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\\n\\n    function revokeCallPermission(\\n        address contractAddress,\\n        string calldata functionSig,\\n        address accountToRevoke\\n    ) external;\\n\\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\\n\\n    function hasPermission(\\n        address account,\\n        address contractAddress,\\n        string calldata functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x41deef84d1839590b243b66506691fde2fb938da01eabde53e82d3b8316fdaf9\",\"license\":\"BSD-3-Clause\"},\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\ninterface OracleInterface {\\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\\n}\\n\\ninterface ResilientOracleInterface is OracleInterface {\\n    function updatePrice(address vToken) external;\\n}\\n\\ninterface TwapInterface is OracleInterface {\\n    function updateTwap(address vToken) external returns (uint256);\\n}\\n\\ninterface BoundValidatorInterface {\\n    function validatePriceWithAnchorPrice(\\n        address vToken,\\n        uint256 reporterPrice,\\n        uint256 anchorPrice\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8ac0bda5d5789c320bf219dc6691eef0e6617e9653bc0e24f407a44e4281edda\",\"license\":\"BSD-3-Clause\"},\"contracts/Comptroller.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { ComptrollerStorage } from \\\"./ComptrollerStorage.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"./MaxLoopsLimitHelper.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title Comptroller\\n * @author Venus\\n * @notice The Comptroller is designed to provide checks for all minting, redeeming, transferring, borrowing, lending, repaying, liquidating,\\n * and seizing done by the `vToken` contract. Each pool has one `Comptroller` checking these interactions across markets. When a user interacts\\n * with a given market by one of these main actions, a call is made to a corresponding hook in the associated `Comptroller`, which either allows\\n * or reverts the transaction. These hooks also update supply and borrow rewards as they are called. The comptroller holds the logic for assessing\\n * liquidity snapshots of an account via the collateral factor and liquidation threshold. This check determines the collateral needed for a borrow,\\n * as well as how much of a borrow may be liquidated. A user may borrow a portion of their collateral with the maximum amount determined by the\\n * markets collateral factor. However, if their borrowed amount exceeds an amount calculated using the market\\u2019s corresponding liquidation threshold,\\n * the borrow is eligible for liquidation.\\n *\\n * The `Comptroller` also includes two functions `liquidateAccount()` and `healAccount()`, which are meant to handle accounts that do not exceed\\n * the `minLiquidatableCollateral` for the `Comptroller`:\\n *\\n * - `healAccount()`: This function is called to seize all of a given user\\u2019s collateral, requiring the `msg.sender` repay a certain percentage\\n * of the debt calculated by `collateral/(borrows*liquidationIncentive)`. The function can only be called if the calculated percentage does not exceed\\n * 100%, because otherwise no `badDebt` would be created and `liquidateAccount()` should be used instead. The difference in the actual amount of debt\\n * and debt paid off is recorded as `badDebt` for each market, which can then be auctioned off for the risk reserves of the associated pool.\\n * - `liquidateAccount()`: This function can only be called if the collateral seized will cover all borrows of an account, as well as the liquidation\\n * incentive. Otherwise, the pool will incur bad debt, in which case the function `healAccount()` should be used instead. This function skips the logic\\n * verifying that the repay amount does not exceed the close factor.\\n */\\ncontract Comptroller is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    ComptrollerStorage,\\n    ComptrollerInterface,\\n    ExponentialNoError,\\n    MaxLoopsLimitHelper\\n{\\n    // PoolRegistry, immutable to save on gas\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable poolRegistry;\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\\n\\n    /// @notice Emitted when a collateral factor is changed by admin\\n    event NewCollateralFactor(VToken vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\\n\\n    /// @notice Emitted when liquidation threshold is changed by admin\\n    event NewLiquidationThreshold(\\n        VToken vToken,\\n        uint256 oldLiquidationThresholdMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    );\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\\n\\n    /// @notice Emitted when an action is paused on a market\\n    event ActionPausedMarket(VToken vToken, Action action, bool pauseState);\\n\\n    /// @notice Emitted when borrow cap for a vToken is changed\\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\\n\\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\\n    event NewMinLiquidatableCollateral(uint256 oldMinLiquidatableCollateral, uint256 newMinLiquidatableCollateral);\\n\\n    /// @notice Emitted when supply cap for a vToken is changed\\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\\n\\n    /// @notice Emitted when a rewards distributor is added\\n    event NewRewardsDistributor(address indexed rewardsDistributor);\\n\\n    /// @notice Emitted when a market is supported\\n    event MarketSupported(VToken vToken);\\n\\n    /// @notice Thrown when collateral factor exceeds the upper bound\\n    error InvalidCollateralFactor();\\n\\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\\n    error InvalidLiquidationThreshold();\\n\\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\\n    error UnexpectedSender(address expectedSender, address actualSender);\\n\\n    /// @notice Thrown when the oracle returns an invalid price for some asset\\n    error PriceError(address vToken);\\n\\n    /// @notice Thrown if VToken unexpectedly returned a nonzero error code while trying to get account snapshot\\n    error SnapshotError(address vToken, address user);\\n\\n    /// @notice Thrown when the market is not listed\\n    error MarketNotListed(address market);\\n\\n    /// @notice Thrown when a market has an unexpected comptroller\\n    error ComptrollerMismatch();\\n\\n    /// @notice Thrown when user is not member of market\\n    error MarketNotCollateral(address vToken, address user);\\n\\n    /**\\n     * @notice Thrown during the liquidation if user's total collateral amount is lower than\\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\\n     *   or healAccount) are available.\\n     */\\n    error MinimalCollateralViolated(uint256 expectedGreaterThan, uint256 actual);\\n    error CollateralExceedsThreshold(uint256 expectedLessThanOrEqualTo, uint256 actual);\\n    error InsufficientCollateral(uint256 collateralToSeize, uint256 availableCollateral);\\n\\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\\n    error InsufficientLiquidity();\\n\\n    /// @notice Thrown when trying to liquidate a healthy account\\n    error InsufficientShortfall();\\n\\n    /// @notice Thrown when trying to repay more than allowed by close factor\\n    error TooMuchRepay();\\n\\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\\n    error NonzeroBorrowBalance();\\n\\n    /// @notice Thrown when trying to perform an action that is paused\\n    error ActionPaused(address market, Action action);\\n\\n    /// @notice Thrown when trying to add a market that is already listed\\n    error MarketAlreadyListed(address market);\\n\\n    /// @notice Thrown if the supply cap is exceeded\\n    error SupplyCapExceeded(address market, uint256 cap);\\n\\n    /// @notice Thrown if the borrow cap is exceeded\\n    error BorrowCapExceeded(address market, uint256 cap);\\n\\n    /// @param poolRegistry_ Pool registry address\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\\n    constructor(address poolRegistry_) {\\n        ensureNonzeroAddress(poolRegistry_);\\n\\n        poolRegistry = poolRegistry_;\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\\n     * @param accessControlManager Access control manager contract address\\n     */\\n    function initialize(uint256 loopLimit, address accessControlManager) external initializer {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager);\\n\\n        _setMaxLoopsLimit(loopLimit);\\n    }\\n\\n    /**\\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\\n     * @param vTokens The list of addresses of the vToken markets to be enabled\\n     * @return errors An array of NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketEntered is emitted for each market on success\\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\\n     * @custom:access Not restricted\\n     */\\n    function enterMarkets(address[] memory vTokens) external override returns (uint256[] memory) {\\n        uint256 len = vTokens.length;\\n\\n        uint256[] memory results = new uint256[](len);\\n        for (uint256 i; i < len; ++i) {\\n            VToken vToken = VToken(vTokens[i]);\\n\\n            _addToMarket(vToken, msg.sender);\\n            results[i] = NO_ERROR;\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param vTokenAddress The address of the asset to be removed\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketExited is emitted on success\\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function exitMarket(address vTokenAddress) external override returns (uint256) {\\n        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\\n        VToken vToken = VToken(vTokenAddress);\\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);\\n\\n        /* Fail if the sender has a borrow balance */\\n        if (amountOwed != 0) {\\n            revert NonzeroBorrowBalance();\\n        }\\n\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\n        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);\\n\\n        Market storage marketToExit = markets[address(vToken)];\\n\\n        /* Return true if the sender is not already \\u2018in\\u2019 the market */\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Set vToken account membership to false */\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        /* Delete vToken from the account\\u2019s list of assets */\\n        // load into memory for faster iteration\\n        VToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint256 len = userAssetList.length;\\n\\n        uint256 assetIndex = len;\\n        for (uint256 i; i < len; ++i) {\\n            if (userAssetList[i] == vToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        VToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(vToken, msg.sender);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param vToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\\n     * @custom:access Not restricted\\n     */\\n    function preMintHook(\\n        address vToken,\\n        address minter,\\n        uint256 mintAmount\\n    ) external override {\\n        _checkActionPauseState(vToken, Action.MINT);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        uint256 supplyCap = supplyCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (supplyCap != type(uint256).max) {\\n            uint256 vTokenSupply = VToken(vToken).totalSupply();\\n            Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\\n            if (nextTotalSupply > supplyCap) {\\n                revert SupplyCapExceeded(vToken, supplyCap);\\n            }\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, minter);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param vToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preRedeemHook(\\n        address vToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) external override {\\n        _checkActionPauseState(vToken, Action.REDEEM);\\n\\n        _checkRedeemAllowed(vToken, redeemer, redeemTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, redeemer);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param vToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @custom:error ActionPaused error is thrown if borrowing is paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if there is not enough collateral to borrow\\n     * @custom:error BorrowCapExceeded is thrown if the borrow cap will be exceeded should this borrow succeed\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted if vToken is enabled as collateral, otherwise only vToken\\n     */\\n    /// disable-eslint\\n    function preBorrowHook(\\n        address vToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external override {\\n        _checkActionPauseState(vToken, Action.BORROW);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (!markets[vToken].accountMembership[borrower]) {\\n            // only vTokens may call borrowAllowed if borrower not in market\\n            _checkSenderIs(vToken);\\n\\n            // attempt to add borrower to the market or revert\\n            _addToMarket(VToken(msg.sender), borrower);\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 borrowCap = borrowCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (borrowCap != type(uint256).max) {\\n            uint256 totalBorrows = VToken(vToken).totalBorrows();\\n            uint256 nextTotalBorrows = totalBorrows + borrowAmount;\\n            if (nextTotalBorrows > borrowCap) {\\n                revert BorrowCapExceeded(vToken, borrowCap);\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            borrower,\\n            VToken(vToken),\\n            0,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param vToken The market to verify the repay against\\n     * @param borrower The account which would borrowed the asset\\n     * @custom:error ActionPaused error is thrown if repayments are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:access Not restricted\\n     */\\n    function preRepayHook(address vToken, address borrower) external override {\\n        _checkActionPauseState(vToken, Action.REPAY);\\n\\n        oracle.updatePrice(vToken);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     * @param skipLiquidityCheck Allows the borrow to be liquidated regardless of the account liquidity\\n     * @custom:error ActionPaused error is thrown if liquidations are paused in this market\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error TooMuchRepay error is thrown if the liquidator is trying to repay more than allowed by close factor\\n     * @custom:error MinimalCollateralViolated is thrown if the users' total collateral is lower than the threshold for non-batch liquidations\\n     * @custom:error InsufficientShortfall is thrown when trying to liquidate a healthy account\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     */\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.\\n        // If we want to pause liquidating to vTokenCollateral, we should pause\\n        // Action.SEIZE on it\\n        _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (!markets[vTokenBorrowed].isListed) {\\n            revert MarketNotListed(address(vTokenBorrowed));\\n        }\\n        if (!markets[vTokenCollateral].isListed) {\\n            revert MarketNotListed(address(vTokenCollateral));\\n        }\\n\\n        uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\\n\\n        /* Allow accounts to be liquidated if the market is deprecated or it is a forced liquidation */\\n        if (skipLiquidityCheck || isDeprecated(VToken(vTokenBorrowed))) {\\n            if (repayAmount > borrowBalance) {\\n                revert TooMuchRepay();\\n            }\\n            return;\\n        }\\n\\n        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral <= minLiquidatableCollateral) {\\n            /* The liquidator should use either liquidateAccount or healAccount */\\n            revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\n        uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\\n        if (repayAmount > maxClose) {\\n            revert TooMuchRepay();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param seizerContract Contract that tries to seize the asset (either borrowed vToken or Comptroller)\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools\\n     * @custom:access Not restricted\\n     */\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address seizerContract,\\n        address liquidator,\\n        address borrower\\n    ) external override {\\n        // Pause Action.SEIZE on COLLATERAL to prevent seizing it.\\n        // If we want to pause liquidating vTokenBorrowed, we should pause\\n        // Action.LIQUIDATE on it\\n        _checkActionPauseState(vTokenCollateral, Action.SEIZE);\\n\\n        Market storage market = markets[vTokenCollateral];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(vTokenCollateral);\\n        }\\n\\n        if (seizerContract == address(this)) {\\n            // If Comptroller is the seizer, just check if collateral's comptroller\\n            // is equal to the current address\\n            if (address(VToken(vTokenCollateral).comptroller()) != address(this)) {\\n                revert ComptrollerMismatch();\\n            }\\n        } else {\\n            // If the seizer is not the Comptroller, check that the seizer is a\\n            // listed market, and that the markets' comptrollers match\\n            if (!markets[seizerContract].isListed) {\\n                revert MarketNotListed(seizerContract);\\n            }\\n            if (VToken(vTokenCollateral).comptroller() != VToken(seizerContract).comptroller()) {\\n                revert ComptrollerMismatch();\\n            }\\n        }\\n\\n        if (!market.accountMembership[borrower]) {\\n            revert MarketNotCollateral(vTokenCollateral, borrower);\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vTokenCollateral);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, borrower);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, liquidator);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param vToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of vTokens to transfer\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preTransferHook(\\n        address vToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external override {\\n        _checkActionPauseState(vToken, Action.TRANSFER);\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        _checkRedeemAllowed(vToken, src, transferTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, src);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, dst);\\n        }\\n    }\\n\\n    /*** Pool-level operations ***/\\n\\n    /**\\n     * @notice Seizes all the remaining collateral, makes msg.sender repay the existing\\n     *   borrows, and treats the rest of the debt as bad debt (for each market).\\n     *   The sender has to repay a certain percentage of the debt, computed as\\n     *   collateral / (borrows * liquidationIncentive).\\n     * @param user account to heal\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for healing\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function healAccount(address user) external {\\n        VToken[] memory userAssets = accountAssets[user];\\n        uint256 userAssetsCount = userAssets.length;\\n\\n        address liquidator = msg.sender;\\n        {\\n            ResilientOracleInterface oracle_ = oracle;\\n            // We need all user's markets to be fresh for the computations to be correct\\n            for (uint256 i; i < userAssetsCount; ++i) {\\n                userAssets[i].accrueInterest();\\n                oracle_.updatePrice(address(userAssets[i]));\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(user, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        // percentage = collateral / (borrows * liquidation incentive)\\n        Exp memory collateral = Exp({ mantissa: snapshot.totalCollateral });\\n        Exp memory scaledBorrows = mul_(\\n            Exp({ mantissa: snapshot.borrows }),\\n            Exp({ mantissa: liquidationIncentiveMantissa })\\n        );\\n\\n        Exp memory percentage = div_(collateral, scaledBorrows);\\n        if (lessThanExp(Exp({ mantissa: MANTISSA_ONE }), percentage)) {\\n            revert CollateralExceedsThreshold(scaledBorrows.mantissa, collateral.mantissa);\\n        }\\n\\n        for (uint256 i; i < userAssetsCount; ++i) {\\n            VToken market = userAssets[i];\\n\\n            (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(market, user);\\n            uint256 repaymentAmount = mul_ScalarTruncate(percentage, borrowBalance);\\n\\n            // Seize the entire collateral\\n            if (tokens != 0) {\\n                market.seize(liquidator, user, tokens);\\n            }\\n            // Repay a certain percentage of the borrow, forgive the rest\\n            if (borrowBalance != 0) {\\n                market.healBorrow(liquidator, user, repaymentAmount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Liquidates all borrows of the borrower. Callable only if the collateral is less than\\n     *   a predefined threshold, and the account collateral can be seized to cover all borrows. If\\n     *   the collateral is higher than the threshold, use regular liquidations. If the collateral is\\n     *   below the threshold, and the account is insolvent, use healAccount.\\n     * @param borrower the borrower address\\n     * @param orders an array of liquidation orders\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for a batch liquidation\\n     * @custom:error InsufficientCollateral error is thrown when there is not enough collateral to cover the debt\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function liquidateAccount(address borrower, LiquidationOrder[] calldata orders) external {\\n        // We will accrue interest and update the oracle prices later during the liquidation\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            // You should use the regular vToken.liquidateBorrow(...) call\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        uint256 collateralToSeize = mul_ScalarTruncate(\\n            Exp({ mantissa: liquidationIncentiveMantissa }),\\n            snapshot.borrows\\n        );\\n        if (collateralToSeize >= snapshot.totalCollateral) {\\n            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow\\n            // and record bad debt.\\n            revert InsufficientCollateral(collateralToSeize, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        uint256 ordersCount = orders.length;\\n\\n        _ensureMaxLoops(ordersCount / 2);\\n\\n        for (uint256 i; i < ordersCount; ++i) {\\n            if (!markets[address(orders[i].vTokenBorrowed)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenBorrowed));\\n            }\\n            if (!markets[address(orders[i].vTokenCollateral)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenCollateral));\\n            }\\n\\n            LiquidationOrder calldata order = orders[i];\\n            order.vTokenBorrowed.forceLiquidateBorrow(\\n                msg.sender,\\n                borrower,\\n                order.repayAmount,\\n                order.vTokenCollateral,\\n                true\\n            );\\n        }\\n\\n        VToken[] memory borrowMarkets = accountAssets[borrower];\\n        uint256 marketsCount = borrowMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);\\n            require(borrowBalance == 0, \\\"Nonzero borrow balance after liquidation\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the closeFactor to use when liquidating borrows\\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n     * @custom:event Emits NewCloseFactor on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCloseFactor(uint256 newCloseFactorMantissa) external {\\n        _checkAccessAllowed(\\\"setCloseFactor(uint256)\\\");\\n        require(MAX_CLOSE_FACTOR_MANTISSA >= newCloseFactorMantissa, \\\"Close factor greater than maximum close factor\\\");\\n        require(MIN_CLOSE_FACTOR_MANTISSA <= newCloseFactorMantissa, \\\"Close factor smaller than minimum close factor\\\");\\n\\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Sets the collateralFactor for a market\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param vToken The market to set the factor on\\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\\n     * @custom:event Emits NewCollateralFactor when collateral factor is updated\\n     *    and NewLiquidationThreshold when liquidation threshold is updated\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InvalidCollateralFactor error is thrown when collateral factor is too high\\n     * @custom:error InvalidLiquidationThreshold error is thrown when liquidation threshold is lower than collateral factor\\n     * @custom:error PriceError is thrown when the oracle returns an invalid price for the asset\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCollateralFactor(\\n        VToken vToken,\\n        uint256 newCollateralFactorMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    ) external {\\n        _checkAccessAllowed(\\\"setCollateralFactor(address,uint256,uint256)\\\");\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(vToken)];\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Check collateral factor <= 0.9\\n        if (newCollateralFactorMantissa > MAX_COLLATERAL_FACTOR_MANTISSA) {\\n            revert InvalidCollateralFactor();\\n        }\\n\\n        // Ensure that liquidation threshold <= 1\\n        if (newLiquidationThresholdMantissa > MANTISSA_ONE) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // Ensure that liquidation threshold >= CF\\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\\n            emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n        }\\n\\n        uint256 oldLiquidationThresholdMantissa = market.liquidationThresholdMantissa;\\n        if (newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa) {\\n            market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\\n            emit NewLiquidationThreshold(vToken, oldLiquidationThresholdMantissa, newLiquidationThresholdMantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets liquidationIncentive\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n     * @custom:event Emits NewLiquidationIncentive on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external {\\n        require(newLiquidationIncentiveMantissa >= MANTISSA_ONE, \\\"liquidation incentive should be greater than 1e18\\\");\\n\\n        _checkAccessAllowed(\\\"setLiquidationIncentive(uint256)\\\");\\n\\n        // Save current value for use in log\\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n    }\\n\\n    /**\\n     * @notice Add the market to the markets mapping and set it as listed\\n     * @dev Only callable by the PoolRegistry\\n     * @param vToken The address of the market (token) to list\\n     * @custom:error MarketAlreadyListed is thrown if the market is already listed in this pool\\n     * @custom:access Only PoolRegistry\\n     */\\n    function supportMarket(VToken vToken) external {\\n        _checkSenderIs(poolRegistry);\\n\\n        if (markets[address(vToken)].isListed) {\\n            revert MarketAlreadyListed(address(vToken));\\n        }\\n\\n        require(vToken.isVToken(), \\\"Comptroller: Invalid vToken\\\"); // Sanity check to make sure its really a VToken\\n\\n        Market storage newMarket = markets[address(vToken)];\\n        newMarket.isListed = true;\\n        newMarket.collateralFactorMantissa = 0;\\n        newMarket.liquidationThresholdMantissa = 0;\\n\\n        _addMarket(address(vToken));\\n\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            rewardsDistributors[i].initializeMarket(address(vToken));\\n        }\\n\\n        emit MarketSupported(vToken);\\n    }\\n\\n    /**\\n     * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A borrow cap of type(uint256).max corresponds to unlimited borrowing.\\n     * @dev Borrow caps smaller than the current total borrows are accepted. This way, new borrows will not be allowed\\n            until the total borrows amount goes below the new borrow cap\\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited borrowing.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\\n        _checkAccessAllowed(\\\"setMarketBorrowCaps(address[],uint256[])\\\");\\n\\n        uint256 numMarkets = vTokens.length;\\n        uint256 numBorrowCaps = newBorrowCaps.length;\\n\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\n\\n        _ensureMaxLoops(numMarkets);\\n\\n        for (uint256 i; i < numMarkets; ++i) {\\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A supply cap of type(uint256).max corresponds to unlimited supply.\\n     * @dev Supply caps smaller than the current total supplies are accepted. This way, new supplies will not be allowed\\n            until the total supplies amount goes below the new supply cap\\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited supply.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\\n        _checkAccessAllowed(\\\"setMarketSupplyCaps(address[],uint256[])\\\");\\n        uint256 vTokensCount = vTokens.length;\\n\\n        require(vTokensCount != 0, \\\"invalid number of markets\\\");\\n        require(vTokensCount == newSupplyCaps.length, \\\"invalid number of markets\\\");\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pause/unpause specified actions\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param marketsList Markets to pause/unpause the actions on\\n     * @param actionsList List of action ids to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setActionsPaused(\\n        VToken[] calldata marketsList,\\n        Action[] calldata actionsList,\\n        bool paused\\n    ) external {\\n        _checkAccessAllowed(\\\"setActionsPaused(address[],uint256[],bool)\\\");\\n\\n        uint256 marketsCount = marketsList.length;\\n        uint256 actionsCount = actionsList.length;\\n\\n        _ensureMaxLoops(marketsCount * actionsCount);\\n\\n        for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {\\n            for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) {\\n                _setActionPaused(address(marketsList[marketIdx]), actionsList[actionIdx], paused);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given collateral threshold for non-batch liquidations. Regular liquidations\\n     *   will fail if the collateral amount is less than this threshold. Liquidators should use batch\\n     *   operations like liquidateAccount or healAccount.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newMinLiquidatableCollateral The new min liquidatable collateral (in USD).\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMinLiquidatableCollateral(uint256 newMinLiquidatableCollateral) external {\\n        _checkAccessAllowed(\\\"setMinLiquidatableCollateral(uint256)\\\");\\n\\n        uint256 oldMinLiquidatableCollateral = minLiquidatableCollateral;\\n        minLiquidatableCollateral = newMinLiquidatableCollateral;\\n        emit NewMinLiquidatableCollateral(oldMinLiquidatableCollateral, newMinLiquidatableCollateral);\\n    }\\n\\n    /**\\n     * @notice Add a new RewardsDistributor and initialize it with all markets\\n     * @dev Only callable by the admin\\n     * @param _rewardsDistributor Address of the RewardDistributor contract to add\\n     * @custom:access Only Governance\\n     * @custom:event Emits NewRewardsDistributor with distributor address\\n     */\\n    function addRewardsDistributor(RewardsDistributor _rewardsDistributor) external onlyOwner {\\n        require(!rewardsDistributorExists[address(_rewardsDistributor)], \\\"already exists\\\");\\n\\n        uint256 rewardsDistributorsLength = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardsDistributorsLength; ++i) {\\n            address rewardToken = address(rewardsDistributors[i].rewardToken());\\n            require(\\n                rewardToken != address(_rewardsDistributor.rewardToken()),\\n                \\\"distributor already exists with this reward\\\"\\n            );\\n        }\\n\\n        uint256 rewardsDistributorsLen = rewardsDistributors.length;\\n        _ensureMaxLoops(rewardsDistributorsLen + 1);\\n\\n        rewardsDistributors.push(_rewardsDistributor);\\n        rewardsDistributorExists[address(_rewardsDistributor)] = true;\\n\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            _rewardsDistributor.initializeMarket(address(allMarkets[i]));\\n        }\\n\\n        emit NewRewardsDistributor(address(_rewardsDistributor));\\n    }\\n\\n    /**\\n     * @notice Sets a new price oracle for the Comptroller\\n     * @dev Only callable by the admin\\n     * @param newOracle Address of the new price oracle to set\\n     * @custom:event Emits NewPriceOracle on success\\n     * @custom:error ZeroAddressNotAllowed is thrown when the new oracle address is zero\\n     */\\n    function setPriceOracle(ResilientOracleInterface newOracle) external onlyOwner {\\n        ensureNonzeroAddress(address(newOracle));\\n\\n        ResilientOracleInterface oldOracle = oracle;\\n        oracle = newOracle;\\n        emit NewPriceOracle(oldOracle, newOracle);\\n    }\\n\\n    /**\\n     * @notice Set the for loop iteration limit to avoid DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to liquidation threshold requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of liquidation threshold requirements,\\n     * @return shortfall Account shortfall below liquidation threshold requirements\\n     */\\n    function getAccountLiquidity(address account)\\n        external\\n        view\\n        returns (\\n            uint256 error,\\n            uint256 liquidity,\\n            uint256 shortfall\\n        )\\n    {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getLiquidationThreshold);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to collateral requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of collateral requirements,\\n     * @return shortfall Account shortfall below collateral requirements\\n     */\\n    function getBorrowingPower(address account)\\n        external\\n        view\\n        returns (\\n            uint256 error,\\n            uint256 liquidity,\\n            uint256 shortfall\\n        )\\n    {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getCollateralFactor);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Hypothetical account liquidity in excess of collateral requirements,\\n     * @return shortfall Hypothetical account shortfall below collateral requirements\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 error,\\n            uint256 liquidity,\\n            uint256 shortfall\\n        )\\n    {\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            account,\\n            VToken(vTokenModify),\\n            redeemTokens,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Return all of the markets\\n     * @dev The automatic getter may be used to access an individual market.\\n     * @return markets The list of market addresses\\n     */\\n    function getAllMarkets() external view override returns (VToken[] memory) {\\n        return allMarkets;\\n    }\\n\\n    /**\\n     * @notice Check if a market is marked as listed (active)\\n     * @param vToken vToken Address for the market to check\\n     * @return listed True if listed otherwise false\\n     */\\n    function isMarketListed(VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].isListed;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A list with the assets the account has entered\\n     */\\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\\n        VToken[] memory assetsIn = accountAssets[account];\\n\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in a given market\\n     * @param account The address of the account to check\\n     * @param vToken The vToken to check\\n     * @return True if the account is in the market specified, otherwise false.\\n     */\\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].accountMembership[account];\\n    }\\n\\n    /**\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\\n     * @param vTokenBorrowed The address of the borrowed vToken\\n     * @param vTokenCollateral The address of the collateral vToken\\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return tokensToSeize Number of vTokenCollateral tokens to be seized in a liquidation\\n     * @custom:error PriceError if the oracle returns an invalid price\\n     */\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 actualRepayAmount\\n    ) external view override returns (uint256 error, uint256 tokensToSeize) {\\n        /* Read oracle prices for borrowed and collateral markets */\\n        uint256 priceBorrowedMantissa = _safeGetUnderlyingPrice(VToken(vTokenBorrowed));\\n        uint256 priceCollateralMantissa = _safeGetUnderlyingPrice(VToken(vTokenCollateral));\\n\\n        /*\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n         *  seizeTokens = seizeAmount / exchangeRate\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n         */\\n        uint256 exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\\n        uint256 seizeTokens;\\n        Exp memory numerator;\\n        Exp memory denominator;\\n        Exp memory ratio;\\n\\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\\n        ratio = div_(numerator, denominator);\\n\\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n\\n        return (NO_ERROR, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Returns reward speed given a vToken\\n     * @param vToken The vToken to get the reward speeds for\\n     * @return rewardSpeeds Array of total supply and borrow speeds and reward token for all reward distributors\\n     */\\n    function getRewardsByMarket(address vToken) external view returns (RewardSpeeds[] memory rewardSpeeds) {\\n        uint256 rewardsDistributorsLength = rewardsDistributors.length;\\n        rewardSpeeds = new RewardSpeeds[](rewardsDistributorsLength);\\n        for (uint256 i; i < rewardsDistributorsLength; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            address rewardToken = address(rewardsDistributor.rewardToken());\\n            rewardSpeeds[i] = RewardSpeeds({\\n                rewardToken: rewardToken,\\n                supplySpeed: rewardsDistributor.rewardTokenSupplySpeeds(vToken),\\n                borrowSpeed: rewardsDistributor.rewardTokenBorrowSpeeds(vToken)\\n            });\\n        }\\n        return rewardSpeeds;\\n    }\\n\\n    /**\\n     * @notice Return all reward distributors for this pool\\n     * @return Array of RewardDistributor addresses\\n     */\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory) {\\n        return rewardsDistributors;\\n    }\\n\\n    /**\\n     * @notice A marker method that returns true for a valid Comptroller contract\\n     * @return Always true\\n     */\\n    function isComptroller() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Update the prices of all the tokens associated with the provided account\\n     * @param account Address of the account to get associated tokens with\\n     */\\n    function updatePrices(address account) public {\\n        VToken[] memory vTokens = accountAssets[account];\\n        uint256 vTokensCount = vTokens.length;\\n\\n        ResilientOracleInterface oracle_ = oracle;\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            oracle_.updatePrice(address(vTokens[i]));\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a certain action is paused on a market\\n     * @param market vToken address\\n     * @param action Action to check\\n     * @return paused True if the action is paused otherwise false\\n     */\\n    function actionPaused(address market, Action action) public view returns (bool) {\\n        return _actionPaused[market][action];\\n    }\\n\\n    /**\\n     * @notice Check if a vToken market has been deprecated\\n     * @dev All borrows in a deprecated vToken market can be immediately liquidated\\n     * @param vToken The market to check if deprecated\\n     * @return deprecated True if the given vToken market has been deprecated\\n     */\\n    function isDeprecated(VToken vToken) public view returns (bool) {\\n        return\\n            markets[address(vToken)].collateralFactorMantissa == 0 &&\\n            actionPaused(address(vToken), Action.BORROW) &&\\n            vToken.reserveFactorMantissa() == MANTISSA_ONE;\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param vToken The market to enter\\n     * @param borrower The address of the account to modify\\n     */\\n    function _addToMarket(VToken vToken, address borrower) internal {\\n        _checkActionPauseState(address(vToken), Action.ENTER_MARKET);\\n        Market storage marketToJoin = markets[address(vToken)];\\n\\n        if (!marketToJoin.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower]) {\\n            // already joined\\n            return;\\n        }\\n\\n        // survived the gauntlet, add to list\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\n        //  this avoids having to iterate through the list for the most common use cases\\n        //  that is, only when we need to perform liquidity checks\\n        //  and not whenever we want to check if an account is in a particular market\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(vToken);\\n\\n        emit MarketEntered(vToken, borrower);\\n    }\\n\\n    /**\\n     * @notice Internal function to validate that a market hasn't already been added\\n     * and if it hasn't adds it\\n     * @param vToken The market to support\\n     */\\n    function _addMarket(address vToken) internal {\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            if (allMarkets[i] == VToken(vToken)) {\\n                revert MarketAlreadyListed(vToken);\\n            }\\n        }\\n        allMarkets.push(VToken(vToken));\\n        marketsCount = allMarkets.length;\\n        _ensureMaxLoops(marketsCount);\\n    }\\n\\n    /**\\n     * @dev Pause/unpause an action on a market\\n     * @param market Market to pause/unpause the action on\\n     * @param action Action id to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     */\\n    function _setActionPaused(\\n        address market,\\n        Action action,\\n        bool paused\\n    ) internal {\\n        require(markets[market].isListed, \\\"cannot pause a market that is not listed\\\");\\n        _actionPaused[market][action] = paused;\\n        emit ActionPausedMarket(VToken(market), action, paused);\\n    }\\n\\n    /**\\n     * @dev Internal function to check that vTokens can be safely redeemed for the underlying asset.\\n     * @param vToken Address of the vTokens to redeem\\n     * @param redeemer Account redeeming the tokens\\n     * @param redeemTokens The number of tokens to redeem\\n     */\\n    function _checkRedeemAllowed(\\n        address vToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) internal {\\n        Market storage market = markets[vToken];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!market.accountMembership[redeemer]) {\\n            return;\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(redeemer);\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            redeemer,\\n            VToken(vToken),\\n            redeemTokens,\\n            0,\\n            _getCollateralFactor\\n        );\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the total collateral, weighted collateral, borrow balance, liquidity, shortfall\\n     * @param account The account to get the snapshot for\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\n     *  liquidation threshold. Accepts the address of the vToken and returns the weight as Exp.\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getCurrentLiquiditySnapshot(address account, function(VToken) internal view returns (Exp memory) weight)\\n        internal\\n        view\\n        returns (AccountLiquiditySnapshot memory snapshot)\\n    {\\n        return _getHypotheticalLiquiditySnapshot(account, VToken(address(0)), 0, 0, weight);\\n    }\\n\\n    /**\\n     * @notice Determine what the supply/borrow balances would be if the given amounts were redeemed/borrowed\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\n         liquidation threshold. Accepts the address of the VToken and returns the weight\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getHypotheticalLiquiditySnapshot(\\n        address account,\\n        VToken vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount,\\n        function(VToken) internal view returns (Exp memory) weight\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\n        // For each asset the account is in\\n        VToken[] memory assets = accountAssets[account];\\n        uint256 assetsCount = assets.length;\\n\\n        for (uint256 i; i < assetsCount; ++i) {\\n            VToken asset = assets[i];\\n\\n            // Read the balances and exchange rate from the vToken\\n            (uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) = _safeGetAccountSnapshot(\\n                asset,\\n                account\\n            );\\n\\n            // Get the normalized price of the asset\\n            Exp memory oraclePrice = Exp({ mantissa: _safeGetUnderlyingPrice(asset) });\\n\\n            // Pre-compute conversion factors from vTokens -> usd\\n            Exp memory vTokenPrice = mul_(Exp({ mantissa: exchangeRateMantissa }), oraclePrice);\\n            Exp memory weightedVTokenPrice = mul_(weight(asset), vTokenPrice);\\n\\n            // weightedCollateral += weightedVTokenPrice * vTokenBalance\\n            snapshot.weightedCollateral = mul_ScalarTruncateAddUInt(\\n                weightedVTokenPrice,\\n                vTokenBalance,\\n                snapshot.weightedCollateral\\n            );\\n\\n            // totalCollateral += vTokenPrice * vTokenBalance\\n            snapshot.totalCollateral = mul_ScalarTruncateAddUInt(vTokenPrice, vTokenBalance, snapshot.totalCollateral);\\n\\n            // borrows += oraclePrice * borrowBalance\\n            snapshot.borrows = mul_ScalarTruncateAddUInt(oraclePrice, borrowBalance, snapshot.borrows);\\n\\n            // Calculate effects of interacting with vTokenModify\\n            if (asset == vTokenModify) {\\n                // redeem effect\\n                // effects += tokensToDenom * redeemTokens\\n                snapshot.effects = mul_ScalarTruncateAddUInt(weightedVTokenPrice, redeemTokens, snapshot.effects);\\n\\n                // borrow effect\\n                // effects += oraclePrice * borrowAmount\\n                snapshot.effects = mul_ScalarTruncateAddUInt(oraclePrice, borrowAmount, snapshot.effects);\\n            }\\n        }\\n\\n        uint256 borrowPlusEffects = snapshot.borrows + snapshot.effects;\\n        // These are safe, as the underflow condition is checked first\\n        unchecked {\\n            if (snapshot.weightedCollateral > borrowPlusEffects) {\\n                snapshot.liquidity = snapshot.weightedCollateral - borrowPlusEffects;\\n                snapshot.shortfall = 0;\\n            } else {\\n                snapshot.liquidity = 0;\\n                snapshot.shortfall = borrowPlusEffects - snapshot.weightedCollateral;\\n            }\\n        }\\n\\n        return snapshot;\\n    }\\n\\n    /**\\n     * @dev Retrieves price from oracle for an asset and checks it is nonzero\\n     * @param asset Address for asset to query price\\n     * @return Underlying price\\n     */\\n    function _safeGetUnderlyingPrice(VToken asset) internal view returns (uint256) {\\n        uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(address(asset));\\n        if (oraclePriceMantissa == 0) {\\n            revert PriceError(address(asset));\\n        }\\n        return oraclePriceMantissa;\\n    }\\n\\n    /**\\n     * @dev Return collateral factor for a market\\n     * @param asset Address for asset\\n     * @return Collateral factor as exponential\\n     */\\n    function _getCollateralFactor(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\\n    }\\n\\n    /**\\n     * @dev Retrieves liquidation threshold for a market as an exponential\\n     * @param asset Address for asset to liquidation threshold\\n     * @return Liquidation threshold as exponential\\n     */\\n    function _getLiquidationThreshold(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].liquidationThresholdMantissa });\\n    }\\n\\n    /**\\n     * @dev Returns supply and borrow balances of user in vToken, reverts on failure\\n     * @param vToken Market to query\\n     * @param user Account address\\n     * @return vTokenBalance Balance of vTokens, the same as vToken.balanceOf(user)\\n     * @return borrowBalance Borrowed amount, including the interest\\n     * @return exchangeRateMantissa Stored exchange rate\\n     */\\n    function _safeGetAccountSnapshot(VToken vToken, address user)\\n        internal\\n        view\\n        returns (\\n            uint256 vTokenBalance,\\n            uint256 borrowBalance,\\n            uint256 exchangeRateMantissa\\n        )\\n    {\\n        uint256 err;\\n        (err, vTokenBalance, borrowBalance, exchangeRateMantissa) = vToken.getAccountSnapshot(user);\\n        if (err != 0) {\\n            revert SnapshotError(address(vToken), user);\\n        }\\n        return (vTokenBalance, borrowBalance, exchangeRateMantissa);\\n    }\\n\\n    /// @notice Reverts if the call is not from expectedSender\\n    /// @param expectedSender Expected transaction sender\\n    function _checkSenderIs(address expectedSender) internal view {\\n        if (msg.sender != expectedSender) {\\n            revert UnexpectedSender(expectedSender, msg.sender);\\n        }\\n    }\\n\\n    /// @notice Reverts if a certain action is paused on a market\\n    /// @param market Market to check\\n    /// @param action Action to check\\n    function _checkActionPauseState(address market, Action action) private view {\\n        if (actionPaused(market, action)) {\\n            revert ActionPaused(market, action);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f4a5c92970213ecb680e41cdbf8f35fc3a05129e8a978c4a77874c3fd0f8aca\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract.\\n */\\ninterface ComptrollerInterface {\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\\n\\n    function exitMarket(address vToken) external returns (uint256);\\n\\n    /*** Policy Hooks ***/\\n\\n    function preMintHook(\\n        address vToken,\\n        address minter,\\n        uint256 mintAmount\\n    ) external;\\n\\n    function preRedeemHook(\\n        address vToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) external;\\n\\n    function preBorrowHook(\\n        address vToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external;\\n\\n    function preRepayHook(address vToken, address borrower) external;\\n\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external;\\n\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address vTokenBorrowed,\\n        address liquidator,\\n        address borrower\\n    ) external;\\n\\n    function preTransferHook(\\n        address vToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external;\\n\\n    function isComptroller() external view returns (bool);\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 repayAmount\\n    ) external view returns (uint256, uint256);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n}\\n\\n/**\\n * @title ComptrollerViewInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract, including only some util view functions.\\n */\\ninterface ComptrollerViewInterface {\\n    function markets(address) external view returns (bool, uint256);\\n\\n    function oracle() external view returns (ResilientOracleInterface);\\n\\n    function getAssetsIn(address) external view returns (VToken[] memory);\\n\\n    function closeFactorMantissa() external view returns (uint256);\\n\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\n\\n    function minLiquidatableCollateral() external view returns (uint256);\\n\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n\\n    function borrowCaps(address) external view returns (uint256);\\n\\n    function supplyCaps(address) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x0ac4cc1e962946a665033bc50251c33ce59998e492d9f4a76cf0231bf0b0f545\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerStorage\\n * @author Venus\\n * @notice Storage layout for the `Comptroller` contract.\\n */\\ncontract ComptrollerStorage {\\n    struct LiquidationOrder {\\n        VToken vTokenCollateral;\\n        VToken vTokenBorrowed;\\n        uint256 repayAmount;\\n    }\\n\\n    struct AccountLiquiditySnapshot {\\n        uint256 totalCollateral;\\n        uint256 weightedCollateral;\\n        uint256 borrows;\\n        uint256 effects;\\n        uint256 liquidity;\\n        uint256 shortfall;\\n    }\\n\\n    struct RewardSpeeds {\\n        address rewardToken;\\n        uint256 supplySpeed;\\n        uint256 borrowSpeed;\\n    }\\n\\n    struct Market {\\n        // Whether or not this market is listed\\n        bool isListed;\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint256 collateralFactorMantissa;\\n        //  Multiplier representing the collateralization after which the borrow is eligible\\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\\n        uint256 liquidationThresholdMantissa;\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n    }\\n\\n    enum Action {\\n        MINT,\\n        REDEEM,\\n        BORROW,\\n        REPAY,\\n        SEIZE,\\n        LIQUIDATE,\\n        TRANSFER,\\n        ENTER_MARKET,\\n        EXIT_MARKET\\n    }\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    ResilientOracleInterface public oracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint256 public closeFactorMantissa;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\"\\n     */\\n    mapping(address => VToken[]) public accountAssets;\\n\\n    /**\\n     * @notice Official mapping of vTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n    /// @notice A list of all markets\\n    VToken[] public allMarkets;\\n\\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which restricts borrowing.\\n    mapping(address => uint256) public borrowCaps;\\n\\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\\n    uint256 public minLiquidatableCollateral;\\n\\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting not allowed\\n    mapping(address => uint256) public supplyCaps;\\n\\n    /// @notice True if a certain action is paused on a certain market\\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\\n\\n    // List of Reward Distributors added\\n    RewardsDistributor[] internal rewardsDistributors;\\n\\n    // Used to check if rewards distributor is added\\n    mapping(address => bool) internal rewardsDistributorExists;\\n\\n    uint256 internal constant NO_ERROR = 0;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint256 internal constant MIN_CLOSE_FACTOR_MANTISSA = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint256 internal constant MAX_CLOSE_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    // No collateralFactorMantissa may exceed this value\\n    uint256 internal constant MAX_COLLATERAL_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x23a035905b74bfbc8840b76690490a67b8861b2025f109fb5ac9fac13be909d3\",\"license\":\"BSD-3-Clause\"},\"contracts/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title TokenErrorReporter\\n * @author Venus\\n * @notice Errors that can be thrown by the `VToken` contract.\\n */\\ncontract TokenErrorReporter {\\n    uint256 public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferNotAllowed();\\n\\n    error MintFreshnessCheck();\\n\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowFreshnessCheck();\\n\\n    error HealBorrowUnauthorized();\\n    error ForceLiquidateBorrowUnauthorized();\\n\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error ProtocolSeizeShareTooBig();\\n\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelFreshCheck();\\n}\\n\",\"keccak256\":\"0x3f8ec4e18bca1fdf8619966f4f6e095e205517a78f8c741b87fe82125754f96f\",\"license\":\"BSD-3-Clause\"},\"contracts/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { EXP_SCALE as EXP_SCALE_, MANTISSA_ONE as MANTISSA_ONE_ } from \\\"./lib/constants.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    struct Double {\\n        uint256 mantissa;\\n    }\\n\\n    uint256 internal constant EXP_SCALE = EXP_SCALE_;\\n    uint256 internal constant DOUBLE_SCALE = 1e36;\\n    uint256 internal constant HALF_EXP_SCALE = EXP_SCALE / 2;\\n    uint256 internal constant MANTISSA_ONE = MANTISSA_ONE_;\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * EXP_SCALE}) = 15\\n     */\\n    function truncate(Exp memory exp) internal pure returns (uint256) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / EXP_SCALE;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncateAddUInt(\\n        Exp memory a,\\n        uint256 scalar,\\n        uint256 addend\\n    ) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n        require(n <= type(uint224).max, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / EXP_SCALE });\\n    }\\n\\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / DOUBLE_SCALE });\\n    }\\n\\n    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / DOUBLE_SCALE;\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(mul_(a.mantissa, EXP_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a.mantissa, DOUBLE_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, DOUBLE_SCALE), b.mantissa);\\n    }\\n\\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a, DOUBLE_SCALE), b) });\\n    }\\n}\\n\",\"keccak256\":\"0xc13fcd089aa939e53b9c494c24beed316d572e9d433a44034eefa77915b673ec\",\"license\":\"BSD-3-Clause\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title Compound's InterestRateModel Interface\\n * @author Compound\\n */\\nabstract contract InterestRateModel {\\n    /**\\n     * @notice Calculates the current borrow interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getBorrowRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Calculates the current supply interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param reserveFactorMantissa The current reserve factor the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getSupplyRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 reserveFactorMantissa,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\\n     * @return Always true\\n     */\\n    function isInterestRateModel() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x60ea8b0b70165acc3cf0f1e92f8dcea93ef5ddc2b8b99172799594aeec7c22b5\",\"license\":\"BSD-3-Clause\"},\"contracts/MaxLoopsLimitHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title MaxLoopsLimitHelper\\n * @author Venus\\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\\n */\\nabstract contract MaxLoopsLimitHelper {\\n    // Limit for the loops to avoid the DOS\\n    uint256 public maxLoopsLimit;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when max loops limit is set\\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\\n\\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function _setMaxLoopsLimit(uint256 limit) internal {\\n        require(limit > maxLoopsLimit, \\\"Comptroller: Invalid maxLoopsLimit\\\");\\n\\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\\n        maxLoopsLimit = limit;\\n\\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\\n    }\\n\\n    /**\\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\\n     * @param len Length of the loops iterate\\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\\n     */\\n    function _ensureMaxLoops(uint256 len) internal view {\\n        if (len > maxLoopsLimit) {\\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98c97af128677629375ca93e8d8ca3f337a4abf9304a0a4ddaea9d96cc554c3b\",\"license\":\"BSD-3-Clause\"},\"contracts/Rewards/RewardsDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"../MaxLoopsLimitHelper.sol\\\";\\n\\n/**\\n * @title `RewardsDistributor`\\n * @author Venus\\n * @notice Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol.\\n * Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward\\n * token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool.\\n * Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward\\n * token to be released each block for borrowers and suppliers, which is distributed based on a user\\u2019s percentage of the borrows or supplies\\n * respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting\\n * their contributor reward token speed, which similarly allocates a fixed amount of reward token per block.\\n *\\n * The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed\\n * automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized\\n * entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.\\n */\\ncontract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, AccessControlledV8, MaxLoopsLimitHelper {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    struct RewardToken {\\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\\n        uint224 index;\\n        // The block number the index was last updated at\\n        uint32 block;\\n        // The block number at which to stop rewards\\n        uint32 lastRewardingBlock;\\n    }\\n\\n    /// @notice The initial REWARD TOKEN index for a market\\n    uint224 public constant INITIAL_INDEX = 1e36;\\n\\n    /// @notice The REWARD TOKEN market supply state for each market\\n    mapping(address => RewardToken) public rewardTokenSupplyState;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenSupplierIndex;\\n\\n    /// @notice The REWARD TOKEN accrued but not yet transferred to each user\\n    mapping(address => uint256) public rewardTokenAccrued;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding borrow market (per block)\\n    mapping(address => uint256) public rewardTokenBorrowSpeeds;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding supply market (per block)\\n    mapping(address => uint256) public rewardTokenSupplySpeeds;\\n\\n    /// @notice The REWARD TOKEN market borrow state for each market\\n    mapping(address => RewardToken) public rewardTokenBorrowState;\\n\\n    /// @notice The portion of REWARD TOKEN that each contributor receives per block\\n    mapping(address => uint256) public rewardTokenContributorSpeeds;\\n\\n    /// @notice Last block at which a contributor's REWARD TOKEN rewards have been allocated\\n    mapping(address => uint256) public lastContributorBlock;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenBorrowerIndex;\\n\\n    Comptroller private comptroller;\\n\\n    IERC20Upgradeable public rewardToken;\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a supplier\\n    event DistributedSupplierRewardToken(\\n        VToken indexed vToken,\\n        address indexed supplier,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenSupplyIndex\\n    );\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a borrower\\n    event DistributedBorrowerRewardToken(\\n        VToken indexed vToken,\\n        address indexed borrower,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenBorrowIndex\\n    );\\n\\n    /// @notice Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when REWARD TOKEN is granted by admin\\n    event RewardTokenGranted(address indexed recipient, uint256 amount);\\n\\n    /// @notice Emitted when a new REWARD TOKEN speed is set for a contributor\\n    event ContributorRewardTokenSpeedUpdated(address indexed contributor, uint256 newSpeed);\\n\\n    /// @notice Emitted when a market is initialized\\n    event MarketInitialized(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token supply index is updated\\n    event RewardTokenSupplyIndexUpdated(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token borrow index is updated\\n    event RewardTokenBorrowIndexUpdated(address indexed vToken, Exp marketBorrowIndex);\\n\\n    /// @notice Emitted when a reward for contributor is updated\\n    event ContributorRewardsUpdated(address indexed contributor, uint256 rewardAccrued);\\n\\n    /// @notice Emitted when a reward token last rewarding block for supply is updated\\n    event SupplyLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    /// @notice Emitted when a reward token last rewarding block for borrow is updated\\n    event BorrowLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    modifier onlyComptroller() {\\n        require(address(comptroller) == msg.sender, \\\"Only comptroller can call this function\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice RewardsDistributor initializer\\n     * @dev Initializes the deployer to owner\\n     * @param comptroller_ Comptroller to attach the reward distributor to\\n     * @param rewardToken_ Reward token to distribute\\n     * @param loopsLimit_ Maximum number of iterations for the loops in this contract\\n     * @param accessControlManager_ AccessControlManager contract address\\n     */\\n    function initialize(\\n        Comptroller comptroller_,\\n        IERC20Upgradeable rewardToken_,\\n        uint256 loopsLimit_,\\n        address accessControlManager_\\n    ) external initializer {\\n        comptroller = comptroller_;\\n        rewardToken = rewardToken_;\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n\\n        _setMaxLoopsLimit(loopsLimit_);\\n    }\\n\\n    function initializeMarket(address vToken) external onlyComptroller {\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n\\n        /*\\n         * Update market state indices\\n         */\\n        if (supplyState.index == 0) {\\n            // Initialize supply state index with default value\\n            supplyState.index = INITIAL_INDEX;\\n        }\\n\\n        if (borrowState.index == 0) {\\n            // Initialize borrow state index with default value\\n            borrowState.index = INITIAL_INDEX;\\n        }\\n\\n        /*\\n         * Update market state block numbers\\n         */\\n        supplyState.block = borrowState.block = blockNumber;\\n\\n        emit MarketInitialized(vToken);\\n    }\\n\\n    /*** Reward Token Distribution ***/\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them\\n     *         Borrowers will begin to accrue after the first interaction with the protocol.\\n     * @dev This function should only be called when the user has a borrow position in the market\\n     *      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)\\n     *      We avoid an external call to check if they are in the market to save gas because this function is called in many places\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function distributeBorrowerRewardToken(\\n        address vToken,\\n        address borrower,\\n        Exp memory marketBorrowIndex\\n    ) external onlyComptroller {\\n        _distributeBorrowerRewardToken(vToken, borrower, marketBorrowIndex);\\n    }\\n\\n    function updateRewardTokenSupplyIndex(address vToken) external onlyComptroller {\\n        _updateRewardTokenSupplyIndex(vToken);\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the recipient\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all\\n     * @param recipient The address of the recipient to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     */\\n    function grantRewardToken(address recipient, uint256 amount) external onlyOwner {\\n        uint256 amountLeft = _grantRewardToken(recipient, amount);\\n        require(amountLeft == 0, \\\"insufficient rewardToken for grant\\\");\\n        emit RewardTokenGranted(recipient, amount);\\n    }\\n\\n    function updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) external onlyComptroller {\\n        _updateRewardTokenBorrowIndex(vToken, marketBorrowIndex);\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN borrow and supply speeds for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN speed to update\\n     * @param supplySpeeds New supply-side REWARD TOKEN speed for the corresponding market\\n     * @param borrowSpeeds New borrow-side REWARD TOKEN speed for the corresponding market\\n     */\\n    function setRewardTokenSpeeds(\\n        VToken[] memory vTokens,\\n        uint256[] memory supplySpeeds,\\n        uint256[] memory borrowSpeeds\\n    ) external {\\n        _checkAccessAllowed(\\\"setRewardTokenSpeeds(address[],uint256[],uint256[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \\\"invalid setRewardTokenSpeeds\\\");\\n\\n        for (uint256 i; i < numTokens; ++i) {\\n            _setRewardTokenSpeed(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN last rewarding block to update\\n     * @param supplyLastRewardingBlocks New supply-side REWARD TOKEN last rewarding block for the corresponding market\\n     * @param borrowLastRewardingBlocks New borrow-side REWARD TOKEN last rewarding block for the corresponding market\\n     */\\n    function setLastRewardingBlocks(\\n        VToken[] calldata vTokens,\\n        uint32[] calldata supplyLastRewardingBlocks,\\n        uint32[] calldata borrowLastRewardingBlocks\\n    ) external {\\n        _checkAccessAllowed(\\\"setLastRewardingBlock(address[],uint32[],uint32[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(\\n            numTokens == supplyLastRewardingBlocks.length && numTokens == borrowLastRewardingBlocks.length,\\n            \\\"RewardsDistributor::setLastRewardingBlocks invalid input\\\"\\n        );\\n\\n        for (uint256 i; i < numTokens; ) {\\n            _setLastRewardingBlock(vTokens[i], supplyLastRewardingBlocks[i], borrowLastRewardingBlocks[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single contributor\\n     * @param contributor The contributor whose REWARD TOKEN speed to update\\n     * @param rewardTokenSpeed New REWARD TOKEN speed for contributor\\n     */\\n    function setContributorRewardTokenSpeed(address contributor, uint256 rewardTokenSpeed) external onlyOwner {\\n        // note that REWARD TOKEN speed could be set to 0 to halt liquidity rewards for a contributor\\n        updateContributorRewards(contributor);\\n        if (rewardTokenSpeed == 0) {\\n            // release storage\\n            delete lastContributorBlock[contributor];\\n        } else {\\n            lastContributorBlock[contributor] = getBlockNumber();\\n        }\\n        rewardTokenContributorSpeeds[contributor] = rewardTokenSpeed;\\n\\n        emit ContributorRewardTokenSpeedUpdated(contributor, rewardTokenSpeed);\\n    }\\n\\n    function distributeSupplierRewardToken(address vToken, address supplier) external onlyComptroller {\\n        _distributeSupplierRewardToken(vToken, supplier);\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in all markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     */\\n    function claimRewardToken(address holder) external {\\n        return claimRewardToken(holder, comptroller.getAllMarkets());\\n    }\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Calculate additional accrued REWARD TOKEN for a contributor since last accrual\\n     * @param contributor The address to calculate contributor rewards for\\n     */\\n    function updateContributorRewards(address contributor) public {\\n        uint256 rewardTokenSpeed = rewardTokenContributorSpeeds[contributor];\\n        uint256 blockNumber = getBlockNumber();\\n        uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\n        if (deltaBlocks > 0 && rewardTokenSpeed > 0) {\\n            uint256 newAccrued = mul_(deltaBlocks, rewardTokenSpeed);\\n            uint256 contributorAccrued = add_(rewardTokenAccrued[contributor], newAccrued);\\n\\n            rewardTokenAccrued[contributor] = contributorAccrued;\\n            lastContributorBlock[contributor] = blockNumber;\\n\\n            emit ContributorRewardsUpdated(contributor, rewardTokenAccrued[contributor]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in the specified markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     * @param vTokens The list of markets to claim REWARD TOKEN in\\n     */\\n    function claimRewardToken(address holder, VToken[] memory vTokens) public {\\n        uint256 vTokensCount = vTokens.length;\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            VToken vToken = vTokens[i];\\n            require(comptroller.isMarketListed(vToken), \\\"market must be listed\\\");\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n            _distributeBorrowerRewardToken(address(vToken), holder, borrowIndex);\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n            _distributeSupplierRewardToken(address(vToken), holder);\\n        }\\n        rewardTokenAccrued[holder] = _grantRewardToken(holder, rewardTokenAccrued[holder]);\\n    }\\n\\n    function getBlockNumber() public view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for a single market.\\n     * @param vToken market's whose reward token last rewarding block to be updated\\n     * @param supplyLastRewardingBlock New supply-side REWARD TOKEN last rewarding block for market\\n     * @param borrowLastRewardingBlock New borrow-side REWARD TOKEN last rewarding block for market\\n     */\\n    function _setLastRewardingBlock(\\n        VToken vToken,\\n        uint32 supplyLastRewardingBlock,\\n        uint32 borrowLastRewardingBlock\\n    ) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        uint256 blockNumber = getBlockNumber();\\n\\n        require(supplyLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n        require(borrowLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n\\n        uint32 currentSupplyLastRewardingBlock = rewardTokenSupplyState[address(vToken)].lastRewardingBlock;\\n        uint32 currentBorrowLastRewardingBlock = rewardTokenBorrowState[address(vToken)].lastRewardingBlock;\\n\\n        require(\\n            currentSupplyLastRewardingBlock == 0 || currentSupplyLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n        require(\\n            currentBorrowLastRewardingBlock == 0 || currentBorrowLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n\\n        if (currentSupplyLastRewardingBlock != supplyLastRewardingBlock) {\\n            rewardTokenSupplyState[address(vToken)].lastRewardingBlock = supplyLastRewardingBlock;\\n            emit SupplyLastRewardingBlockUpdated(address(vToken), supplyLastRewardingBlock);\\n        }\\n\\n        if (currentBorrowLastRewardingBlock != borrowLastRewardingBlock) {\\n            rewardTokenBorrowState[address(vToken)].lastRewardingBlock = borrowLastRewardingBlock;\\n            emit BorrowLastRewardingBlockUpdated(address(vToken), borrowLastRewardingBlock);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single market.\\n     * @param vToken market's whose reward token rate to be updated\\n     * @param supplySpeed New supply-side REWARD TOKEN speed for market\\n     * @param borrowSpeed New borrow-side REWARD TOKEN speed for market\\n     */\\n    function _setRewardTokenSpeed(\\n        VToken vToken,\\n        uint256 supplySpeed,\\n        uint256 borrowSpeed\\n    ) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        if (rewardTokenSupplySpeeds[address(vToken)] != supplySpeed) {\\n            // Supply speed updated so let's update supply state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n\\n            // Update speed and emit event\\n            rewardTokenSupplySpeeds[address(vToken)] = supplySpeed;\\n            emit RewardTokenSupplySpeedUpdated(vToken, supplySpeed);\\n        }\\n\\n        if (rewardTokenBorrowSpeeds[address(vToken)] != borrowSpeed) {\\n            // Borrow speed updated so let's update borrow state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n\\n            // Update speed and emit event\\n            rewardTokenBorrowSpeeds[address(vToken)] = borrowSpeed;\\n            emit RewardTokenBorrowSpeedUpdated(vToken, borrowSpeed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate REWARD TOKEN accrued by a supplier and possibly transfer it to them.\\n     * @param vToken The market in which the supplier is interacting\\n     * @param supplier The address of the supplier to distribute REWARD TOKEN to\\n     */\\n    function _distributeSupplierRewardToken(address vToken, address supplier) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplyIndex = supplyState.index;\\n        uint256 supplierIndex = rewardTokenSupplierIndex[vToken][supplier];\\n\\n        // Update supplier's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenSupplierIndex[vToken][supplier] = supplyIndex;\\n\\n        if (supplierIndex == 0 && supplyIndex >= INITIAL_INDEX) {\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\\n            // set for the market.\\n            supplierIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per vToken accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\\n\\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerVToken\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\n\\n        uint256 supplierAccrued = add_(rewardTokenAccrued[supplier], supplierDelta);\\n        rewardTokenAccrued[supplier] = supplierAccrued;\\n\\n        emit DistributedSupplierRewardToken(VToken(vToken), supplier, supplierDelta, supplierAccrued, supplyIndex);\\n    }\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them.\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function _distributeBorrowerRewardToken(\\n        address vToken,\\n        address borrower,\\n        Exp memory marketBorrowIndex\\n    ) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowIndex = borrowState.index;\\n        uint256 borrowerIndex = rewardTokenBorrowerIndex[vToken][borrower];\\n\\n        // Update borrowers's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenBorrowerIndex[vToken][borrower] = borrowIndex;\\n\\n        if (borrowerIndex == 0 && borrowIndex >= INITIAL_INDEX) {\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\\n            // set for the market.\\n            borrowerIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per borrowed unit accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\\n\\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerBorrowedUnit\\n        if (borrowerAmount != 0) {\\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n\\n            uint256 borrowerAccrued = add_(rewardTokenAccrued[borrower], borrowerDelta);\\n            rewardTokenAccrued[borrower] = borrowerAccrued;\\n\\n            emit DistributedBorrowerRewardToken(VToken(vToken), borrower, borrowerDelta, borrowerAccrued, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the user.\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\\n     * @param user The address of the user to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     * @return The amount of REWARD TOKEN which was NOT transferred to the user\\n     */\\n    function _grantRewardToken(address user, uint256 amount) internal returns (uint256) {\\n        uint256 rewardTokenRemaining = rewardToken.balanceOf(address(this));\\n        if (amount > 0 && amount <= rewardTokenRemaining) {\\n            rewardToken.safeTransfer(user, amount);\\n            return 0;\\n        }\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the supply index\\n     * @param vToken The market whose supply index to update\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenSupplyIndex(address vToken) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplySpeed = rewardTokenSupplySpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (supplyState.lastRewardingBlock > 0 && blockNumber > supplyState.lastRewardingBlock) {\\n            blockNumber = supplyState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(supplyState.block));\\n\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\n            uint256 supplyTokens = VToken(vToken).totalSupply();\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, supplySpeed);\\n            Double memory ratio = supplyTokens > 0\\n                ? fraction(accruedSinceUpdate, supplyTokens)\\n                : Double({ mantissa: 0 });\\n            supplyState.index = safe224(\\n                add_(Double({ mantissa: supplyState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            supplyState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            supplyState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenSupplyIndexUpdated(vToken);\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the borrow index\\n     * @param vToken The market whose borrow index to update\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowSpeed = rewardTokenBorrowSpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (borrowState.lastRewardingBlock > 0 && blockNumber > borrowState.lastRewardingBlock) {\\n            blockNumber = borrowState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(borrowState.block));\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, borrowSpeed);\\n            Double memory ratio = borrowAmount > 0\\n                ? fraction(accruedSinceUpdate, borrowAmount)\\n                : Double({ mantissa: 0 });\\n            borrowState.index = safe224(\\n                add_(Double({ mantissa: borrowState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            borrowState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            borrowState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenBorrowIndexUpdated(vToken, marketBorrowIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x0e5bede4edc4346e689de0adcf98dc9642feb55d44c1916715741c5937a34d52\",\"license\":\"BSD-3-Clause\"},\"contracts/RiskFund/IProtocolShareReserve.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title IProtocolShareReserve\\n * @author Venus\\n * @notice Interface implemented by `ProtocolShareReserve`.\\n */\\ninterface IProtocolShareReserve {\\n    function updateAssetsState(address comptroller, address asset) external;\\n}\\n\",\"keccak256\":\"0x45bf43fe09973ebfe0b5d3e81f966d7521b88c118d6ff64c289c500a62a7d564\",\"license\":\"BSD-3-Clause\"},\"contracts/VToken.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { VTokenInterface } from \\\"./VTokenInterfaces.sol\\\";\\nimport { ComptrollerInterface, ComptrollerViewInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { TokenErrorReporter } from \\\"./ErrorReporter.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { IProtocolShareReserve } from \\\"./RiskFund/IProtocolShareReserve.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title VToken\\n * @author Venus\\n * @notice Each asset that is supported by a pool is integrated through an instance of the `VToken` contract. As outlined in the protocol overview,\\n * each isolated pool creates its own `vToken` corresponding to an asset. Within a given pool, each included `vToken` is referred to as a market of\\n * the pool. The main actions a user regularly interacts with in a market are:\\n\\n- mint/redeem of vTokens;\\n- transfer of vTokens;\\n- borrow/repay a loan on an underlying asset;\\n- liquidate a borrow or liquidate/heal an account.\\n\\n * A user supplies the underlying asset to a pool by minting `vTokens`, where the corresponding `vToken` amount is determined by the `exchangeRate`.\\n * The `exchangeRate` will change over time, dependent on a number of factors, some of which accrue interest. Additionally, once users have minted\\n * `vToken` in a pool, they can borrow any asset in the isolated pool by using their `vToken` as collateral. In order to borrow an asset or use a `vToken`\\n * as collateral, the user must be entered into each corresponding market (else, the `vToken` will not be considered collateral for a borrow). Note that\\n * a user may borrow up to a portion of their collateral determined by the market\\u2019s collateral factor. However, if their borrowed amount exceeds an amount\\n * calculated using the market\\u2019s corresponding liquidation threshold, the borrow is eligible for liquidation. When a user repays a borrow, they must also\\n * pay off interest accrued on the borrow.\\n * \\n * The Venus protocol includes unique mechanisms for healing an account and liquidating an account. These actions are performed in the `Comptroller`\\n * and consider all borrows and collateral for which a given account is entered within a market. These functions may only be called on an account with a\\n * total collateral amount that is no larger than a universal `minLiquidatableCollateral` value, which is used for all markets within a `Comptroller`.\\n * Both functions settle all of an account\\u2019s borrows, but `healAccount()` may add `badDebt` to a vToken. For more detail, see the description of\\n * `healAccount()` and `liquidateAccount()` in the `Comptroller` summary section below.\\n */\\ncontract VToken is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    VTokenInterface,\\n    ExponentialNoError,\\n    TokenErrorReporter\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 internal constant DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA = 5e16; // 5%\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\n        // to set the state variables.\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     * @custom:error ZeroAddressNotAllowed is thrown when admin address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     */\\n    function initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) external initializer {\\n        ensureNonzeroAddress(admin_);\\n\\n        // Initialize the market\\n        _initialize(\\n            underlying_,\\n            comptroller_,\\n            interestRateModel_,\\n            initialExchangeRateMantissa_,\\n            name_,\\n            symbol_,\\n            decimals_,\\n            admin_,\\n            accessControlManager_,\\n            riskManagement,\\n            reserveFactorMantissa_\\n        );\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param addedValue The number of additional tokens spender can transfer\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 newAllowance = transferAllowances[src][spender];\\n        newAllowance += addedValue;\\n        transferAllowances[src][spender] = newAllowance;\\n\\n        emit Approval(src, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decreases approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param subtractedValue The number of tokens to remove from total approval\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 currentAllowance = transferAllowances[src][spender];\\n        require(currentAllowance >= subtractedValue, \\\"decreased allowance below zero\\\");\\n        unchecked {\\n            currentAllowance -= subtractedValue;\\n        }\\n\\n        transferAllowances[src][spender] = currentAllowance;\\n\\n        emit Approval(src, spender, currentAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return amount The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return totalBorrows The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, msg.sender, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param minter User whom the supply will be attributed to\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when minter address is zero\\n     */\\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        ensureNonzeroAddress(minter);\\n\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, minter, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of vTokens to redeem into underlying\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, redeemTokens, 0);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     */\\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, 0, redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender borrows assets from the protocol to their own address\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Borrow event; may emit AccrueInterest\\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _borrowFresh(msg.sender, borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Not restricted\\n     */\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external override returns (uint256) {\\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice sets protocol share accumulated from liquidations\\n     * @dev must be equal or less than liquidation incentive - 1\\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\\n     * @custom:event Emits NewProtocolSeizeShare event on success\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\\n        _checkAccessAllowed(\\\"setProtocolSeizeShare(uint256)\\\");\\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\\n        if (newProtocolSeizeShareMantissa_ + MANTISSA_ONE > liquidationIncentive) {\\n            revert ProtocolSeizeShareTooBig();\\n        }\\n\\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\\n    }\\n\\n    /**\\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n     * @dev Admin function to accrue interest and set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\\n        _checkAccessAllowed(\\\"setReserveFactor(uint256)\\\");\\n\\n        accrueInterest();\\n        _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\\n     * @custom:access Not restricted\\n     */\\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\\n        accrueInterest();\\n        _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount of underlying token to add as reserves\\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function addReserves(uint256 addAmount) external override nonReentrant {\\n        accrueInterest();\\n        _addReservesFresh(addAmount);\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external override {\\n        _checkAccessAllowed(\\\"setInterestRateModel(address)\\\");\\n\\n        accrueInterest();\\n        _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\\n     *   \\\"forgiving\\\" the borrower. Healing is a situation that should rarely happen. However, some pools\\n     *   may list risky assets or be configured improperly \\u2013 we want to still handle such cases gracefully.\\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\\n     * @dev This function does not call any Comptroller hooks (like \\\"healAllowed\\\"), because we assume\\n     *   the Comptroller does all the necessary checks before calling this function.\\n     * @param payer account who repays the debt\\n     * @param borrower account to heal\\n     * @param repayAmount amount to repay\\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:access Only Comptroller\\n     */\\n    function healBorrow(\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external override nonReentrant {\\n        if (repayAmount != 0) {\\n            comptroller.preRepayHook(address(this), borrower);\\n        }\\n\\n        if (msg.sender != address(comptroller)) {\\n            revert HealBorrowUnauthorized();\\n        }\\n\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 totalBorrowsNew = totalBorrows;\\n\\n        uint256 actualRepayAmount;\\n        if (repayAmount != 0) {\\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\\n            emit RepayBorrow(\\n                payer,\\n                borrower,\\n                actualRepayAmount,\\n                accountBorrowsPrev - actualRepayAmount,\\n                totalBorrowsNew\\n            );\\n        }\\n\\n        // The transaction will fail if trying to repay too much\\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\\n        if (badDebtDelta != 0) {\\n            uint256 badDebtOld = badDebt;\\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\\n            badDebt = badDebtNew;\\n\\n            // We treat healing as \\\"repayment\\\", where vToken is the payer\\n            emit RepayBorrow(address(this), borrower, badDebtDelta, 0, totalBorrowsNew);\\n            emit BadDebtIncreased(borrower, badDebtDelta, badDebtOld, badDebtNew);\\n        }\\n\\n        accountBorrows[borrower].principal = 0;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        emit HealBorrow(payer, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\\n     *  the close factor check. The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Only Comptroller\\n     */\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        if (msg.sender != address(comptroller)) {\\n            revert ForceLiquidateBorrowUnauthorized();\\n        }\\n        _liquidateBorrow(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another vToken during the process of liquidation.\\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     * @custom:event Emits Transfer, ReservesAdded events\\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:access Not restricted\\n     */\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external override nonReentrant {\\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Updates bad debt\\n     * @dev Called only when bad debt is recovered from auction\\n     * @param recoveredAmount_ The amount of bad debt recovered\\n     * @custom:event Emits BadDebtRecovered event\\n     * @custom:access Only Shortfall contract\\n     */\\n    function badDebtRecovered(uint256 recoveredAmount_) external {\\n        require(msg.sender == shortfall, \\\"only shortfall contract can update bad debt\\\");\\n        require(recoveredAmount_ <= badDebt, \\\"more than bad debt recovered from auction\\\");\\n\\n        uint256 badDebtOld = badDebt;\\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\\n        badDebt = badDebtNew;\\n\\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\\n    }\\n\\n    /**\\n     * @notice Sets protocol share reserve contract address\\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\\n        _setProtocolShareReserve(protocolShareReserve_);\\n    }\\n\\n    /**\\n     * @notice Sets shortfall contract address\\n     * @param shortfall_ The address of the shortfall contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setShortfallContract(address shortfall_) external onlyOwner {\\n        _setShortfallContract(shortfall_);\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     * @custom:access Only Governance\\n     */\\n    function sweepToken(IERC20Upgradeable token) external override {\\n        require(msg.sender == owner(), \\\"VToken::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"VToken::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.safeTransfer(owner(), balance);\\n\\n        emit SweepToken(address(token));\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return amount The number of tokens allowed to be spent (type(uint256).max means infinite)\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return amount The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return vTokenBalance User's balance of vTokens\\n     * @return borrowBalance Amount owed in terms of underlying\\n     * @return exchangeRate Stored exchange rate\\n     */\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 error,\\n            uint256 vTokenBalance,\\n            uint256 borrowBalance,\\n            uint256 exchangeRate\\n        )\\n    {\\n        return (NO_ERROR, accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this vToken in the underlying asset\\n     * @return cash The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() external view override returns (uint256) {\\n        return _getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this vToken\\n     * @return rate The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external view override returns (uint256) {\\n        return interestRateModel.getBorrowRate(_getCashPrior(), totalBorrows, totalReserves, badDebt);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this v\\n     * @return rate The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external view override returns (uint256) {\\n        return\\n            interestRateModel.getSupplyRate(\\n                _getCashPrior(),\\n                totalBorrows,\\n                totalReserves,\\n                reserveFactorMantissa,\\n                badDebt\\n            );\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceStored(address account) external view override returns (uint256) {\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() external view override returns (uint256) {\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     * @return Always NO_ERROR\\n     * @custom:event Emits AccrueInterest event on success\\n     * @custom:access Not restricted\\n     */\\n    function accrueInterest() public virtual override returns (uint256) {\\n        /* Remember the initial block number */\\n        uint256 currentBlockNumber = _getBlockNumber();\\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint256 cashPrior = _getCashPrior();\\n        uint256 borrowsPrior = totalBorrows;\\n        uint256 reservesPrior = totalReserves;\\n        uint256 borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior, badDebt);\\n        require(borrowRateMantissa <= MAX_BORROW_RATE_MANTISSA, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\\n            Exp({ mantissa: reserveFactorMantissa }),\\n            interestAccumulated,\\n            reservesPrior\\n        );\\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives vTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param payer The address of the account which is sending the assets for supply\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function _mintFresh(\\n        address payer,\\n        address minter,\\n        uint256 mintAmount\\n    ) internal {\\n        /* Fail if mint not allowed */\\n        comptroller.preMintHook(address(this), minter, mintAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `_doTransferIn` for the minter and the mintAmount.\\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint256 actualMintAmount = _doTransferIn(payer, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        uint256 balanceAfter = accountTokens[minter] + mintTokens;\\n        accountTokens[minter] = balanceAfter;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens, balanceAfter);\\n        emit Transfer(address(0), minter, mintTokens);\\n    }\\n\\n    /**\\n     * @notice User redeems vTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function _redeemFresh(\\n        address redeemer,\\n        uint256 redeemTokensIn,\\n        uint256 redeemAmountIn\\n    ) internal {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             */\\n            redeemTokens = redeemTokensIn;\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n\\n            uint256 _redeemAmount = mul_(redeemTokens, exchangeRate);\\n            if (_redeemAmount != 0 && _redeemAmount != redeemAmountIn) redeemTokens++; // round up\\n        }\\n\\n        // redeemAmount = exchangeRate * redeemTokens\\n        redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokens);\\n\\n        // Revert if amount is zero\\n        if (redeemAmount == 0) {\\n            revert(\\\"redeemAmount is zero\\\");\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        comptroller.preRedeemHook(address(this), redeemer, redeemTokens);\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (_getCashPrior() - totalReserves < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        uint256 balanceAfter = accountTokens[redeemer] - redeemTokens;\\n        accountTokens[redeemer] = balanceAfter;\\n\\n        /*\\n         * We invoke _doTransferOut for the redeemer and the redeemAmount.\\n         *  On success, the vToken has redeemAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(redeemer, redeemAmount);\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens, balanceAfter);\\n    }\\n\\n    /**\\n     * @notice Users borrow assets from the protocol to their own address\\n     * @param borrower User who borrows the assets\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     */\\n    function _borrowFresh(address borrower, uint256 borrowAmount) internal {\\n        /* Fail if borrow not allowed */\\n        comptroller.preBorrowHook(address(this), borrower, borrowAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (_getCashPrior() - totalReserves < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke _doTransferOut for the borrower and the borrowAmount.\\n         *  On success, the vToken borrowAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or type(uint256).max for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function _repayBorrowFresh(\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) internal returns (uint256) {\\n        /* Fail if repayBorrow not allowed */\\n        comptroller.preRepayHook(address(this), borrower);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n\\n        uint256 repayAmountFinal = repayAmount >= accountBorrowsPrev ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call _doTransferIn for the payer and the repayAmount\\n         *  On success, the vToken holds an additional repayAmount of cash.\\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint256 actualRepayAmount = _doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint256 error = vTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // _liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrowFresh(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal {\\n        /* Fail if liquidate not allowed */\\n        comptroller.preLiquidateHook(\\n            address(this),\\n            address(vTokenCollateral),\\n            borrower,\\n            repayAmount,\\n            skipLiquidityCheck\\n        );\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify vTokenCollateral market's block number equals current block number */\\n        if (vTokenCollateral.accrualBlockNumber() != _getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = type(uint256).max */\\n        if (repayAmount == type(uint256).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint256 actualRepayAmount = _repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\\n            address(this),\\n            address(vTokenCollateral),\\n            actualRepayAmount\\n        );\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, call _seize internally to avoid re-entrancy, otherwise make an external call\\n        if (address(vTokenCollateral) == address(this)) {\\n            _seize(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            vTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another VToken.\\n     *  It's absolutely critical to use msg.sender as the seizer vToken and not a parameter.\\n     * @param seizerContract The contract seizing the collateral (either borrowed vToken or Comptroller)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     */\\n    function _seize(\\n        address seizerContract,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) internal {\\n        /* Fail if seize not allowed */\\n        comptroller.preSeizeHook(address(this), seizerContract, liquidator, borrower);\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint256 liquidationIncentiveMantissa = ComptrollerViewInterface(address(comptroller))\\n        .liquidationIncentiveMantissa();\\n        uint256 numerator = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\\n        uint256 protocolSeizeTokens = div_(numerator, Exp({ mantissa: liquidationIncentiveMantissa }));\\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n        uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalReserves = totalReservesNew;\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n    }\\n\\n    function _setComptroller(ComptrollerInterface newComptroller) internal {\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n    }\\n\\n    /**\\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n     * @dev Admin function to set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     */\\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal {\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \\u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > MAX_RESERVE_FACTOR_MANTISSA) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return actualAddAmount The actual amount added, excluding the potential token fees\\n     */\\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256) {\\n        // totalReserves + actualAddAmount\\n        uint256 totalReservesNew;\\n        uint256 actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\\n        totalReservesNew = totalReserves + actualAddAmount;\\n        totalReserves = totalReservesNew;\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        return actualAddAmount;\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to the protocol reserve contract\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     */\\n    function _reduceReservesFresh(uint256 reduceAmount) internal {\\n        // totalReserves - reduceAmount\\n        uint256 totalReservesNew;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (_getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \\u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\n        _doTransferOut(protocolShareReserve, reduceAmount);\\n\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(address(comptroller), underlying);\\n\\n        emit ReservesReduced(protocolShareReserve, reduceAmount, totalReservesNew);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal {\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     * @param from Sender of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     * @return Actual amount received\\n     */\\n    function _doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n        token.safeTransferFrom(from, address(this), amount);\\n        uint256 balanceAfter = token.balanceOf(address(this));\\n        // Return the amount that was *actually* transferred\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    /**\\n     * @dev Just a regular ERC-20 transfer, reverts on failure\\n     * @param to Receiver of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     */\\n    function _doTransferOut(address to, uint256 amount) internal virtual {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        token.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     */\\n    function _transferTokens(\\n        address spender,\\n        address src,\\n        address dst,\\n        uint256 tokens\\n    ) internal {\\n        /* Fail if transfer not allowed */\\n        comptroller.preTransferHook(address(this), src, dst, tokens);\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint256 startingAllowance;\\n        if (spender == src) {\\n            startingAllowance = type(uint256).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint256 allowanceNew = startingAllowance - tokens;\\n        uint256 srcTokensNew = accountTokens[src] - tokens;\\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint256).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n    }\\n\\n    /**\\n     * @notice Initialize the money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     */\\n    function _initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        _setComptroller(comptroller_);\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = _getBlockNumber();\\n        borrowIndex = MANTISSA_ONE;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        _setInterestRateModelFresh(interestRateModel_);\\n\\n        _setReserveFactorFresh(reserveFactorMantissa_);\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        _setShortfallContract(riskManagement.shortfall);\\n        _setProtocolShareReserve(riskManagement.protocolShareReserve);\\n        protocolSeizeShareMantissa = DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA;\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        IERC20Upgradeable(underlying).totalSupply();\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n        _transferOwnership(admin_);\\n    }\\n\\n    function _setShortfallContract(address shortfall_) internal {\\n        ensureNonzeroAddress(shortfall_);\\n        address oldShortfall = shortfall;\\n        shortfall = shortfall_;\\n        emit NewShortfallContract(oldShortfall, shortfall_);\\n    }\\n\\n    function _setProtocolShareReserve(address payable protocolShareReserve_) internal {\\n        ensureNonzeroAddress(protocolShareReserve_);\\n        address oldProtocolShareReserve = address(protocolShareReserve);\\n        protocolShareReserve = protocolShareReserve_;\\n        emit NewProtocolShareReserve(oldProtocolShareReserve, address(protocolShareReserve_));\\n    }\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function _getCashPrior() internal view virtual returns (uint256) {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     * @return Current block number\\n     */\\n    function _getBlockNumber() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance the calculated balance\\n     */\\n    function _borrowBalanceStored(address account) internal view returns (uint256) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function _exchangeRateStored() internal view virtual returns (uint256) {\\n        uint256 _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        }\\n        /*\\n         * Otherwise:\\n         *  exchangeRate = (totalCash + totalBorrows + badDebt - totalReserves) / totalSupply\\n         */\\n        uint256 totalCash = _getCashPrior();\\n        uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows + badDebt - totalReserves;\\n        uint256 exchangeRate = (cashPlusBorrowsMinusReserves * EXP_SCALE) / _totalSupply;\\n\\n        return exchangeRate;\\n    }\\n}\\n\",\"keccak256\":\"0x90ec54cadfdd13bc09a1bc4ae1cc37585b695804a6c95d8b42fb866ec269a300\",\"license\":\"BSD-3-Clause\"},\"contracts/VTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\n\\n/**\\n * @title VTokenStorage\\n * @author Venus\\n * @notice Storage layout used by the `VToken` contract\\n */\\n// solhint-disable-next-line max-states-count\\ncontract VTokenStorage {\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint256 principal;\\n        uint256 interestIndex;\\n    }\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice Underlying asset for this VToken\\n     */\\n    address public underlying;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Protocol share Reserve contract address\\n     */\\n    address payable public protocolShareReserve;\\n\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint256 internal constant MAX_BORROW_RATE_MANTISSA = 0.0005e16;\\n\\n    // Maximum fraction of interest that can be set aside for reserves\\n    uint256 internal constant MAX_RESERVE_FACTOR_MANTISSA = 1e18;\\n\\n    /**\\n     * @notice Contract which oversees inter-vToken operations\\n     */\\n    ComptrollerInterface public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    // Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\\n    uint256 internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint256 public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint256 public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint256 public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint256 public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint256 public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint256 public totalSupply;\\n\\n    /**\\n     * @notice Total bad debt of the market\\n     */\\n    uint256 public badDebt;\\n\\n    // Official record of token balances for each account\\n    mapping(address => uint256) internal accountTokens;\\n\\n    // Approved token transfer amounts on behalf of others\\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint256 public protocolSeizeShareMantissa;\\n\\n    /**\\n     * @notice Storage of Shortfall contract address\\n     */\\n    address public shortfall;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\\n/**\\n * @title VTokenInterface\\n * @author Venus\\n * @notice Interface implemented by the `VToken` contract\\n */\\nabstract contract VTokenInterface is VTokenStorage {\\n    struct RiskManagementInit {\\n        address shortfall;\\n        address payable protocolShareReserve;\\n    }\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address indexed minter, uint256 mintAmount, uint256 mintTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address indexed borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(\\n        address indexed payer,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when bad debt is accumulated on a market\\n     * @param borrower borrower to \\\"forgive\\\"\\n     * @param badDebtDelta amount of new bad debt recorded\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtIncreased(address indexed borrower, uint256 badDebtDelta, uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when bad debt is recovered via an auction\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtRecovered(uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        address indexed vTokenCollateral,\\n        uint256 seizeTokens\\n    );\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(ComptrollerInterface indexed oldComptroller, ComptrollerInterface indexed newComptroller);\\n\\n    /**\\n     * @notice Event emitted when shortfall contract address is changed\\n     */\\n    event NewShortfallContract(address indexed oldShortfall, address indexed newShortfall);\\n\\n    /**\\n     * @notice Event emitted when protocol share reserve contract address is changed\\n     */\\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(\\n        InterestRateModel indexed oldInterestRateModel,\\n        InterestRateModel indexed newInterestRateModel\\n    );\\n\\n    /**\\n     * @notice Event emitted when protocol seize share is changed\\n     */\\n    event NewProtocolSeizeShare(uint256 oldProtocolSeizeShareMantissa, uint256 newProtocolSeizeShareMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address indexed benefactor, uint256 addAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address indexed admin, uint256 reduceAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Event emitted when healing the borrow\\n     */\\n    event HealBorrow(address indexed payer, address indexed borrower, uint256 repayAmount);\\n\\n    /**\\n     * @notice Event emitted when tokens are swept\\n     */\\n    event SweepToken(address indexed token);\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint256 mintAmount) external virtual returns (uint256);\\n\\n    function mintBehalf(address minter, uint256 mintAllowed) external virtual returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external virtual returns (uint256);\\n\\n    function healBorrow(\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external virtual;\\n\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipCloseFactorCheck\\n    ) external virtual;\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external virtual;\\n\\n    function transfer(address dst, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external virtual returns (bool);\\n\\n    function accrueInterest() external virtual returns (uint256);\\n\\n    function sweepToken(IERC20Upgradeable token) external virtual;\\n\\n    /*** Admin Functions ***/\\n\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external virtual;\\n\\n    function reduceReserves(uint256 reduceAmount) external virtual;\\n\\n    function exchangeRateCurrent() external virtual returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\\n\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external virtual;\\n\\n    function addReserves(uint256 addAmount) external virtual;\\n\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool);\\n\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) external view virtual returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function borrowRatePerBlock() external view virtual returns (uint256);\\n\\n    function supplyRatePerBlock() external view virtual returns (uint256);\\n\\n    function borrowBalanceStored(address account) external view virtual returns (uint256);\\n\\n    function exchangeRateStored() external view virtual returns (uint256);\\n\\n    function getCash() external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is a VToken contract (for inspection)\\n     * @return Always true\\n     */\\n    function isVToken() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xe82d0de552cfda8da11191a3b0bd24d5e218f182d1fdb776585b97cf27c5f4de\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/constants.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @dev The approximate number of blocks per year that is assumed by the interest rate model\\nuint256 constant BLOCKS_PER_YEAR = 10_512_000;\\n\\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\\nuint256 constant EXP_SCALE = 1e18;\\n\\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\\nuint256 constant MANTISSA_ONE = EXP_SCALE;\\n\",\"keccak256\":\"0x04cd899695ea593a2529cb6a1a04c2a34bff0c1516bd70a5f638ae7a850cad8b\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/validators.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\\nerror ZeroAddressNotAllowed();\\n\\n/// @notice Checks if the provided address is nonzero, reverts otherwise\\n/// @param address_ Address to check\\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\\nfunction ensureNonzeroAddress(address address_) pure {\\n    if (address_ == address(0)) {\\n        revert ZeroAddressNotAllowed();\\n    }\\n}\\n\",\"keccak256\":\"0x909eb76841ebd57d8f53686b76b1a09da7bbbbcddb29510c41674d5aa84c713e\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506200001c62000022565b620000e3565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff90811614620000e1576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b612e7f80620000f36000396000f3fe608060405234801561001057600080fd5b50600436106102065760003560e01c806379ba50971161011a578063be203094116100ad578063db7954fd1161007c578063db7954fd14610537578063e30c39781461054a578063efc75f241461055b578063f2fde38b1461057c578063f7c618c11461058f57600080fd5b8063be203094146104e7578063be26317e146104fa578063bea6b8b814610503578063ca37271b1461052457600080fd5b80638c37dfa3116100e95780638c37dfa31461045b5780638da5cb5b1461046e57806392a1823514610493578063b4a0bdf3146104d657600080fd5b806379ba50971461040d5780637c05a7c51461041557806380d45a2d14610435578063856e5e6c1461044857600080fd5b80632eed69061161019d5780636d0493291161016c5780636d049329146103935780636dfd08ca146103a6578063715018a6146103d2578063741b2525146103da57806374c4c1cc146103ed57600080fd5b80632eed69061461033c57806342cbb15c1461034f578063552c0971146103555780636a95ddef1461038057600080fd5b80631627ee89116101d95780631627ee891461027857806323526079146102a65780632a869a4d146102b95780632c427b57146102cc57600080fd5b806304caeb101461020b5780630a3a3a9e146102205780630e32cb8614610233578063160c3a0314610246575b600080fd5b61021e610219366004612660565b6105a3565b005b61021e61022e3660046126b0565b610786565b61021e6102413660046126b0565b6107bd565b61025b6a0c097ce7bc90715b34b9f160241b81565b6040516001600160e01b0390911681526020015b60405180910390f35b6102986102863660046126b0565b60fd6020526000908152604090205481565b60405190815260200161026f565b61021e6102b436600461270f565b6107ce565b61021e6102c73660046126b0565b610807565b6103106102da3660046126b0565b61010060205260009081526040902080546001909101546001600160e01b0382169163ffffffff600160e01b9091048116911683565b604080516001600160e01b03909416845263ffffffff928316602085015291169082015260600161026f565b61021e61034a366004612745565b610961565b43610298565b610298610363366004612771565b60fc60209081526000928352604080842090915290825290205481565b61021e61038e3660046127aa565b610a0f565b61021e6103a1366004612745565b610a4a565b6102986103b4366004612771565b61010360209081526000928352604080842090915290825290205481565b61021e610b01565b61021e6103e83660046126b0565b610b15565b6102986103fb3660046126b0565b60ff6020526000908152604090205481565b61021e610c02565b6102986104233660046126b0565b60fe6020526000908152604090205481565b61021e6104433660046127f2565b610c79565b61021e610456366004612857565b610c8a565b61021e61046936600461294c565b610dc6565b6033546001600160a01b03165b6040516001600160a01b03909116815260200161026f565b6103106104a13660046126b0565b60fb60205260009081526040902080546001909101546001600160e01b0382169163ffffffff600160e01b9091048116911683565b6097546001600160a01b031661047b565b61021e6104f53660046129d4565b610ebd565b61029860c95481565b6102986105113660046126b0565b6101026020526000908152604090205481565b61021e6105323660046126b0565b611015565b61021e610545366004612771565b611095565b6065546001600160a01b031661047b565b6102986105693660046126b0565b6101016020526000908152604090205481565b61021e61058a3660046126b0565b6110ca565b6101055461047b906001600160a01b031681565b80516105ae8161113b565b60005b818110156107405760008382815181106105cd576105cd612a27565b602090810291909101015161010454604051633d98a1e560e01b81526001600160a01b038084166004830152929350911690633d98a1e590602401602060405180830381865afa158015610625573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106499190612a3d565b6106925760405162461bcd60e51b81526020600482015260156024820152741b585c9ad95d081b5d5cdd081899481b1a5cdd1959605a1b60448201526064015b60405180910390fd5b60006040518060200160405280836001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106dd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107019190612a5f565b9052905061070f828261116c565b61071a828783611394565b61072382611523565b61072d8287611706565b50508061073990612a8e565b90506105b1565b506001600160a01b038316600090815260fd60205260409020546107659084906118ab565b6001600160a01b03909316600090815260fd60205260409020929092555050565b610104546001600160a01b031633146107b15760405162461bcd60e51b815260040161068990612aa7565b6107ba81611523565b50565b6107c5611961565b6107ba816119bb565b610104546001600160a01b031633146107f95760405162461bcd60e51b815260040161068990612aa7565b610803828261116c565b5050565b610104546001600160a01b031633146108325760405162461bcd60e51b815260040161068990612aa7565b6000610874435b6040518060400160405280601c81526020017f626c6f636b206e756d6265722065786365656473203332206269747300000000815250611a81565b6001600160a01b038316600090815260fb6020908152604080832061010090925282208154939450909290916001600160e01b0390911690036108d05781546001600160e01b0319166a0c097ce7bc90715b34b9f160241b1782555b80546001600160e01b03166000036109015780546001600160e01b0319166a0c097ce7bc90715b34b9f160241b1781555b805463ffffffff8416600160e01b026001600160e01b039182168117835583549091161782556040516001600160a01b038516907ffe6944646a362be70b0925ea999b3d9f755589a63ffcd89e4fb2b0affd252c7190600090a250505050565b610969611961565b61097282610b15565b80600003610999576001600160a01b038216600090815261010260205260408120556109b5565b436001600160a01b038316600090815261010260205260409020555b6001600160a01b0382166000818152610101602052604090819020839055517f4882c0217331870166b5d239c9f7be7801bab4be26560cd2f8789145d0fd3af490610a039084815260200190565b60405180910390a25050565b610104546001600160a01b03163314610a3a5760405162461bcd60e51b815260040161068990612aa7565b610a45838383611394565b505050565b610a52611961565b6000610a5e83836118ab565b90508015610ab95760405162461bcd60e51b815260206004820152602260248201527f696e73756666696369656e7420726577617264546f6b656e20666f72206772616044820152611b9d60f21b6064820152608401610689565b826001600160a01b03167f251909abf904fc80eac3f0d4c25e5c800441ea19fda63c6f0df08e4f24f926f983604051610af491815260200190565b60405180910390a2505050565b610b09611961565b610b136000611ab1565b565b6001600160a01b0381166000908152610101602090815260408083205461010290925282205490914391610b4a908390611aca565b9050600081118015610b5c5750600083115b15610bfc576000610b6d8285611add565b6001600160a01b038616600090815260fd602052604081205491925090610b949083611ae9565b6001600160a01b038716600081815260fd602081815260408084208681556101028352938190208a90559181529154905190815292935090917f38fe05baf9dc12e4e3bfda3daba26419e9930bf26ee6227f407ca46f8c9c29bc91015b60405180910390a250505b50505050565b60655433906001600160a01b03168114610c705760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610689565b6107ba81611ab1565b610c81611961565b6107ba81611af5565b610cab604051806060016040528060328152602001612de560329139611b8f565b848381148015610cba57508082145b610d2c5760405162461bcd60e51b815260206004820152603860248201527f526577617264734469737472696275746f723a3a7365744c617374526577617260448201527f64696e67426c6f636b7320696e76616c696420696e70757400000000000000006064820152608401610689565b60005b81811015610dbc57610db4888883818110610d4c57610d4c612a27565b9050602002016020810190610d6191906126b0565b878784818110610d7357610d73612a27565b9050602002016020810190610d889190612aee565b868685818110610d9a57610d9a612a27565b9050602002016020810190610daf9190612aee565b611c29565b600101610d2f565b5050505050505050565b610de7604051806060016040528060338152602001612e1760339139611b8f565b8251825181148015610df95750815181145b610e455760405162461bcd60e51b815260206004820152601c60248201527f696e76616c696420736574526577617264546f6b656e537065656473000000006044820152606401610689565b60005b81811015610eb657610ea6858281518110610e6557610e65612a27565b6020026020010151858381518110610e7f57610e7f612a27565b6020026020010151858481518110610e9957610e99612a27565b6020026020010151611ebf565b610eaf81612a8e565b9050610e48565b5050505050565b600054610100900460ff1615808015610edd5750600054600160ff909116105b80610ef75750303b158015610ef7575060005460ff166001145b610f5a5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610689565b6000805460ff191660011790558015610f7d576000805461ff0019166101001790555b61010480546001600160a01b038088166001600160a01b031992831617909255610105805492871692909116919091179055610fb76120ef565b610fc08261211e565b610fc983611af5565b8015610eb6576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050505050565b6107ba8161010460009054906101000a90046001600160a01b03166001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561106d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526102199190810190612b14565b610104546001600160a01b031633146110c05760405162461bcd60e51b815260040161068990612aa7565b6108038282611706565b6110d2611961565b606580546001600160a01b0383166001600160a01b031990911681179091556111036033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b60c9548111156107ba5760c95460405163792bfb1b60e11b8152600481019190915260248101829052604401610689565b6001600160a01b03821660009081526101006020908152604080832060fe909252822054909161119b43610839565b600184015490915063ffffffff16158015906111c45750600183015463ffffffff908116908216115b156111d65750600182015463ffffffff165b82546000906111f59063ffffffff80851691600160e01b900416611aca565b90506000811180156112075750600083115b15611336576000611279876001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa15801561124f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112739190612a5f565b87612145565b905060006112878386611add565b905060008083116112a757604051806020016040528060008152506112b1565b6112b18284612163565b604080516020810190915288546001600160e01b03168152909150611314906112da90836121a7565b5160408051808201909152601a81527f6e657720696e646578206578636565647320323234206269747300000000000060208201526121d3565b6001600160e01b0316600160e01b63ffffffff87160217875550611358915050565b80156113585783546001600160e01b0316600160e01b63ffffffff8416021784555b856001600160a01b03167fbfeed4eb85c013b0e466fdfdbaa785159ff7986078247dc95f1c717a5bd6bca286604051610bf19151815260200190565b6001600160a01b038381166000908152610100602090815260408083208054610103845282852095881685529490925290912080546001600160e01b03909316908190559091801580156113f657506a0c097ce7bc90715b34b9f160241b8210155b1561140c57506a0c097ce7bc90715b34b9f160241b5b600060405180602001604052806114238585611aca565b90526040516395dd919360e01b81526001600160a01b03888116600483015291925060009161147691908a16906395dd919390602401602060405180830381865afa15801561124f573d6000803e3d6000fd5b90508015610dbc57600061148a82846121fe565b6001600160a01b038916600090815260fd6020526040812054919250906114b19083611ae9565b6001600160a01b038a8116600081815260fd602090815260409182902085905581518781529081018590529081018a905292935091908c16907f510d7612da9ca257889eabdfbe0366aaea10020be46f7810f4afb2111d80aa939060600160405180910390a350505050505050505050565b6001600160a01b038116600090815260fb6020908152604080832060ff909252822054909161155143610839565b600184015490915063ffffffff161580159061157a5750600183015463ffffffff908116908216115b1561158c5750600182015463ffffffff165b82546000906115ab9063ffffffff80851691600160e01b900416611aca565b90506000811180156115bd5750600083115b156116a9576000856001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611602573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116269190612a5f565b905060006116348386611add565b90506000808311611654576040518060200160405280600081525061165e565b61165e8284612163565b604080516020810190915288546001600160e01b03168152909150611687906112da90836121a7565b6001600160e01b0316600160e01b63ffffffff871602178755506116cb915050565b80156116cb5783546001600160e01b0316600160e01b63ffffffff8416021784555b6040516001600160a01b038616907f6a7b996800070d8bc0f9a3ddcb0a4b09bc1653f76381d745444956366afd423a90600090a25050505050565b6001600160a01b03828116600090815260fb60209081526040808320805460fc845282852095871685529490925290912080546001600160e01b039093169081905590918015801561176657506a0c097ce7bc90715b34b9f160241b8210155b1561177c57506a0c097ce7bc90715b34b9f160241b5b600060405180602001604052806117938585611aca565b90526040516370a0823160e01b81526001600160a01b0387811660048301529192506000918816906370a0823190602401602060405180830381865afa1580156117e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118059190612a5f565b9050600061181382846121fe565b6001600160a01b038816600090815260fd60205260408120549192509061183a9083611ae9565b6001600160a01b03898116600081815260fd602090815260409182902085905581518781529081018590529081018a905292935091908b16907f9563ff6035b973f2e4514ad9315010c220eb74b0c33a782a18118a199a97e4429060600160405180910390a3505050505050505050565b610105546040516370a0823160e01b815230600482015260009182916001600160a01b03909116906370a0823190602401602060405180830381865afa1580156118f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191d9190612a5f565b905060008311801561192f5750808311155b15611956576101055461194c906001600160a01b03168585612227565b600091505061195b565b829150505b92915050565b6033546001600160a01b03163314610b135760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610689565b6001600160a01b038116611a1f5760405162461bcd60e51b815260206004820152602560248201527f696e76616c696420616365737320636f6e74726f6c206d616e61676572206164604482015264647265737360d81b6064820152608401610689565b609780546001600160a01b038381166001600160a01b031983168117909355604080519190921680825260208201939093527f66fd58e82f7b31a2a5c30e0888f3093efe4e111b00cd2b0c31fe014601293aa091015b60405180910390a15050565b60008163ffffffff841115611aa95760405162461bcd60e51b81526004016106899190612bfb565b509192915050565b606580546001600160a01b03191690556107ba81612279565b6000611ad68284612c0e565b9392505050565b6000611ad68284612c25565b6000611ad68284612c44565b60c9548111611b515760405162461bcd60e51b815260206004820152602260248201527f436f6d7074726f6c6c65723a20496e76616c6964206d61784c6f6f70734c696d6044820152611a5d60f21b6064820152608401610689565b60c980549082905560408051828152602081018490527fc2d09fef144f7c8a86f71ea459f8fc17f675768eb1ae369cbd77fb31d467aafa9101611a75565b6097546040516318c5e8ab60e01b81526000916001600160a01b0316906318c5e8ab90611bc29033908690600401612c5c565b602060405180830381865afa158015611bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c039190612a3d565b90508061080357333083604051634a3fa29360e01b815260040161068993929190612c80565b61010454604051633d98a1e560e01b81526001600160a01b03858116600483015290911690633d98a1e590602401602060405180830381865afa158015611c74573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c989190612a3d565b611ce45760405162461bcd60e51b815260206004820181905260248201527f726577617264546f6b656e206d61726b6574206973206e6f74206c69737465646044820152606401610689565b4363ffffffff83168110611d0a5760405162461bcd60e51b815260040161068990612cb5565b808263ffffffff1611611d2f5760405162461bcd60e51b815260040161068990612cb5565b6001600160a01b038416600090815260fb6020908152604080832060019081015461010090935292209091015463ffffffff9182169116811580611d785750828263ffffffff16115b611d945760405162461bcd60e51b815260040161068990612d12565b63ffffffff81161580611dac5750828163ffffffff16115b611dc85760405162461bcd60e51b815260040161068990612d12565b8463ffffffff168263ffffffff1614611e41576001600160a01b038616600081815260fb6020908152604091829020600101805463ffffffff191663ffffffff8a1690811790915591519182527f41b697bf2627e0a03f253382759baaab2469897004cc619465a3d8f4bb6b3fec910160405180910390a25b8363ffffffff168163ffffffff1614611eb7576001600160a01b03861660008181526101006020908152604091829020600101805463ffffffff191663ffffffff891690811790915591519182527f4163eb203170b7facecc8d7307e3f8affa8826d4df30fc722f8f8ce17988eb919101610bf1565b505050505050565b61010454604051633d98a1e560e01b81526001600160a01b03858116600483015290911690633d98a1e590602401602060405180830381865afa158015611f0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f2e9190612a3d565b611f7a5760405162461bcd60e51b815260206004820181905260248201527f726577617264546f6b656e206d61726b6574206973206e6f74206c69737465646044820152606401610689565b6001600160a01b038316600090815260ff60205260409020548214611ff857611fa283611523565b6001600160a01b038316600081815260ff602052604090819020849055517f24741480445e83baea9eb28086e16a4377ebb4f003c773e386496fd90b3ed04e90611fef9085815260200190565b60405180910390a25b6001600160a01b038316600090815260fe60205260409020548114610a455760006040518060200160405280856001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612062573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120869190612a5f565b90529050612094848261116c565b6001600160a01b038416600081815260fe602052604090819020849055517f2091432bbf4aa40f4785b469e931d32c5f5c6ba66dcf702a99cbe776df729c3c906120e19085815260200190565b60405180910390a250505050565b600054610100900460ff166121165760405162461bcd60e51b815260040161068990612d5b565b610b136122cb565b600054610100900460ff166107c55760405162461bcd60e51b815260040161068990612d5b565b6000611ad661215c84670de0b6b3a7640000611add565b83516122fb565b604080516020810190915260008152604051806020016040528061219e612198866a0c097ce7bc90715b34b9f160241b611add565b856122fb565b90529392505050565b604080516020810190915260008152604051806020016040528061219e85600001518560000151611ae9565b6000816001600160e01b03841115611aa95760405162461bcd60e51b81526004016106899190612bfb565b60006a0c097ce7bc90715b34b9f160241b61221d848460000151611add565b611ad69190612da6565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052610a45908490612307565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff166122f25760405162461bcd60e51b815260040161068990612d5b565b610b1333611ab1565b6000611ad68284612da6565b600061235c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166123dc9092919063ffffffff16565b905080516000148061237d57508080602001905181019061237d9190612a3d565b610a455760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610689565b60606123eb84846000856123f3565b949350505050565b6060824710156124545760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610689565b600080866001600160a01b031685876040516124709190612dc8565b60006040518083038185875af1925050503d80600081146124ad576040519150601f19603f3d011682016040523d82523d6000602084013e6124b2565b606091505b50915091506124c3878383876124ce565b979650505050505050565b6060831561253d578251600003612536576001600160a01b0385163b6125365760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610689565b50816123eb565b6123eb83838151156125525781518083602001fd5b8060405162461bcd60e51b81526004016106899190612bfb565b6001600160a01b03811681146107ba57600080fd5b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156125c0576125c0612581565b604052919050565b600067ffffffffffffffff8211156125e2576125e2612581565b5060051b60200190565b600082601f8301126125fd57600080fd5b8135602061261261260d836125c8565b612597565b82815260059290921b8401810191818101908684111561263157600080fd5b8286015b848110156126555780356126488161256c565b8352918301918301612635565b509695505050505050565b6000806040838503121561267357600080fd5b823561267e8161256c565b9150602083013567ffffffffffffffff81111561269a57600080fd5b6126a6858286016125ec565b9150509250929050565b6000602082840312156126c257600080fd5b8135611ad68161256c565b6000602082840312156126df57600080fd5b6040516020810181811067ffffffffffffffff8211171561270257612702612581565b6040529135825250919050565b6000806040838503121561272257600080fd5b823561272d8161256c565b915061273c84602085016126cd565b90509250929050565b6000806040838503121561275857600080fd5b82356127638161256c565b946020939093013593505050565b6000806040838503121561278457600080fd5b823561278f8161256c565b9150602083013561279f8161256c565b809150509250929050565b6000806000606084860312156127bf57600080fd5b83356127ca8161256c565b925060208401356127da8161256c565b91506127e985604086016126cd565b90509250925092565b60006020828403121561280457600080fd5b5035919050565b60008083601f84011261281d57600080fd5b50813567ffffffffffffffff81111561283557600080fd5b6020830191508360208260051b850101111561285057600080fd5b9250929050565b6000806000806000806060878903121561287057600080fd5b863567ffffffffffffffff8082111561288857600080fd5b6128948a838b0161280b565b909850965060208901359150808211156128ad57600080fd5b6128b98a838b0161280b565b909650945060408901359150808211156128d257600080fd5b506128df89828a0161280b565b979a9699509497509295939492505050565b600082601f83011261290257600080fd5b8135602061291261260d836125c8565b82815260059290921b8401810191818101908684111561293157600080fd5b8286015b848110156126555780358352918301918301612935565b60008060006060848603121561296157600080fd5b833567ffffffffffffffff8082111561297957600080fd5b612985878388016125ec565b9450602086013591508082111561299b57600080fd5b6129a7878388016128f1565b935060408601359150808211156129bd57600080fd5b506129ca868287016128f1565b9150509250925092565b600080600080608085870312156129ea57600080fd5b84356129f58161256c565b93506020850135612a058161256c565b9250604085013591506060850135612a1c8161256c565b939692955090935050565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612a4f57600080fd5b81518015158114611ad657600080fd5b600060208284031215612a7157600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600060018201612aa057612aa0612a78565b5060010190565b60208082526027908201527f4f6e6c7920636f6d7074726f6c6c65722063616e2063616c6c207468697320666040820152663ab731ba34b7b760c91b606082015260800190565b600060208284031215612b0057600080fd5b813563ffffffff81168114611ad657600080fd5b60006020808385031215612b2757600080fd5b825167ffffffffffffffff811115612b3e57600080fd5b8301601f81018513612b4f57600080fd5b8051612b5d61260d826125c8565b81815260059190911b82018301908381019087831115612b7c57600080fd5b928401925b828410156124c3578351612b948161256c565b82529284019290840190612b81565b60005b83811015612bbe578181015183820152602001612ba6565b83811115610bfc5750506000910152565b60008151808452612be7816020860160208601612ba3565b601f01601f19169290920160200192915050565b602081526000611ad66020830184612bcf565b600082821015612c2057612c20612a78565b500390565b6000816000190483118215151615612c3f57612c3f612a78565b500290565b60008219821115612c5757612c57612a78565b500190565b6001600160a01b03831681526040602082018190526000906123eb90830184612bcf565b6001600160a01b03848116825283166020820152606060408201819052600090612cac90830184612bcf565b95945050505050565b60208082526037908201527f73657474696e67206c61737420726577617264696e6720626c6f636b20696e2060408201527f7468652070617374206973206e6f7420616c6c6f776564000000000000000000606082015260800190565b60208082526029908201527f7468697320526577617264734469737472696275746f7220697320616c726561604082015268191e481b1bd8dad95960ba1b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b600082612dc357634e487b7160e01b600052601260045260246000fd5b500490565b60008251612dda818460208701612ba3565b919091019291505056fe7365744c617374526577617264696e67426c6f636b28616464726573735b5d2c75696e7433325b5d2c75696e7433325b5d29736574526577617264546f6b656e53706565647328616464726573735b5d2c75696e743235365b5d2c75696e743235365b5d29a2646970667358221220ee935b642fddd19338c6b0bb3fd97a5140d0b308d86c6822d0a76c26e04087fb64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102065760003560e01c806379ba50971161011a578063be203094116100ad578063db7954fd1161007c578063db7954fd14610537578063e30c39781461054a578063efc75f241461055b578063f2fde38b1461057c578063f7c618c11461058f57600080fd5b8063be203094146104e7578063be26317e146104fa578063bea6b8b814610503578063ca37271b1461052457600080fd5b80638c37dfa3116100e95780638c37dfa31461045b5780638da5cb5b1461046e57806392a1823514610493578063b4a0bdf3146104d657600080fd5b806379ba50971461040d5780637c05a7c51461041557806380d45a2d14610435578063856e5e6c1461044857600080fd5b80632eed69061161019d5780636d0493291161016c5780636d049329146103935780636dfd08ca146103a6578063715018a6146103d2578063741b2525146103da57806374c4c1cc146103ed57600080fd5b80632eed69061461033c57806342cbb15c1461034f578063552c0971146103555780636a95ddef1461038057600080fd5b80631627ee89116101d95780631627ee891461027857806323526079146102a65780632a869a4d146102b95780632c427b57146102cc57600080fd5b806304caeb101461020b5780630a3a3a9e146102205780630e32cb8614610233578063160c3a0314610246575b600080fd5b61021e610219366004612660565b6105a3565b005b61021e61022e3660046126b0565b610786565b61021e6102413660046126b0565b6107bd565b61025b6a0c097ce7bc90715b34b9f160241b81565b6040516001600160e01b0390911681526020015b60405180910390f35b6102986102863660046126b0565b60fd6020526000908152604090205481565b60405190815260200161026f565b61021e6102b436600461270f565b6107ce565b61021e6102c73660046126b0565b610807565b6103106102da3660046126b0565b61010060205260009081526040902080546001909101546001600160e01b0382169163ffffffff600160e01b9091048116911683565b604080516001600160e01b03909416845263ffffffff928316602085015291169082015260600161026f565b61021e61034a366004612745565b610961565b43610298565b610298610363366004612771565b60fc60209081526000928352604080842090915290825290205481565b61021e61038e3660046127aa565b610a0f565b61021e6103a1366004612745565b610a4a565b6102986103b4366004612771565b61010360209081526000928352604080842090915290825290205481565b61021e610b01565b61021e6103e83660046126b0565b610b15565b6102986103fb3660046126b0565b60ff6020526000908152604090205481565b61021e610c02565b6102986104233660046126b0565b60fe6020526000908152604090205481565b61021e6104433660046127f2565b610c79565b61021e610456366004612857565b610c8a565b61021e61046936600461294c565b610dc6565b6033546001600160a01b03165b6040516001600160a01b03909116815260200161026f565b6103106104a13660046126b0565b60fb60205260009081526040902080546001909101546001600160e01b0382169163ffffffff600160e01b9091048116911683565b6097546001600160a01b031661047b565b61021e6104f53660046129d4565b610ebd565b61029860c95481565b6102986105113660046126b0565b6101026020526000908152604090205481565b61021e6105323660046126b0565b611015565b61021e610545366004612771565b611095565b6065546001600160a01b031661047b565b6102986105693660046126b0565b6101016020526000908152604090205481565b61021e61058a3660046126b0565b6110ca565b6101055461047b906001600160a01b031681565b80516105ae8161113b565b60005b818110156107405760008382815181106105cd576105cd612a27565b602090810291909101015161010454604051633d98a1e560e01b81526001600160a01b038084166004830152929350911690633d98a1e590602401602060405180830381865afa158015610625573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106499190612a3d565b6106925760405162461bcd60e51b81526020600482015260156024820152741b585c9ad95d081b5d5cdd081899481b1a5cdd1959605a1b60448201526064015b60405180910390fd5b60006040518060200160405280836001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106dd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107019190612a5f565b9052905061070f828261116c565b61071a828783611394565b61072382611523565b61072d8287611706565b50508061073990612a8e565b90506105b1565b506001600160a01b038316600090815260fd60205260409020546107659084906118ab565b6001600160a01b03909316600090815260fd60205260409020929092555050565b610104546001600160a01b031633146107b15760405162461bcd60e51b815260040161068990612aa7565b6107ba81611523565b50565b6107c5611961565b6107ba816119bb565b610104546001600160a01b031633146107f95760405162461bcd60e51b815260040161068990612aa7565b610803828261116c565b5050565b610104546001600160a01b031633146108325760405162461bcd60e51b815260040161068990612aa7565b6000610874435b6040518060400160405280601c81526020017f626c6f636b206e756d6265722065786365656473203332206269747300000000815250611a81565b6001600160a01b038316600090815260fb6020908152604080832061010090925282208154939450909290916001600160e01b0390911690036108d05781546001600160e01b0319166a0c097ce7bc90715b34b9f160241b1782555b80546001600160e01b03166000036109015780546001600160e01b0319166a0c097ce7bc90715b34b9f160241b1781555b805463ffffffff8416600160e01b026001600160e01b039182168117835583549091161782556040516001600160a01b038516907ffe6944646a362be70b0925ea999b3d9f755589a63ffcd89e4fb2b0affd252c7190600090a250505050565b610969611961565b61097282610b15565b80600003610999576001600160a01b038216600090815261010260205260408120556109b5565b436001600160a01b038316600090815261010260205260409020555b6001600160a01b0382166000818152610101602052604090819020839055517f4882c0217331870166b5d239c9f7be7801bab4be26560cd2f8789145d0fd3af490610a039084815260200190565b60405180910390a25050565b610104546001600160a01b03163314610a3a5760405162461bcd60e51b815260040161068990612aa7565b610a45838383611394565b505050565b610a52611961565b6000610a5e83836118ab565b90508015610ab95760405162461bcd60e51b815260206004820152602260248201527f696e73756666696369656e7420726577617264546f6b656e20666f72206772616044820152611b9d60f21b6064820152608401610689565b826001600160a01b03167f251909abf904fc80eac3f0d4c25e5c800441ea19fda63c6f0df08e4f24f926f983604051610af491815260200190565b60405180910390a2505050565b610b09611961565b610b136000611ab1565b565b6001600160a01b0381166000908152610101602090815260408083205461010290925282205490914391610b4a908390611aca565b9050600081118015610b5c5750600083115b15610bfc576000610b6d8285611add565b6001600160a01b038616600090815260fd602052604081205491925090610b949083611ae9565b6001600160a01b038716600081815260fd602081815260408084208681556101028352938190208a90559181529154905190815292935090917f38fe05baf9dc12e4e3bfda3daba26419e9930bf26ee6227f407ca46f8c9c29bc91015b60405180910390a250505b50505050565b60655433906001600160a01b03168114610c705760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610689565b6107ba81611ab1565b610c81611961565b6107ba81611af5565b610cab604051806060016040528060328152602001612de560329139611b8f565b848381148015610cba57508082145b610d2c5760405162461bcd60e51b815260206004820152603860248201527f526577617264734469737472696275746f723a3a7365744c617374526577617260448201527f64696e67426c6f636b7320696e76616c696420696e70757400000000000000006064820152608401610689565b60005b81811015610dbc57610db4888883818110610d4c57610d4c612a27565b9050602002016020810190610d6191906126b0565b878784818110610d7357610d73612a27565b9050602002016020810190610d889190612aee565b868685818110610d9a57610d9a612a27565b9050602002016020810190610daf9190612aee565b611c29565b600101610d2f565b5050505050505050565b610de7604051806060016040528060338152602001612e1760339139611b8f565b8251825181148015610df95750815181145b610e455760405162461bcd60e51b815260206004820152601c60248201527f696e76616c696420736574526577617264546f6b656e537065656473000000006044820152606401610689565b60005b81811015610eb657610ea6858281518110610e6557610e65612a27565b6020026020010151858381518110610e7f57610e7f612a27565b6020026020010151858481518110610e9957610e99612a27565b6020026020010151611ebf565b610eaf81612a8e565b9050610e48565b5050505050565b600054610100900460ff1615808015610edd5750600054600160ff909116105b80610ef75750303b158015610ef7575060005460ff166001145b610f5a5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610689565b6000805460ff191660011790558015610f7d576000805461ff0019166101001790555b61010480546001600160a01b038088166001600160a01b031992831617909255610105805492871692909116919091179055610fb76120ef565b610fc08261211e565b610fc983611af5565b8015610eb6576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050505050565b6107ba8161010460009054906101000a90046001600160a01b03166001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561106d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526102199190810190612b14565b610104546001600160a01b031633146110c05760405162461bcd60e51b815260040161068990612aa7565b6108038282611706565b6110d2611961565b606580546001600160a01b0383166001600160a01b031990911681179091556111036033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b60c9548111156107ba5760c95460405163792bfb1b60e11b8152600481019190915260248101829052604401610689565b6001600160a01b03821660009081526101006020908152604080832060fe909252822054909161119b43610839565b600184015490915063ffffffff16158015906111c45750600183015463ffffffff908116908216115b156111d65750600182015463ffffffff165b82546000906111f59063ffffffff80851691600160e01b900416611aca565b90506000811180156112075750600083115b15611336576000611279876001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa15801561124f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112739190612a5f565b87612145565b905060006112878386611add565b905060008083116112a757604051806020016040528060008152506112b1565b6112b18284612163565b604080516020810190915288546001600160e01b03168152909150611314906112da90836121a7565b5160408051808201909152601a81527f6e657720696e646578206578636565647320323234206269747300000000000060208201526121d3565b6001600160e01b0316600160e01b63ffffffff87160217875550611358915050565b80156113585783546001600160e01b0316600160e01b63ffffffff8416021784555b856001600160a01b03167fbfeed4eb85c013b0e466fdfdbaa785159ff7986078247dc95f1c717a5bd6bca286604051610bf19151815260200190565b6001600160a01b038381166000908152610100602090815260408083208054610103845282852095881685529490925290912080546001600160e01b03909316908190559091801580156113f657506a0c097ce7bc90715b34b9f160241b8210155b1561140c57506a0c097ce7bc90715b34b9f160241b5b600060405180602001604052806114238585611aca565b90526040516395dd919360e01b81526001600160a01b03888116600483015291925060009161147691908a16906395dd919390602401602060405180830381865afa15801561124f573d6000803e3d6000fd5b90508015610dbc57600061148a82846121fe565b6001600160a01b038916600090815260fd6020526040812054919250906114b19083611ae9565b6001600160a01b038a8116600081815260fd602090815260409182902085905581518781529081018590529081018a905292935091908c16907f510d7612da9ca257889eabdfbe0366aaea10020be46f7810f4afb2111d80aa939060600160405180910390a350505050505050505050565b6001600160a01b038116600090815260fb6020908152604080832060ff909252822054909161155143610839565b600184015490915063ffffffff161580159061157a5750600183015463ffffffff908116908216115b1561158c5750600182015463ffffffff165b82546000906115ab9063ffffffff80851691600160e01b900416611aca565b90506000811180156115bd5750600083115b156116a9576000856001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611602573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116269190612a5f565b905060006116348386611add565b90506000808311611654576040518060200160405280600081525061165e565b61165e8284612163565b604080516020810190915288546001600160e01b03168152909150611687906112da90836121a7565b6001600160e01b0316600160e01b63ffffffff871602178755506116cb915050565b80156116cb5783546001600160e01b0316600160e01b63ffffffff8416021784555b6040516001600160a01b038616907f6a7b996800070d8bc0f9a3ddcb0a4b09bc1653f76381d745444956366afd423a90600090a25050505050565b6001600160a01b03828116600090815260fb60209081526040808320805460fc845282852095871685529490925290912080546001600160e01b039093169081905590918015801561176657506a0c097ce7bc90715b34b9f160241b8210155b1561177c57506a0c097ce7bc90715b34b9f160241b5b600060405180602001604052806117938585611aca565b90526040516370a0823160e01b81526001600160a01b0387811660048301529192506000918816906370a0823190602401602060405180830381865afa1580156117e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118059190612a5f565b9050600061181382846121fe565b6001600160a01b038816600090815260fd60205260408120549192509061183a9083611ae9565b6001600160a01b03898116600081815260fd602090815260409182902085905581518781529081018590529081018a905292935091908b16907f9563ff6035b973f2e4514ad9315010c220eb74b0c33a782a18118a199a97e4429060600160405180910390a3505050505050505050565b610105546040516370a0823160e01b815230600482015260009182916001600160a01b03909116906370a0823190602401602060405180830381865afa1580156118f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191d9190612a5f565b905060008311801561192f5750808311155b15611956576101055461194c906001600160a01b03168585612227565b600091505061195b565b829150505b92915050565b6033546001600160a01b03163314610b135760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610689565b6001600160a01b038116611a1f5760405162461bcd60e51b815260206004820152602560248201527f696e76616c696420616365737320636f6e74726f6c206d616e61676572206164604482015264647265737360d81b6064820152608401610689565b609780546001600160a01b038381166001600160a01b031983168117909355604080519190921680825260208201939093527f66fd58e82f7b31a2a5c30e0888f3093efe4e111b00cd2b0c31fe014601293aa091015b60405180910390a15050565b60008163ffffffff841115611aa95760405162461bcd60e51b81526004016106899190612bfb565b509192915050565b606580546001600160a01b03191690556107ba81612279565b6000611ad68284612c0e565b9392505050565b6000611ad68284612c25565b6000611ad68284612c44565b60c9548111611b515760405162461bcd60e51b815260206004820152602260248201527f436f6d7074726f6c6c65723a20496e76616c6964206d61784c6f6f70734c696d6044820152611a5d60f21b6064820152608401610689565b60c980549082905560408051828152602081018490527fc2d09fef144f7c8a86f71ea459f8fc17f675768eb1ae369cbd77fb31d467aafa9101611a75565b6097546040516318c5e8ab60e01b81526000916001600160a01b0316906318c5e8ab90611bc29033908690600401612c5c565b602060405180830381865afa158015611bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c039190612a3d565b90508061080357333083604051634a3fa29360e01b815260040161068993929190612c80565b61010454604051633d98a1e560e01b81526001600160a01b03858116600483015290911690633d98a1e590602401602060405180830381865afa158015611c74573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c989190612a3d565b611ce45760405162461bcd60e51b815260206004820181905260248201527f726577617264546f6b656e206d61726b6574206973206e6f74206c69737465646044820152606401610689565b4363ffffffff83168110611d0a5760405162461bcd60e51b815260040161068990612cb5565b808263ffffffff1611611d2f5760405162461bcd60e51b815260040161068990612cb5565b6001600160a01b038416600090815260fb6020908152604080832060019081015461010090935292209091015463ffffffff9182169116811580611d785750828263ffffffff16115b611d945760405162461bcd60e51b815260040161068990612d12565b63ffffffff81161580611dac5750828163ffffffff16115b611dc85760405162461bcd60e51b815260040161068990612d12565b8463ffffffff168263ffffffff1614611e41576001600160a01b038616600081815260fb6020908152604091829020600101805463ffffffff191663ffffffff8a1690811790915591519182527f41b697bf2627e0a03f253382759baaab2469897004cc619465a3d8f4bb6b3fec910160405180910390a25b8363ffffffff168163ffffffff1614611eb7576001600160a01b03861660008181526101006020908152604091829020600101805463ffffffff191663ffffffff891690811790915591519182527f4163eb203170b7facecc8d7307e3f8affa8826d4df30fc722f8f8ce17988eb919101610bf1565b505050505050565b61010454604051633d98a1e560e01b81526001600160a01b03858116600483015290911690633d98a1e590602401602060405180830381865afa158015611f0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f2e9190612a3d565b611f7a5760405162461bcd60e51b815260206004820181905260248201527f726577617264546f6b656e206d61726b6574206973206e6f74206c69737465646044820152606401610689565b6001600160a01b038316600090815260ff60205260409020548214611ff857611fa283611523565b6001600160a01b038316600081815260ff602052604090819020849055517f24741480445e83baea9eb28086e16a4377ebb4f003c773e386496fd90b3ed04e90611fef9085815260200190565b60405180910390a25b6001600160a01b038316600090815260fe60205260409020548114610a455760006040518060200160405280856001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612062573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120869190612a5f565b90529050612094848261116c565b6001600160a01b038416600081815260fe602052604090819020849055517f2091432bbf4aa40f4785b469e931d32c5f5c6ba66dcf702a99cbe776df729c3c906120e19085815260200190565b60405180910390a250505050565b600054610100900460ff166121165760405162461bcd60e51b815260040161068990612d5b565b610b136122cb565b600054610100900460ff166107c55760405162461bcd60e51b815260040161068990612d5b565b6000611ad661215c84670de0b6b3a7640000611add565b83516122fb565b604080516020810190915260008152604051806020016040528061219e612198866a0c097ce7bc90715b34b9f160241b611add565b856122fb565b90529392505050565b604080516020810190915260008152604051806020016040528061219e85600001518560000151611ae9565b6000816001600160e01b03841115611aa95760405162461bcd60e51b81526004016106899190612bfb565b60006a0c097ce7bc90715b34b9f160241b61221d848460000151611add565b611ad69190612da6565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052610a45908490612307565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff166122f25760405162461bcd60e51b815260040161068990612d5b565b610b1333611ab1565b6000611ad68284612da6565b600061235c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166123dc9092919063ffffffff16565b905080516000148061237d57508080602001905181019061237d9190612a3d565b610a455760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610689565b60606123eb84846000856123f3565b949350505050565b6060824710156124545760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610689565b600080866001600160a01b031685876040516124709190612dc8565b60006040518083038185875af1925050503d80600081146124ad576040519150601f19603f3d011682016040523d82523d6000602084013e6124b2565b606091505b50915091506124c3878383876124ce565b979650505050505050565b6060831561253d578251600003612536576001600160a01b0385163b6125365760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610689565b50816123eb565b6123eb83838151156125525781518083602001fd5b8060405162461bcd60e51b81526004016106899190612bfb565b6001600160a01b03811681146107ba57600080fd5b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156125c0576125c0612581565b604052919050565b600067ffffffffffffffff8211156125e2576125e2612581565b5060051b60200190565b600082601f8301126125fd57600080fd5b8135602061261261260d836125c8565b612597565b82815260059290921b8401810191818101908684111561263157600080fd5b8286015b848110156126555780356126488161256c565b8352918301918301612635565b509695505050505050565b6000806040838503121561267357600080fd5b823561267e8161256c565b9150602083013567ffffffffffffffff81111561269a57600080fd5b6126a6858286016125ec565b9150509250929050565b6000602082840312156126c257600080fd5b8135611ad68161256c565b6000602082840312156126df57600080fd5b6040516020810181811067ffffffffffffffff8211171561270257612702612581565b6040529135825250919050565b6000806040838503121561272257600080fd5b823561272d8161256c565b915061273c84602085016126cd565b90509250929050565b6000806040838503121561275857600080fd5b82356127638161256c565b946020939093013593505050565b6000806040838503121561278457600080fd5b823561278f8161256c565b9150602083013561279f8161256c565b809150509250929050565b6000806000606084860312156127bf57600080fd5b83356127ca8161256c565b925060208401356127da8161256c565b91506127e985604086016126cd565b90509250925092565b60006020828403121561280457600080fd5b5035919050565b60008083601f84011261281d57600080fd5b50813567ffffffffffffffff81111561283557600080fd5b6020830191508360208260051b850101111561285057600080fd5b9250929050565b6000806000806000806060878903121561287057600080fd5b863567ffffffffffffffff8082111561288857600080fd5b6128948a838b0161280b565b909850965060208901359150808211156128ad57600080fd5b6128b98a838b0161280b565b909650945060408901359150808211156128d257600080fd5b506128df89828a0161280b565b979a9699509497509295939492505050565b600082601f83011261290257600080fd5b8135602061291261260d836125c8565b82815260059290921b8401810191818101908684111561293157600080fd5b8286015b848110156126555780358352918301918301612935565b60008060006060848603121561296157600080fd5b833567ffffffffffffffff8082111561297957600080fd5b612985878388016125ec565b9450602086013591508082111561299b57600080fd5b6129a7878388016128f1565b935060408601359150808211156129bd57600080fd5b506129ca868287016128f1565b9150509250925092565b600080600080608085870312156129ea57600080fd5b84356129f58161256c565b93506020850135612a058161256c565b9250604085013591506060850135612a1c8161256c565b939692955090935050565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612a4f57600080fd5b81518015158114611ad657600080fd5b600060208284031215612a7157600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600060018201612aa057612aa0612a78565b5060010190565b60208082526027908201527f4f6e6c7920636f6d7074726f6c6c65722063616e2063616c6c207468697320666040820152663ab731ba34b7b760c91b606082015260800190565b600060208284031215612b0057600080fd5b813563ffffffff81168114611ad657600080fd5b60006020808385031215612b2757600080fd5b825167ffffffffffffffff811115612b3e57600080fd5b8301601f81018513612b4f57600080fd5b8051612b5d61260d826125c8565b81815260059190911b82018301908381019087831115612b7c57600080fd5b928401925b828410156124c3578351612b948161256c565b82529284019290840190612b81565b60005b83811015612bbe578181015183820152602001612ba6565b83811115610bfc5750506000910152565b60008151808452612be7816020860160208601612ba3565b601f01601f19169290920160200192915050565b602081526000611ad66020830184612bcf565b600082821015612c2057612c20612a78565b500390565b6000816000190483118215151615612c3f57612c3f612a78565b500290565b60008219821115612c5757612c57612a78565b500190565b6001600160a01b03831681526040602082018190526000906123eb90830184612bcf565b6001600160a01b03848116825283166020820152606060408201819052600090612cac90830184612bcf565b95945050505050565b60208082526037908201527f73657474696e67206c61737420726577617264696e6720626c6f636b20696e2060408201527f7468652070617374206973206e6f7420616c6c6f776564000000000000000000606082015260800190565b60208082526029908201527f7468697320526577617264734469737472696275746f7220697320616c726561604082015268191e481b1bd8dad95960ba1b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b600082612dc357634e487b7160e01b600052601260045260246000fd5b500490565b60008251612dda818460208701612ba3565b919091019291505056fe7365744c617374526577617264696e67426c6f636b28616464726573735b5d2c75696e7433325b5d2c75696e7433325b5d29736574526577617264546f6b656e53706565647328616464726573735b5d2c75696e743235365b5d2c75696e743235365b5d29a2646970667358221220ee935b642fddd19338c6b0bb3fd97a5140d0b308d86c6822d0a76c26e04087fb64736f6c634300080d0033",
  "devdoc": {
    "author": "Venus",
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "claimRewardToken(address)": {
        "params": {
          "holder": "The address to claim REWARD TOKEN for"
        }
      },
      "claimRewardToken(address,address[])": {
        "params": {
          "holder": "The address to claim REWARD TOKEN for",
          "vTokens": "The list of markets to claim REWARD TOKEN in"
        }
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "distributeBorrowerRewardToken(address,address,(uint256))": {
        "details": "This function should only be called when the user has a borrow position in the market      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)      We avoid an external call to check if they are in the market to save gas because this function is called in many places",
        "params": {
          "borrower": "The address of the borrower to distribute REWARD TOKEN to",
          "marketBorrowIndex": "The current global borrow index of vToken",
          "vToken": "The market in which the borrower is interacting"
        }
      },
      "grantRewardToken(address,uint256)": {
        "details": "Note: If there is not enough REWARD TOKEN, we do not perform the transfer all",
        "params": {
          "amount": "The amount of REWARD TOKEN to (possibly) transfer",
          "recipient": "The address of the recipient to transfer REWARD TOKEN to"
        }
      },
      "initialize(address,address,uint256,address)": {
        "details": "Initializes the deployer to owner",
        "params": {
          "accessControlManager_": "AccessControlManager contract address",
          "comptroller_": "Comptroller to attach the reward distributor to",
          "loopsLimit_": "Maximum number of iterations for the loops in this contract",
          "rewardToken_": "Reward token to distribute"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "setAccessControlManager(address)": {
        "custom:access": "Only Governance",
        "custom:event": "Emits NewAccessControlManager event",
        "details": "Admin function to set address of AccessControlManager",
        "params": {
          "accessControlManager_": "The new address of the AccessControlManager"
        }
      },
      "setContributorRewardTokenSpeed(address,uint256)": {
        "params": {
          "contributor": "The contributor whose REWARD TOKEN speed to update",
          "rewardTokenSpeed": "New REWARD TOKEN speed for contributor"
        }
      },
      "setLastRewardingBlocks(address[],uint32[],uint32[])": {
        "params": {
          "borrowLastRewardingBlocks": "New borrow-side REWARD TOKEN last rewarding block for the corresponding market",
          "supplyLastRewardingBlocks": "New supply-side REWARD TOKEN last rewarding block for the corresponding market",
          "vTokens": "The markets whose REWARD TOKEN last rewarding block to update"
        }
      },
      "setMaxLoopsLimit(uint256)": {
        "params": {
          "limit": "Limit for the max loops can execute at a time"
        }
      },
      "setRewardTokenSpeeds(address[],uint256[],uint256[])": {
        "params": {
          "borrowSpeeds": "New borrow-side REWARD TOKEN speed for the corresponding market",
          "supplySpeeds": "New supply-side REWARD TOKEN speed for the corresponding market",
          "vTokens": "The markets whose REWARD TOKEN speed to update"
        }
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
      },
      "updateContributorRewards(address)": {
        "params": {
          "contributor": "The address to calculate contributor rewards for"
        }
      }
    },
    "title": "`RewardsDistributor`",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "MaxLoopsLimitExceeded(uint256,uint256)": [
        {
          "notice": "Thrown an error on maxLoopsLimit exceeds for any loop"
        }
      ],
      "Unauthorized(address,address,string)": [
        {
          "notice": "Thrown when the action is prohibited by AccessControlManager"
        }
      ]
    },
    "events": {
      "BorrowLastRewardingBlockUpdated(address,uint32)": {
        "notice": "Emitted when a reward token last rewarding block for borrow is updated"
      },
      "ContributorRewardTokenSpeedUpdated(address,uint256)": {
        "notice": "Emitted when a new REWARD TOKEN speed is set for a contributor"
      },
      "ContributorRewardsUpdated(address,uint256)": {
        "notice": "Emitted when a reward for contributor is updated"
      },
      "DistributedBorrowerRewardToken(address,address,uint256,uint256,uint256)": {
        "notice": "Emitted when REWARD TOKEN is distributed to a borrower"
      },
      "DistributedSupplierRewardToken(address,address,uint256,uint256,uint256)": {
        "notice": "Emitted when REWARD TOKEN is distributed to a supplier"
      },
      "MarketInitialized(address)": {
        "notice": "Emitted when a market is initialized"
      },
      "MaxLoopsLimitUpdated(uint256,uint256)": {
        "notice": "Emitted when max loops limit is set"
      },
      "NewAccessControlManager(address,address)": {
        "notice": "Emitted when access control manager contract address is changed"
      },
      "RewardTokenBorrowIndexUpdated(address,(uint256))": {
        "notice": "Emitted when a reward token borrow index is updated"
      },
      "RewardTokenBorrowSpeedUpdated(address,uint256)": {
        "notice": "Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market"
      },
      "RewardTokenGranted(address,uint256)": {
        "notice": "Emitted when REWARD TOKEN is granted by admin"
      },
      "RewardTokenSupplyIndexUpdated(address)": {
        "notice": "Emitted when a reward token supply index is updated"
      },
      "RewardTokenSupplySpeedUpdated(address,uint256)": {
        "notice": "Emitted when a new supply-side REWARD TOKEN speed is calculated for a market"
      },
      "SupplyLastRewardingBlockUpdated(address,uint32)": {
        "notice": "Emitted when a reward token last rewarding block for supply is updated"
      }
    },
    "kind": "user",
    "methods": {
      "INITIAL_INDEX()": {
        "notice": "The initial REWARD TOKEN index for a market"
      },
      "accessControlManager()": {
        "notice": "Returns the address of the access control manager contract"
      },
      "claimRewardToken(address)": {
        "notice": "Claim all the rewardToken accrued by holder in all markets"
      },
      "claimRewardToken(address,address[])": {
        "notice": "Claim all the rewardToken accrued by holder in the specified markets"
      },
      "distributeBorrowerRewardToken(address,address,(uint256))": {
        "notice": "Calculate reward token accrued by a borrower and possibly transfer it to them         Borrowers will begin to accrue after the first interaction with the protocol."
      },
      "grantRewardToken(address,uint256)": {
        "notice": "Transfer REWARD TOKEN to the recipient"
      },
      "initialize(address,address,uint256,address)": {
        "notice": "RewardsDistributor initializer"
      },
      "lastContributorBlock(address)": {
        "notice": "Last block at which a contributor's REWARD TOKEN rewards have been allocated"
      },
      "rewardTokenAccrued(address)": {
        "notice": "The REWARD TOKEN accrued but not yet transferred to each user"
      },
      "rewardTokenBorrowSpeeds(address)": {
        "notice": "The rate at which rewardToken is distributed to the corresponding borrow market (per block)"
      },
      "rewardTokenBorrowState(address)": {
        "notice": "The REWARD TOKEN market borrow state for each market"
      },
      "rewardTokenBorrowerIndex(address,address)": {
        "notice": "The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN"
      },
      "rewardTokenContributorSpeeds(address)": {
        "notice": "The portion of REWARD TOKEN that each contributor receives per block"
      },
      "rewardTokenSupplierIndex(address,address)": {
        "notice": "The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN"
      },
      "rewardTokenSupplySpeeds(address)": {
        "notice": "The rate at which rewardToken is distributed to the corresponding supply market (per block)"
      },
      "rewardTokenSupplyState(address)": {
        "notice": "The REWARD TOKEN market supply state for each market"
      },
      "setAccessControlManager(address)": {
        "notice": "Sets the address of AccessControlManager"
      },
      "setContributorRewardTokenSpeed(address,uint256)": {
        "notice": "Set REWARD TOKEN speed for a single contributor"
      },
      "setLastRewardingBlocks(address[],uint32[],uint32[])": {
        "notice": "Set REWARD TOKEN last rewarding block for the specified markets"
      },
      "setMaxLoopsLimit(uint256)": {
        "notice": "Set the limit for the loops can iterate to avoid the DOS"
      },
      "setRewardTokenSpeeds(address[],uint256[],uint256[])": {
        "notice": "Set REWARD TOKEN borrow and supply speeds for the specified markets"
      },
      "updateContributorRewards(address)": {
        "notice": "Calculate additional accrued REWARD TOKEN for a contributor since last accrual"
      }
    },
    "notice": "Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol. Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool. Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward token to be released each block for borrowers and suppliers, which is distributed based on a users percentage of the borrows or supplies respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting their contributor reward token speed, which similarly allocates a fixed amount of reward token per block. The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 290,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 293,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1397,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 162,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 282,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 71,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "101",
        "type": "t_address"
      },
      {
        "astId": 150,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 3341,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "_accessControlManager",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(IAccessControlManagerV8)3525"
      },
      {
        "astId": 3346,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 10688,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "maxLoopsLimit",
        "offset": 0,
        "slot": "201",
        "type": "t_uint256"
      },
      {
        "astId": 10693,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "__gap",
        "offset": 0,
        "slot": "202",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 11644,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenSupplyState",
        "offset": 0,
        "slot": "251",
        "type": "t_mapping(t_address,t_struct(RewardToken)11634_storage)"
      },
      {
        "astId": 11651,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenSupplierIndex",
        "offset": 0,
        "slot": "252",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 11656,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenAccrued",
        "offset": 0,
        "slot": "253",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11661,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenBorrowSpeeds",
        "offset": 0,
        "slot": "254",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11666,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenSupplySpeeds",
        "offset": 0,
        "slot": "255",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11672,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenBorrowState",
        "offset": 0,
        "slot": "256",
        "type": "t_mapping(t_address,t_struct(RewardToken)11634_storage)"
      },
      {
        "astId": 11677,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenContributorSpeeds",
        "offset": 0,
        "slot": "257",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11682,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "lastContributorBlock",
        "offset": 0,
        "slot": "258",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11689,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardTokenBorrowerIndex",
        "offset": 0,
        "slot": "259",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 11692,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "comptroller",
        "offset": 0,
        "slot": "260",
        "type": "t_contract(Comptroller)7964"
      },
      {
        "astId": 11695,
        "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
        "label": "rewardToken",
        "offset": 0,
        "slot": "261",
        "type": "t_contract(IERC20Upgradeable)614"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Comptroller)7964": {
        "encoding": "inplace",
        "label": "contract Comptroller",
        "numberOfBytes": "20"
      },
      "t_contract(IAccessControlManagerV8)3525": {
        "encoding": "inplace",
        "label": "contract IAccessControlManagerV8",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20Upgradeable)614": {
        "encoding": "inplace",
        "label": "contract IERC20Upgradeable",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_struct(RewardToken)11634_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct RewardsDistributor.RewardToken)",
        "numberOfBytes": "32",
        "value": "t_struct(RewardToken)11634_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(RewardToken)11634_storage": {
        "encoding": "inplace",
        "label": "struct RewardsDistributor.RewardToken",
        "members": [
          {
            "astId": 11629,
            "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
            "label": "index",
            "offset": 0,
            "slot": "0",
            "type": "t_uint224"
          },
          {
            "astId": 11631,
            "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
            "label": "block",
            "offset": 28,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11633,
            "contract": "contracts/Rewards/RewardsDistributor.sol:RewardsDistributor",
            "label": "lastRewardingBlock",
            "offset": 0,
            "slot": "1",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint224": {
        "encoding": "inplace",
        "label": "uint224",
        "numberOfBytes": "28"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}
