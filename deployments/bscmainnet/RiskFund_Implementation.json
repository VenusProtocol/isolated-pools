{
  "address": "0x470443271a416214841a617cbFB8b2f060dDb830",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "corePoolComptroller_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vbnb_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "nativeWrapped_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ApproveFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "loopsLimit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "requiredLoops",
          "type": "uint256"
        }
      ],
      "name": "MaxLoopsLimitExceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "calledContract",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "methodSignature",
          "type": "string"
        }
      ],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddressNotAllowed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "AssetsReservesUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldConvertibleBaseAsset",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newConvertibleBaseAsset",
          "type": "address"
        }
      ],
      "name": "ConvertibleBaseAssetUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldMaxLoopsLimit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newmaxLoopsLimit",
          "type": "uint256"
        }
      ],
      "name": "MaxLoopsLimitUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldMinAmountToConvert",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newMinAmountToConvert",
          "type": "uint256"
        }
      ],
      "name": "MinAmountToConvertUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldAccessControlManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAccessControlManager",
          "type": "address"
        }
      ],
      "name": "NewAccessControlManager",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldPancakeSwapRouter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newPancakeSwapRouter",
          "type": "address"
        }
      ],
      "name": "PancakeSwapRouterUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldPoolRegistry",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newPoolRegistry",
          "type": "address"
        }
      ],
      "name": "PoolRegistryUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldShortfallContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newShortfallContract",
          "type": "address"
        }
      ],
      "name": "ShortfallContractUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "markets",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amountsOutMin",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        }
      ],
      "name": "SwappedPoolsAssets",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "SweepToken",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferredReserveForAuction",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CORE_POOL_COMPTROLLER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NATIVE_WRAPPED",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VBNB",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "accessControlManager",
      "outputs": [
        {
          "internalType": "contract IAccessControlManagerV8",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "assetsReserves",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "convertibleBaseAsset",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "getPoolAssetReserve",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        }
      ],
      "name": "getPoolsBaseAssetReserves",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pancakeSwapRouter_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minAmountToConvert_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "convertibleBaseAsset_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "accessControlManager_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "loopsLimit_",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxLoopsLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minAmountToConvert",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pancakeSwapRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "poolRegistry",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "accessControlManager_",
          "type": "address"
        }
      ],
      "name": "setAccessControlManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_convertibleBaseAsset",
          "type": "address"
        }
      ],
      "name": "setConvertibleBaseAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "setMaxLoopsLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "minAmountToConvert_",
          "type": "uint256"
        }
      ],
      "name": "setMinAmountToConvert",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pancakeSwapRouter_",
          "type": "address"
        }
      ],
      "name": "setPancakeSwapRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistry_",
          "type": "address"
        }
      ],
      "name": "setPoolRegistry",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "shortfallContractAddress_",
          "type": "address"
        }
      ],
      "name": "setShortfallContractAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "shortfall",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "markets",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amountsOutMin",
          "type": "uint256[]"
        },
        {
          "internalType": "address[][]",
          "name": "paths",
          "type": "address[][]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "swapPoolsAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        }
      ],
      "name": "sweepToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferReserveForAuction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "updateAssetsState",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf1bb734413dee3f943e457c8734e4b66e3dd8dd9783329b88c273f4780e95ef6",
  "receipt": {
    "to": null,
    "from": "0x8BDA9f9E1fEF0DFd404Fef338D9fE4c543d172e1",
    "contractAddress": "0x470443271a416214841a617cbFB8b2f060dDb830",
    "transactionIndex": 46,
    "gasUsed": "2769907",
    "logsBloom": "0x00000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000080000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5265158486084e468ed2c2e0d3ff83459eb807e24726f2936f01c910a19c6af7",
    "transactionHash": "0xf1bb734413dee3f943e457c8734e4b66e3dd8dd9783329b88c273f4780e95ef6",
    "logs": [
      {
        "transactionIndex": 46,
        "blockNumber": 32457691,
        "transactionHash": "0xf1bb734413dee3f943e457c8734e4b66e3dd8dd9783329b88c273f4780e95ef6",
        "address": "0x470443271a416214841a617cbFB8b2f060dDb830",
        "topics": ["0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 220,
        "blockHash": "0x5265158486084e468ed2c2e0d3ff83459eb807e24726f2936f01c910a19c6af7"
      }
    ],
    "blockNumber": 32457691,
    "cumulativeGasUsed": "11147413",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xfD36E2c2a6789Db23113685031d7F16329158384",
    "0xA07c5b74C9B40447a954e1466938b865b6BBea36",
    "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"
  ],
  "numDeployments": 1,
  "solcInputHash": "f237ea044837d6f4ff4c08abcdd27558",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"corePoolComptroller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vbnb_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nativeWrapped_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApproveFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loopsLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredLoops\",\"type\":\"uint256\"}],\"name\":\"MaxLoopsLimitExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calledContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"methodSignature\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetsReservesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldConvertibleBaseAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newConvertibleBaseAsset\",\"type\":\"address\"}],\"name\":\"ConvertibleBaseAssetUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxLoopsLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newmaxLoopsLimit\",\"type\":\"uint256\"}],\"name\":\"MaxLoopsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinAmountToConvert\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinAmountToConvert\",\"type\":\"uint256\"}],\"name\":\"MinAmountToConvertUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAccessControlManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAccessControlManager\",\"type\":\"address\"}],\"name\":\"NewAccessControlManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPancakeSwapRouter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPancakeSwapRouter\",\"type\":\"address\"}],\"name\":\"PancakeSwapRouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPoolRegistry\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPoolRegistry\",\"type\":\"address\"}],\"name\":\"PoolRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldShortfallContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newShortfallContract\",\"type\":\"address\"}],\"name\":\"ShortfallContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"markets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsOutMin\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"SwappedPoolsAssets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SweepToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferredReserveForAuction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CORE_POOL_COMPTROLLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_WRAPPED\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlManager\",\"outputs\":[{\"internalType\":\"contract IAccessControlManagerV8\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetsReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertibleBaseAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPoolAssetReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"}],\"name\":\"getPoolsBaseAssetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pancakeSwapRouter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountToConvert_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"convertibleBaseAsset_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loopsLimit_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLoopsLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToConvert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeSwapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"}],\"name\":\"setAccessControlManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_convertibleBaseAsset\",\"type\":\"address\"}],\"name\":\"setConvertibleBaseAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setMaxLoopsLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmountToConvert_\",\"type\":\"uint256\"}],\"name\":\"setMinAmountToConvert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pancakeSwapRouter_\",\"type\":\"address\"}],\"name\":\"setPancakeSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistry_\",\"type\":\"address\"}],\"name\":\"setPoolRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shortfallContractAddress_\",\"type\":\"address\"}],\"name\":\"setShortfallContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shortfall\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"markets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOutMin\",\"type\":\"uint256[]\"},{\"internalType\":\"address[][]\",\"name\":\"paths\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapPoolsAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferReserveForAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"updateAssetsState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Venus\",\"details\":\"This contract does not support BNB.\",\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\",\"details\":\"Note that the contract is upgradeable. Use initialize() or reinitializers      to set the state variables.\"},\"getPoolAssetReserve(address,address)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown when asset address is zero\",\"params\":{\"asset\":\"Asset address.\",\"comptroller\":\"Comptroller address(pool).\"},\"returns\":{\"_0\":\"Asset's reserve in risk fund.\"}},\"getPoolsBaseAssetReserves(address)\":{\"params\":{\"comptroller\":\"Comptroller address(pool).\"},\"returns\":{\"_0\":\"Base Asset's reserve in risk fund.\"}},\"initialize(address,uint256,address,address,uint256)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown when PCS router address is zeroZeroAddressNotAllowed is thrown when convertible base asset address is zero\",\"params\":{\"accessControlManager_\":\"Address of the access control contract\",\"convertibleBaseAsset_\":\"Address of the base asset\",\"loopsLimit_\":\"Limit for the loops in the contract to avoid DOS\",\"minAmountToConvert_\":\"Minimum amount assets must be worth to convert into base asset\",\"pancakeSwapRouter_\":\"Address of the PancakeSwap router\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setAccessControlManager(address)\":{\"custom:access\":\"Only Governance\",\"custom:event\":\"Emits NewAccessControlManager event\",\"details\":\"Admin function to set address of AccessControlManager\",\"params\":{\"accessControlManager_\":\"The new address of the AccessControlManager\"}},\"setConvertibleBaseAsset(address)\":{\"params\":{\"_convertibleBaseAsset\":\"Address for new convertible base asset.\"}},\"setMaxLoopsLimit(uint256)\":{\"params\":{\"limit\":\"Limit for the max loops can execute at a time\"}},\"setMinAmountToConvert(uint256)\":{\"params\":{\"minAmountToConvert_\":\"Min amount to convert.\"}},\"setPancakeSwapRouter(address)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown when PCS router address is zero\",\"params\":{\"pancakeSwapRouter_\":\"Address of the PancakeSwap router\"}},\"setPoolRegistry(address)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown when pool registry address is zero\",\"params\":{\"poolRegistry_\":\"Address of the pool registry\"}},\"setShortfallContractAddress(address)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown when shortfall contract address is zero\",\"params\":{\"shortfallContractAddress_\":\"Address of the auction contract\"}},\"swapPoolsAssets(address[],uint256[],address[][],uint256)\":{\"custom:error\":\"ZeroAddressNotAllowed is thrown if PoolRegistry contract address is not configured\",\"params\":{\"amountsOutMin\":\"Minimum amount to receive for swap\",\"deadline\":\"Deadline for the swap\",\"markets\":\"Array of vTokens whose assets to swap for base asset\",\"paths\":\"A path consisting of PCS token pairs for each swap\"},\"returns\":{\"_0\":\"Number of swapped tokens\"}},\"sweepToken(address,address)\":{\"custom:access\":\"Only Owner\",\"custom:error\":\"ZeroAddressNotAllowed is thrown when asset address is zero\",\"params\":{\"_to\":\"Recipient of the output tokens.\",\"_token\":\"The address of the BEP-20 token to sweep\"}},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"},\"transferReserveForAuction(address,uint256)\":{\"params\":{\"amount\":\"Amount to be transferred to auction contract.\",\"comptroller\":\"Comptroller of the pool.\"},\"returns\":{\"_0\":\"Number reserved tokens.\"}},\"updateAssetsState(address,address)\":{\"params\":{\"asset\":\"Asset address.\",\"comptroller\":\"Comptroller address(pool).\"}}},\"title\":\"RiskFund\",\"version\":1},\"userdoc\":{\"errors\":{\"ApproveFailed()\":[{\"notice\":\"Thrown if a contract is unable to approve a transfer\"}],\"MaxLoopsLimitExceeded(uint256,uint256)\":[{\"notice\":\"Thrown an error on maxLoopsLimit exceeds for any loop\"}],\"Unauthorized(address,address,string)\":[{\"notice\":\"Thrown when the action is prohibited by AccessControlManager\"}],\"ZeroAddressNotAllowed()\":[{\"notice\":\"Thrown if the supplied address is a zero address where it is not allowed\"}]},\"events\":{\"AssetsReservesUpdated(address,address,uint256)\":{\"notice\":\"Event emitted after the update of the assets reserves.\"},\"ConvertibleBaseAssetUpdated(address,address)\":{\"notice\":\"Emitted when convertible base asset is updated\"},\"MaxLoopsLimitUpdated(uint256,uint256)\":{\"notice\":\"Emitted when max loops limit is set\"},\"MinAmountToConvertUpdated(uint256,uint256)\":{\"notice\":\"Emitted when minimum amount to convert is updated\"},\"NewAccessControlManager(address,address)\":{\"notice\":\"Emitted when access control manager contract address is changed\"},\"PancakeSwapRouterUpdated(address,address)\":{\"notice\":\"Emitted when PancakeSwap router contract address is updated\"},\"PoolRegistryUpdated(address,address)\":{\"notice\":\"Emitted when pool registry address is updated\"},\"ShortfallContractUpdated(address,address)\":{\"notice\":\"Emitted when shortfall contract address is updated\"},\"SwappedPoolsAssets(address[],uint256[],uint256)\":{\"notice\":\"Emitted when pools assets are swapped\"},\"SweepToken(address,address,uint256)\":{\"notice\":\"event emitted on sweep token success\"},\"TransferredReserveForAuction(address,uint256)\":{\"notice\":\"Emitted when reserves are transferred for auction\"}},\"kind\":\"user\",\"methods\":{\"accessControlManager()\":{\"notice\":\"Returns the address of the access control manager contract\"},\"getPoolAssetReserve(address,address)\":{\"notice\":\"Get the Amount of the asset in the risk fund for the specific pool.\"},\"getPoolsBaseAssetReserves(address)\":{\"notice\":\"Get the Amount of the Base asset in the risk fund for the specific pool.\"},\"initialize(address,uint256,address,address,uint256)\":{\"notice\":\"Initializes the deployer to owner.\"},\"setAccessControlManager(address)\":{\"notice\":\"Sets the address of AccessControlManager\"},\"setConvertibleBaseAsset(address)\":{\"notice\":\"Sets a new convertible base asset\"},\"setMaxLoopsLimit(uint256)\":{\"notice\":\"Set the limit for the loops can iterate to avoid the DOS\"},\"setMinAmountToConvert(uint256)\":{\"notice\":\"Min amount to convert setter\"},\"setPancakeSwapRouter(address)\":{\"notice\":\"PancakeSwap router address setter\"},\"setPoolRegistry(address)\":{\"notice\":\"Pool registry setter\"},\"setShortfallContractAddress(address)\":{\"notice\":\"Shortfall contract address setter\"},\"swapPoolsAssets(address[],uint256[],address[][],uint256)\":{\"notice\":\"Swap array of pool assets into base asset's tokens of at least a minimum amount\"},\"sweepToken(address,address)\":{\"notice\":\"A public function to sweep accidental BEP-20 transfers to this contract. Tokens are sent to the address `to`, provided in input\"},\"transferReserveForAuction(address,uint256)\":{\"notice\":\"Transfer tokens for auction.\"},\"updateAssetsState(address,address)\":{\"notice\":\"Update the reserve of the asset for the specific pool after transferring to risk fund.\"}},\"notice\":\"Contract with basic features to track/hold different assets for different Comptrollers.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RiskFund/RiskFund.sol\":\"RiskFund\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x84efb8889801b0ac817324aff6acc691d07bbee816b671817132911d287a8c63\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x4075622496acc77fd6d4de4cc30a8577a744d5c75afad33fdeacf1704d6eda98\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xd60f939a3ca0199014d079b4dd66aa757954334947d81eb5c1d35d7a83061ab3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x4dae161227d332808312ee2caf6384929321b83c16cc89b5642985fbec6b814c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\nimport \\\"./IAccessControlManagerV8.sol\\\";\\n\\n/**\\n * @title Venus Access Control Contract.\\n * @dev The AccessControlledV8 contract is a wrapper around the OpenZeppelin AccessControl contract\\n *      It provides a standardized way to control access to methods within the Venus Smart Contract Ecosystem.\\n *      The contract allows the owner to set an AccessControlManager contract address.\\n *      It can restrict method calls based on the sender's role and the method's signature.\\n */\\n\\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\\n    /// @notice Access control manager contract\\n    IAccessControlManagerV8 private _accessControlManager;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when access control manager contract address is changed\\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\\n\\n    /// @notice Thrown when the action is prohibited by AccessControlManager\\n    error Unauthorized(address sender, address calledContract, string methodSignature);\\n\\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n    }\\n\\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Sets the address of AccessControlManager\\n     * @dev Admin function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     * @custom:event Emits NewAccessControlManager event\\n     * @custom:access Only Governance\\n     */\\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the access control manager contract\\n     */\\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\\n        return _accessControlManager;\\n    }\\n\\n    /**\\n     * @dev Internal function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     */\\n    function _setAccessControlManager(address accessControlManager_) internal {\\n        require(address(accessControlManager_) != address(0), \\\"invalid acess control manager address\\\");\\n        address oldAccessControlManager = address(_accessControlManager);\\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Reverts if the call is not allowed by AccessControlManager\\n     * @param signature Method signature\\n     */\\n    function _checkAccessAllowed(string memory signature) internal view {\\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\\n\\n        if (!isAllowedToCall) {\\n            revert Unauthorized(msg.sender, address(this), signature);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x618d942756b93e02340a42f3c80aa99fc56be1a96861f5464dc23a76bf30b3a5\",\"license\":\"BSD-3-Clause\"},\"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IAccessControlManagerV8 is IAccessControl {\\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\\n\\n    function revokeCallPermission(\\n        address contractAddress,\\n        string calldata functionSig,\\n        address accountToRevoke\\n    ) external;\\n\\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\\n\\n    function hasPermission(\\n        address account,\\n        address contractAddress,\\n        string calldata functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x41deef84d1839590b243b66506691fde2fb938da01eabde53e82d3b8316fdaf9\",\"license\":\"BSD-3-Clause\"},\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\ninterface OracleInterface {\\n    function getPrice(address asset) external view returns (uint256);\\n}\\n\\ninterface ResilientOracleInterface is OracleInterface {\\n    function updatePrice(address vToken) external;\\n\\n    function updateAssetPrice(address asset) external;\\n\\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\\n}\\n\\ninterface TwapInterface is OracleInterface {\\n    function updateTwap(address asset) external returns (uint256);\\n}\\n\\ninterface BoundValidatorInterface {\\n    function validatePriceWithAnchorPrice(\\n        address asset,\\n        uint256 reporterPrice,\\n        uint256 anchorPrice\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x40031b19684ca0c912e794d08c2c0b0d8be77d3c1bdc937830a0658eff899650\",\"license\":\"BSD-3-Clause\"},\"contracts/Comptroller.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { ComptrollerStorage } from \\\"./ComptrollerStorage.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"./MaxLoopsLimitHelper.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title Comptroller\\n * @author Venus\\n * @notice The Comptroller is designed to provide checks for all minting, redeeming, transferring, borrowing, lending, repaying, liquidating,\\n * and seizing done by the `vToken` contract. Each pool has one `Comptroller` checking these interactions across markets. When a user interacts\\n * with a given market by one of these main actions, a call is made to a corresponding hook in the associated `Comptroller`, which either allows\\n * or reverts the transaction. These hooks also update supply and borrow rewards as they are called. The comptroller holds the logic for assessing\\n * liquidity snapshots of an account via the collateral factor and liquidation threshold. This check determines the collateral needed for a borrow,\\n * as well as how much of a borrow may be liquidated. A user may borrow a portion of their collateral with the maximum amount determined by the\\n * markets collateral factor. However, if their borrowed amount exceeds an amount calculated using the market\\u2019s corresponding liquidation threshold,\\n * the borrow is eligible for liquidation.\\n *\\n * The `Comptroller` also includes two functions `liquidateAccount()` and `healAccount()`, which are meant to handle accounts that do not exceed\\n * the `minLiquidatableCollateral` for the `Comptroller`:\\n *\\n * - `healAccount()`: This function is called to seize all of a given user\\u2019s collateral, requiring the `msg.sender` repay a certain percentage\\n * of the debt calculated by `collateral/(borrows*liquidationIncentive)`. The function can only be called if the calculated percentage does not exceed\\n * 100%, because otherwise no `badDebt` would be created and `liquidateAccount()` should be used instead. The difference in the actual amount of debt\\n * and debt paid off is recorded as `badDebt` for each market, which can then be auctioned off for the risk reserves of the associated pool.\\n * - `liquidateAccount()`: This function can only be called if the collateral seized will cover all borrows of an account, as well as the liquidation\\n * incentive. Otherwise, the pool will incur bad debt, in which case the function `healAccount()` should be used instead. This function skips the logic\\n * verifying that the repay amount does not exceed the close factor.\\n */\\ncontract Comptroller is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    ComptrollerStorage,\\n    ComptrollerInterface,\\n    ExponentialNoError,\\n    MaxLoopsLimitHelper\\n{\\n    // PoolRegistry, immutable to save on gas\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable poolRegistry;\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\\n\\n    /// @notice Emitted when a collateral factor is changed by admin\\n    event NewCollateralFactor(VToken vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\\n\\n    /// @notice Emitted when liquidation threshold is changed by admin\\n    event NewLiquidationThreshold(\\n        VToken vToken,\\n        uint256 oldLiquidationThresholdMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    );\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\\n\\n    /// @notice Emitted when an action is paused on a market\\n    event ActionPausedMarket(VToken vToken, Action action, bool pauseState);\\n\\n    /// @notice Emitted when borrow cap for a vToken is changed\\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\\n\\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\\n    event NewMinLiquidatableCollateral(uint256 oldMinLiquidatableCollateral, uint256 newMinLiquidatableCollateral);\\n\\n    /// @notice Emitted when supply cap for a vToken is changed\\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\\n\\n    /// @notice Emitted when a rewards distributor is added\\n    event NewRewardsDistributor(address indexed rewardsDistributor, address indexed rewardToken);\\n\\n    /// @notice Emitted when a market is supported\\n    event MarketSupported(VToken vToken);\\n\\n    /// @notice Thrown when collateral factor exceeds the upper bound\\n    error InvalidCollateralFactor();\\n\\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\\n    error InvalidLiquidationThreshold();\\n\\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\\n    error UnexpectedSender(address expectedSender, address actualSender);\\n\\n    /// @notice Thrown when the oracle returns an invalid price for some asset\\n    error PriceError(address vToken);\\n\\n    /// @notice Thrown if VToken unexpectedly returned a nonzero error code while trying to get account snapshot\\n    error SnapshotError(address vToken, address user);\\n\\n    /// @notice Thrown when the market is not listed\\n    error MarketNotListed(address market);\\n\\n    /// @notice Thrown when a market has an unexpected comptroller\\n    error ComptrollerMismatch();\\n\\n    /// @notice Thrown when user is not member of market\\n    error MarketNotCollateral(address vToken, address user);\\n\\n    /**\\n     * @notice Thrown during the liquidation if user's total collateral amount is lower than\\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\\n     *   or healAccount) are available.\\n     */\\n    error MinimalCollateralViolated(uint256 expectedGreaterThan, uint256 actual);\\n    error CollateralExceedsThreshold(uint256 expectedLessThanOrEqualTo, uint256 actual);\\n    error InsufficientCollateral(uint256 collateralToSeize, uint256 availableCollateral);\\n\\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\\n    error InsufficientLiquidity();\\n\\n    /// @notice Thrown when trying to liquidate a healthy account\\n    error InsufficientShortfall();\\n\\n    /// @notice Thrown when trying to repay more than allowed by close factor\\n    error TooMuchRepay();\\n\\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\\n    error NonzeroBorrowBalance();\\n\\n    /// @notice Thrown when trying to perform an action that is paused\\n    error ActionPaused(address market, Action action);\\n\\n    /// @notice Thrown when trying to add a market that is already listed\\n    error MarketAlreadyListed(address market);\\n\\n    /// @notice Thrown if the supply cap is exceeded\\n    error SupplyCapExceeded(address market, uint256 cap);\\n\\n    /// @notice Thrown if the borrow cap is exceeded\\n    error BorrowCapExceeded(address market, uint256 cap);\\n\\n    /// @param poolRegistry_ Pool registry address\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\\n    constructor(address poolRegistry_) {\\n        ensureNonzeroAddress(poolRegistry_);\\n\\n        poolRegistry = poolRegistry_;\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\\n     * @param accessControlManager Access control manager contract address\\n     */\\n    function initialize(uint256 loopLimit, address accessControlManager) external initializer {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager);\\n\\n        _setMaxLoopsLimit(loopLimit);\\n    }\\n\\n    /**\\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\\n     * @param vTokens The list of addresses of the vToken markets to be enabled\\n     * @return errors An array of NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketEntered is emitted for each market on success\\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\\n     * @custom:access Not restricted\\n     */\\n    function enterMarkets(address[] memory vTokens) external override returns (uint256[] memory) {\\n        uint256 len = vTokens.length;\\n\\n        uint256[] memory results = new uint256[](len);\\n        for (uint256 i; i < len; ++i) {\\n            VToken vToken = VToken(vTokens[i]);\\n\\n            _addToMarket(vToken, msg.sender);\\n            results[i] = NO_ERROR;\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param vTokenAddress The address of the asset to be removed\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketExited is emitted on success\\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function exitMarket(address vTokenAddress) external override returns (uint256) {\\n        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\\n        VToken vToken = VToken(vTokenAddress);\\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);\\n\\n        /* Fail if the sender has a borrow balance */\\n        if (amountOwed != 0) {\\n            revert NonzeroBorrowBalance();\\n        }\\n\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\n        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);\\n\\n        Market storage marketToExit = markets[address(vToken)];\\n\\n        /* Return true if the sender is not already \\u2018in\\u2019 the market */\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Set vToken account membership to false */\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        /* Delete vToken from the account\\u2019s list of assets */\\n        // load into memory for faster iteration\\n        VToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint256 len = userAssetList.length;\\n\\n        uint256 assetIndex = len;\\n        for (uint256 i; i < len; ++i) {\\n            if (userAssetList[i] == vToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        VToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(vToken, msg.sender);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param vToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\\n     * @custom:access Not restricted\\n     */\\n    function preMintHook(address vToken, address minter, uint256 mintAmount) external override {\\n        _checkActionPauseState(vToken, Action.MINT);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        uint256 supplyCap = supplyCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (supplyCap != type(uint256).max) {\\n            uint256 vTokenSupply = VToken(vToken).totalSupply();\\n            Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\\n            if (nextTotalSupply > supplyCap) {\\n                revert SupplyCapExceeded(vToken, supplyCap);\\n            }\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, minter);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param vToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preRedeemHook(address vToken, address redeemer, uint256 redeemTokens) external override {\\n        _checkActionPauseState(vToken, Action.REDEEM);\\n\\n        _checkRedeemAllowed(vToken, redeemer, redeemTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, redeemer);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param vToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @custom:error ActionPaused error is thrown if borrowing is paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if there is not enough collateral to borrow\\n     * @custom:error BorrowCapExceeded is thrown if the borrow cap will be exceeded should this borrow succeed\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted if vToken is enabled as collateral, otherwise only vToken\\n     */\\n    /// disable-eslint\\n    function preBorrowHook(address vToken, address borrower, uint256 borrowAmount) external override {\\n        _checkActionPauseState(vToken, Action.BORROW);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (!markets[vToken].accountMembership[borrower]) {\\n            // only vTokens may call borrowAllowed if borrower not in market\\n            _checkSenderIs(vToken);\\n\\n            // attempt to add borrower to the market or revert\\n            _addToMarket(VToken(msg.sender), borrower);\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 borrowCap = borrowCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (borrowCap != type(uint256).max) {\\n            uint256 totalBorrows = VToken(vToken).totalBorrows();\\n            uint256 badDebt = VToken(vToken).badDebt();\\n            uint256 nextTotalBorrows = totalBorrows + borrowAmount + badDebt;\\n            if (nextTotalBorrows > borrowCap) {\\n                revert BorrowCapExceeded(vToken, borrowCap);\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            borrower,\\n            VToken(vToken),\\n            0,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param vToken The market to verify the repay against\\n     * @param borrower The account which would borrowed the asset\\n     * @custom:error ActionPaused error is thrown if repayments are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:access Not restricted\\n     */\\n    function preRepayHook(address vToken, address borrower) external override {\\n        _checkActionPauseState(vToken, Action.REPAY);\\n\\n        oracle.updatePrice(vToken);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     * @param skipLiquidityCheck Allows the borrow to be liquidated regardless of the account liquidity\\n     * @custom:error ActionPaused error is thrown if liquidations are paused in this market\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error TooMuchRepay error is thrown if the liquidator is trying to repay more than allowed by close factor\\n     * @custom:error MinimalCollateralViolated is thrown if the users' total collateral is lower than the threshold for non-batch liquidations\\n     * @custom:error InsufficientShortfall is thrown when trying to liquidate a healthy account\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     */\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.\\n        // If we want to pause liquidating to vTokenCollateral, we should pause\\n        // Action.SEIZE on it\\n        _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (!markets[vTokenBorrowed].isListed) {\\n            revert MarketNotListed(address(vTokenBorrowed));\\n        }\\n        if (!markets[vTokenCollateral].isListed) {\\n            revert MarketNotListed(address(vTokenCollateral));\\n        }\\n\\n        uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\\n\\n        /* Allow accounts to be liquidated if the market is deprecated or it is a forced liquidation */\\n        if (skipLiquidityCheck || isDeprecated(VToken(vTokenBorrowed))) {\\n            if (repayAmount > borrowBalance) {\\n                revert TooMuchRepay();\\n            }\\n            return;\\n        }\\n\\n        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral <= minLiquidatableCollateral) {\\n            /* The liquidator should use either liquidateAccount or healAccount */\\n            revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\n        uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\\n        if (repayAmount > maxClose) {\\n            revert TooMuchRepay();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param seizerContract Contract that tries to seize the asset (either borrowed vToken or Comptroller)\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools\\n     * @custom:access Not restricted\\n     */\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address seizerContract,\\n        address liquidator,\\n        address borrower\\n    ) external override {\\n        // Pause Action.SEIZE on COLLATERAL to prevent seizing it.\\n        // If we want to pause liquidating vTokenBorrowed, we should pause\\n        // Action.LIQUIDATE on it\\n        _checkActionPauseState(vTokenCollateral, Action.SEIZE);\\n\\n        Market storage market = markets[vTokenCollateral];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(vTokenCollateral);\\n        }\\n\\n        if (seizerContract == address(this)) {\\n            // If Comptroller is the seizer, just check if collateral's comptroller\\n            // is equal to the current address\\n            if (address(VToken(vTokenCollateral).comptroller()) != address(this)) {\\n                revert ComptrollerMismatch();\\n            }\\n        } else {\\n            // If the seizer is not the Comptroller, check that the seizer is a\\n            // listed market, and that the markets' comptrollers match\\n            if (!markets[seizerContract].isListed) {\\n                revert MarketNotListed(seizerContract);\\n            }\\n            if (VToken(vTokenCollateral).comptroller() != VToken(seizerContract).comptroller()) {\\n                revert ComptrollerMismatch();\\n            }\\n        }\\n\\n        if (!market.accountMembership[borrower]) {\\n            revert MarketNotCollateral(vTokenCollateral, borrower);\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vTokenCollateral);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, borrower);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, liquidator);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param vToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of vTokens to transfer\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preTransferHook(address vToken, address src, address dst, uint256 transferTokens) external override {\\n        _checkActionPauseState(vToken, Action.TRANSFER);\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        _checkRedeemAllowed(vToken, src, transferTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, src);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, dst);\\n        }\\n    }\\n\\n    /*** Pool-level operations ***/\\n\\n    /**\\n     * @notice Seizes all the remaining collateral, makes msg.sender repay the existing\\n     *   borrows, and treats the rest of the debt as bad debt (for each market).\\n     *   The sender has to repay a certain percentage of the debt, computed as\\n     *   collateral / (borrows * liquidationIncentive).\\n     * @param user account to heal\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for healing\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function healAccount(address user) external {\\n        VToken[] memory userAssets = accountAssets[user];\\n        uint256 userAssetsCount = userAssets.length;\\n\\n        address liquidator = msg.sender;\\n        {\\n            ResilientOracleInterface oracle_ = oracle;\\n            // We need all user's markets to be fresh for the computations to be correct\\n            for (uint256 i; i < userAssetsCount; ++i) {\\n                userAssets[i].accrueInterest();\\n                oracle_.updatePrice(address(userAssets[i]));\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(user, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        // percentage = collateral / (borrows * liquidation incentive)\\n        Exp memory collateral = Exp({ mantissa: snapshot.totalCollateral });\\n        Exp memory scaledBorrows = mul_(\\n            Exp({ mantissa: snapshot.borrows }),\\n            Exp({ mantissa: liquidationIncentiveMantissa })\\n        );\\n\\n        Exp memory percentage = div_(collateral, scaledBorrows);\\n        if (lessThanExp(Exp({ mantissa: MANTISSA_ONE }), percentage)) {\\n            revert CollateralExceedsThreshold(scaledBorrows.mantissa, collateral.mantissa);\\n        }\\n\\n        for (uint256 i; i < userAssetsCount; ++i) {\\n            VToken market = userAssets[i];\\n\\n            (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(market, user);\\n            uint256 repaymentAmount = mul_ScalarTruncate(percentage, borrowBalance);\\n\\n            // Seize the entire collateral\\n            if (tokens != 0) {\\n                market.seize(liquidator, user, tokens);\\n            }\\n            // Repay a certain percentage of the borrow, forgive the rest\\n            if (borrowBalance != 0) {\\n                market.healBorrow(liquidator, user, repaymentAmount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Liquidates all borrows of the borrower. Callable only if the collateral is less than\\n     *   a predefined threshold, and the account collateral can be seized to cover all borrows. If\\n     *   the collateral is higher than the threshold, use regular liquidations. If the collateral is\\n     *   below the threshold, and the account is insolvent, use healAccount.\\n     * @param borrower the borrower address\\n     * @param orders an array of liquidation orders\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for a batch liquidation\\n     * @custom:error InsufficientCollateral error is thrown when there is not enough collateral to cover the debt\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function liquidateAccount(address borrower, LiquidationOrder[] calldata orders) external {\\n        // We will accrue interest and update the oracle prices later during the liquidation\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            // You should use the regular vToken.liquidateBorrow(...) call\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        uint256 collateralToSeize = mul_ScalarTruncate(\\n            Exp({ mantissa: liquidationIncentiveMantissa }),\\n            snapshot.borrows\\n        );\\n        if (collateralToSeize >= snapshot.totalCollateral) {\\n            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow\\n            // and record bad debt.\\n            revert InsufficientCollateral(collateralToSeize, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        uint256 ordersCount = orders.length;\\n\\n        _ensureMaxLoops(ordersCount / 2);\\n\\n        for (uint256 i; i < ordersCount; ++i) {\\n            if (!markets[address(orders[i].vTokenBorrowed)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenBorrowed));\\n            }\\n            if (!markets[address(orders[i].vTokenCollateral)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenCollateral));\\n            }\\n\\n            LiquidationOrder calldata order = orders[i];\\n            order.vTokenBorrowed.forceLiquidateBorrow(\\n                msg.sender,\\n                borrower,\\n                order.repayAmount,\\n                order.vTokenCollateral,\\n                true\\n            );\\n        }\\n\\n        VToken[] memory borrowMarkets = accountAssets[borrower];\\n        uint256 marketsCount = borrowMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);\\n            require(borrowBalance == 0, \\\"Nonzero borrow balance after liquidation\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the closeFactor to use when liquidating borrows\\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n     * @custom:event Emits NewCloseFactor on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCloseFactor(uint256 newCloseFactorMantissa) external {\\n        _checkAccessAllowed(\\\"setCloseFactor(uint256)\\\");\\n        require(MAX_CLOSE_FACTOR_MANTISSA >= newCloseFactorMantissa, \\\"Close factor greater than maximum close factor\\\");\\n        require(MIN_CLOSE_FACTOR_MANTISSA <= newCloseFactorMantissa, \\\"Close factor smaller than minimum close factor\\\");\\n\\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Sets the collateralFactor for a market\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param vToken The market to set the factor on\\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\\n     * @custom:event Emits NewCollateralFactor when collateral factor is updated\\n     *    and NewLiquidationThreshold when liquidation threshold is updated\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InvalidCollateralFactor error is thrown when collateral factor is too high\\n     * @custom:error InvalidLiquidationThreshold error is thrown when liquidation threshold is lower than collateral factor\\n     * @custom:error PriceError is thrown when the oracle returns an invalid price for the asset\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCollateralFactor(\\n        VToken vToken,\\n        uint256 newCollateralFactorMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    ) external {\\n        _checkAccessAllowed(\\\"setCollateralFactor(address,uint256,uint256)\\\");\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(vToken)];\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Check collateral factor <= 0.9\\n        if (newCollateralFactorMantissa > MAX_COLLATERAL_FACTOR_MANTISSA) {\\n            revert InvalidCollateralFactor();\\n        }\\n\\n        // Ensure that liquidation threshold <= 1\\n        if (newLiquidationThresholdMantissa > MANTISSA_ONE) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // Ensure that liquidation threshold >= CF\\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\\n            emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n        }\\n\\n        uint256 oldLiquidationThresholdMantissa = market.liquidationThresholdMantissa;\\n        if (newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa) {\\n            market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\\n            emit NewLiquidationThreshold(vToken, oldLiquidationThresholdMantissa, newLiquidationThresholdMantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets liquidationIncentive\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n     * @custom:event Emits NewLiquidationIncentive on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external {\\n        require(newLiquidationIncentiveMantissa >= MANTISSA_ONE, \\\"liquidation incentive should be greater than 1e18\\\");\\n\\n        _checkAccessAllowed(\\\"setLiquidationIncentive(uint256)\\\");\\n\\n        // Save current value for use in log\\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n    }\\n\\n    /**\\n     * @notice Add the market to the markets mapping and set it as listed\\n     * @dev Only callable by the PoolRegistry\\n     * @param vToken The address of the market (token) to list\\n     * @custom:error MarketAlreadyListed is thrown if the market is already listed in this pool\\n     * @custom:access Only PoolRegistry\\n     */\\n    function supportMarket(VToken vToken) external {\\n        _checkSenderIs(poolRegistry);\\n\\n        if (markets[address(vToken)].isListed) {\\n            revert MarketAlreadyListed(address(vToken));\\n        }\\n\\n        require(vToken.isVToken(), \\\"Comptroller: Invalid vToken\\\"); // Sanity check to make sure its really a VToken\\n\\n        Market storage newMarket = markets[address(vToken)];\\n        newMarket.isListed = true;\\n        newMarket.collateralFactorMantissa = 0;\\n        newMarket.liquidationThresholdMantissa = 0;\\n\\n        _addMarket(address(vToken));\\n\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            rewardsDistributors[i].initializeMarket(address(vToken));\\n        }\\n\\n        emit MarketSupported(vToken);\\n    }\\n\\n    /**\\n     * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A borrow cap of type(uint256).max corresponds to unlimited borrowing.\\n     * @dev Borrow caps smaller than the current total borrows are accepted. This way, new borrows will not be allowed\\n            until the total borrows amount goes below the new borrow cap\\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited borrowing.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\\n        _checkAccessAllowed(\\\"setMarketBorrowCaps(address[],uint256[])\\\");\\n\\n        uint256 numMarkets = vTokens.length;\\n        uint256 numBorrowCaps = newBorrowCaps.length;\\n\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\n\\n        _ensureMaxLoops(numMarkets);\\n\\n        for (uint256 i; i < numMarkets; ++i) {\\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A supply cap of type(uint256).max corresponds to unlimited supply.\\n     * @dev Supply caps smaller than the current total supplies are accepted. This way, new supplies will not be allowed\\n            until the total supplies amount goes below the new supply cap\\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited supply.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\\n        _checkAccessAllowed(\\\"setMarketSupplyCaps(address[],uint256[])\\\");\\n        uint256 vTokensCount = vTokens.length;\\n\\n        require(vTokensCount != 0, \\\"invalid number of markets\\\");\\n        require(vTokensCount == newSupplyCaps.length, \\\"invalid number of markets\\\");\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pause/unpause specified actions\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param marketsList Markets to pause/unpause the actions on\\n     * @param actionsList List of action ids to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setActionsPaused(VToken[] calldata marketsList, Action[] calldata actionsList, bool paused) external {\\n        _checkAccessAllowed(\\\"setActionsPaused(address[],uint256[],bool)\\\");\\n\\n        uint256 marketsCount = marketsList.length;\\n        uint256 actionsCount = actionsList.length;\\n\\n        _ensureMaxLoops(marketsCount * actionsCount);\\n\\n        for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {\\n            for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) {\\n                _setActionPaused(address(marketsList[marketIdx]), actionsList[actionIdx], paused);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given collateral threshold for non-batch liquidations. Regular liquidations\\n     *   will fail if the collateral amount is less than this threshold. Liquidators should use batch\\n     *   operations like liquidateAccount or healAccount.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newMinLiquidatableCollateral The new min liquidatable collateral (in USD).\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMinLiquidatableCollateral(uint256 newMinLiquidatableCollateral) external {\\n        _checkAccessAllowed(\\\"setMinLiquidatableCollateral(uint256)\\\");\\n\\n        uint256 oldMinLiquidatableCollateral = minLiquidatableCollateral;\\n        minLiquidatableCollateral = newMinLiquidatableCollateral;\\n        emit NewMinLiquidatableCollateral(oldMinLiquidatableCollateral, newMinLiquidatableCollateral);\\n    }\\n\\n    /**\\n     * @notice Add a new RewardsDistributor and initialize it with all markets. We can add several RewardsDistributor\\n     * contracts with the same rewardToken, and there could be overlaping among them considering the last reward block\\n     * @dev Only callable by the admin\\n     * @param _rewardsDistributor Address of the RewardDistributor contract to add\\n     * @custom:access Only Governance\\n     * @custom:event Emits NewRewardsDistributor with distributor address\\n     */\\n    function addRewardsDistributor(RewardsDistributor _rewardsDistributor) external onlyOwner {\\n        require(!rewardsDistributorExists[address(_rewardsDistributor)], \\\"already exists\\\");\\n\\n        uint256 rewardsDistributorsLen = rewardsDistributors.length;\\n        _ensureMaxLoops(rewardsDistributorsLen + 1);\\n\\n        rewardsDistributors.push(_rewardsDistributor);\\n        rewardsDistributorExists[address(_rewardsDistributor)] = true;\\n\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            _rewardsDistributor.initializeMarket(address(allMarkets[i]));\\n        }\\n\\n        emit NewRewardsDistributor(address(_rewardsDistributor), address(_rewardsDistributor.rewardToken()));\\n    }\\n\\n    /**\\n     * @notice Sets a new price oracle for the Comptroller\\n     * @dev Only callable by the admin\\n     * @param newOracle Address of the new price oracle to set\\n     * @custom:event Emits NewPriceOracle on success\\n     * @custom:error ZeroAddressNotAllowed is thrown when the new oracle address is zero\\n     */\\n    function setPriceOracle(ResilientOracleInterface newOracle) external onlyOwner {\\n        ensureNonzeroAddress(address(newOracle));\\n\\n        ResilientOracleInterface oldOracle = oracle;\\n        oracle = newOracle;\\n        emit NewPriceOracle(oldOracle, newOracle);\\n    }\\n\\n    /**\\n     * @notice Set the for loop iteration limit to avoid DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to liquidation threshold requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of liquidation threshold requirements,\\n     * @return shortfall Account shortfall below liquidation threshold requirements\\n     */\\n    function getAccountLiquidity(\\n        address account\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getLiquidationThreshold);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to collateral requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of collateral requirements,\\n     * @return shortfall Account shortfall below collateral requirements\\n     */\\n    function getBorrowingPower(\\n        address account\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getCollateralFactor);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Hypothetical account liquidity in excess of collateral requirements,\\n     * @return shortfall Hypothetical account shortfall below collateral requirements\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            account,\\n            VToken(vTokenModify),\\n            redeemTokens,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Return all of the markets\\n     * @dev The automatic getter may be used to access an individual market.\\n     * @return markets The list of market addresses\\n     */\\n    function getAllMarkets() external view override returns (VToken[] memory) {\\n        return allMarkets;\\n    }\\n\\n    /**\\n     * @notice Check if a market is marked as listed (active)\\n     * @param vToken vToken Address for the market to check\\n     * @return listed True if listed otherwise false\\n     */\\n    function isMarketListed(VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].isListed;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A list with the assets the account has entered\\n     */\\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\\n        VToken[] memory assetsIn = accountAssets[account];\\n\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in a given market\\n     * @param account The address of the account to check\\n     * @param vToken The vToken to check\\n     * @return True if the account is in the market specified, otherwise false.\\n     */\\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].accountMembership[account];\\n    }\\n\\n    /**\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\\n     * @param vTokenBorrowed The address of the borrowed vToken\\n     * @param vTokenCollateral The address of the collateral vToken\\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return tokensToSeize Number of vTokenCollateral tokens to be seized in a liquidation\\n     * @custom:error PriceError if the oracle returns an invalid price\\n     */\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 actualRepayAmount\\n    ) external view override returns (uint256 error, uint256 tokensToSeize) {\\n        /* Read oracle prices for borrowed and collateral markets */\\n        uint256 priceBorrowedMantissa = _safeGetUnderlyingPrice(VToken(vTokenBorrowed));\\n        uint256 priceCollateralMantissa = _safeGetUnderlyingPrice(VToken(vTokenCollateral));\\n\\n        /*\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n         *  seizeTokens = seizeAmount / exchangeRate\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n         */\\n        uint256 exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\\n        uint256 seizeTokens;\\n        Exp memory numerator;\\n        Exp memory denominator;\\n        Exp memory ratio;\\n\\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\\n        ratio = div_(numerator, denominator);\\n\\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n\\n        return (NO_ERROR, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Returns reward speed given a vToken\\n     * @param vToken The vToken to get the reward speeds for\\n     * @return rewardSpeeds Array of total supply and borrow speeds and reward token for all reward distributors\\n     */\\n    function getRewardsByMarket(address vToken) external view returns (RewardSpeeds[] memory rewardSpeeds) {\\n        uint256 rewardsDistributorsLength = rewardsDistributors.length;\\n        rewardSpeeds = new RewardSpeeds[](rewardsDistributorsLength);\\n        for (uint256 i; i < rewardsDistributorsLength; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            address rewardToken = address(rewardsDistributor.rewardToken());\\n            rewardSpeeds[i] = RewardSpeeds({\\n                rewardToken: rewardToken,\\n                supplySpeed: rewardsDistributor.rewardTokenSupplySpeeds(vToken),\\n                borrowSpeed: rewardsDistributor.rewardTokenBorrowSpeeds(vToken)\\n            });\\n        }\\n        return rewardSpeeds;\\n    }\\n\\n    /**\\n     * @notice Return all reward distributors for this pool\\n     * @return Array of RewardDistributor addresses\\n     */\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory) {\\n        return rewardsDistributors;\\n    }\\n\\n    /**\\n     * @notice A marker method that returns true for a valid Comptroller contract\\n     * @return Always true\\n     */\\n    function isComptroller() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Update the prices of all the tokens associated with the provided account\\n     * @param account Address of the account to get associated tokens with\\n     */\\n    function updatePrices(address account) public {\\n        VToken[] memory vTokens = accountAssets[account];\\n        uint256 vTokensCount = vTokens.length;\\n\\n        ResilientOracleInterface oracle_ = oracle;\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            oracle_.updatePrice(address(vTokens[i]));\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a certain action is paused on a market\\n     * @param market vToken address\\n     * @param action Action to check\\n     * @return paused True if the action is paused otherwise false\\n     */\\n    function actionPaused(address market, Action action) public view returns (bool) {\\n        return _actionPaused[market][action];\\n    }\\n\\n    /**\\n     * @notice Check if a vToken market has been deprecated\\n     * @dev All borrows in a deprecated vToken market can be immediately liquidated\\n     * @param vToken The market to check if deprecated\\n     * @return deprecated True if the given vToken market has been deprecated\\n     */\\n    function isDeprecated(VToken vToken) public view returns (bool) {\\n        return\\n            markets[address(vToken)].collateralFactorMantissa == 0 &&\\n            actionPaused(address(vToken), Action.BORROW) &&\\n            vToken.reserveFactorMantissa() == MANTISSA_ONE;\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param vToken The market to enter\\n     * @param borrower The address of the account to modify\\n     */\\n    function _addToMarket(VToken vToken, address borrower) internal {\\n        _checkActionPauseState(address(vToken), Action.ENTER_MARKET);\\n        Market storage marketToJoin = markets[address(vToken)];\\n\\n        if (!marketToJoin.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower]) {\\n            // already joined\\n            return;\\n        }\\n\\n        // survived the gauntlet, add to list\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\n        //  this avoids having to iterate through the list for the most common use cases\\n        //  that is, only when we need to perform liquidity checks\\n        //  and not whenever we want to check if an account is in a particular market\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(vToken);\\n\\n        emit MarketEntered(vToken, borrower);\\n    }\\n\\n    /**\\n     * @notice Internal function to validate that a market hasn't already been added\\n     * and if it hasn't adds it\\n     * @param vToken The market to support\\n     */\\n    function _addMarket(address vToken) internal {\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            if (allMarkets[i] == VToken(vToken)) {\\n                revert MarketAlreadyListed(vToken);\\n            }\\n        }\\n        allMarkets.push(VToken(vToken));\\n        marketsCount = allMarkets.length;\\n        _ensureMaxLoops(marketsCount);\\n    }\\n\\n    /**\\n     * @dev Pause/unpause an action on a market\\n     * @param market Market to pause/unpause the action on\\n     * @param action Action id to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     */\\n    function _setActionPaused(address market, Action action, bool paused) internal {\\n        require(markets[market].isListed, \\\"cannot pause a market that is not listed\\\");\\n        _actionPaused[market][action] = paused;\\n        emit ActionPausedMarket(VToken(market), action, paused);\\n    }\\n\\n    /**\\n     * @dev Internal function to check that vTokens can be safely redeemed for the underlying asset.\\n     * @param vToken Address of the vTokens to redeem\\n     * @param redeemer Account redeeming the tokens\\n     * @param redeemTokens The number of tokens to redeem\\n     */\\n    function _checkRedeemAllowed(address vToken, address redeemer, uint256 redeemTokens) internal {\\n        Market storage market = markets[vToken];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!market.accountMembership[redeemer]) {\\n            return;\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(redeemer);\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            redeemer,\\n            VToken(vToken),\\n            redeemTokens,\\n            0,\\n            _getCollateralFactor\\n        );\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the total collateral, weighted collateral, borrow balance, liquidity, shortfall\\n     * @param account The account to get the snapshot for\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\n     *  liquidation threshold. Accepts the address of the vToken and returns the weight as Exp.\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getCurrentLiquiditySnapshot(\\n        address account,\\n        function(VToken) internal view returns (Exp memory) weight\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\n        return _getHypotheticalLiquiditySnapshot(account, VToken(address(0)), 0, 0, weight);\\n    }\\n\\n    /**\\n     * @notice Determine what the supply/borrow balances would be if the given amounts were redeemed/borrowed\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\n         liquidation threshold. Accepts the address of the VToken and returns the weight\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getHypotheticalLiquiditySnapshot(\\n        address account,\\n        VToken vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount,\\n        function(VToken) internal view returns (Exp memory) weight\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\n        // For each asset the account is in\\n        VToken[] memory assets = accountAssets[account];\\n        uint256 assetsCount = assets.length;\\n\\n        for (uint256 i; i < assetsCount; ++i) {\\n            VToken asset = assets[i];\\n\\n            // Read the balances and exchange rate from the vToken\\n            (uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) = _safeGetAccountSnapshot(\\n                asset,\\n                account\\n            );\\n\\n            // Get the normalized price of the asset\\n            Exp memory oraclePrice = Exp({ mantissa: _safeGetUnderlyingPrice(asset) });\\n\\n            // Pre-compute conversion factors from vTokens -> usd\\n            Exp memory vTokenPrice = mul_(Exp({ mantissa: exchangeRateMantissa }), oraclePrice);\\n            Exp memory weightedVTokenPrice = mul_(weight(asset), vTokenPrice);\\n\\n            // weightedCollateral += weightedVTokenPrice * vTokenBalance\\n            snapshot.weightedCollateral = mul_ScalarTruncateAddUInt(\\n                weightedVTokenPrice,\\n                vTokenBalance,\\n                snapshot.weightedCollateral\\n            );\\n\\n            // totalCollateral += vTokenPrice * vTokenBalance\\n            snapshot.totalCollateral = mul_ScalarTruncateAddUInt(vTokenPrice, vTokenBalance, snapshot.totalCollateral);\\n\\n            // borrows += oraclePrice * borrowBalance\\n            snapshot.borrows = mul_ScalarTruncateAddUInt(oraclePrice, borrowBalance, snapshot.borrows);\\n\\n            // Calculate effects of interacting with vTokenModify\\n            if (asset == vTokenModify) {\\n                // redeem effect\\n                // effects += tokensToDenom * redeemTokens\\n                snapshot.effects = mul_ScalarTruncateAddUInt(weightedVTokenPrice, redeemTokens, snapshot.effects);\\n\\n                // borrow effect\\n                // effects += oraclePrice * borrowAmount\\n                snapshot.effects = mul_ScalarTruncateAddUInt(oraclePrice, borrowAmount, snapshot.effects);\\n            }\\n        }\\n\\n        uint256 borrowPlusEffects = snapshot.borrows + snapshot.effects;\\n        // These are safe, as the underflow condition is checked first\\n        unchecked {\\n            if (snapshot.weightedCollateral > borrowPlusEffects) {\\n                snapshot.liquidity = snapshot.weightedCollateral - borrowPlusEffects;\\n                snapshot.shortfall = 0;\\n            } else {\\n                snapshot.liquidity = 0;\\n                snapshot.shortfall = borrowPlusEffects - snapshot.weightedCollateral;\\n            }\\n        }\\n\\n        return snapshot;\\n    }\\n\\n    /**\\n     * @dev Retrieves price from oracle for an asset and checks it is nonzero\\n     * @param asset Address for asset to query price\\n     * @return Underlying price\\n     */\\n    function _safeGetUnderlyingPrice(VToken asset) internal view returns (uint256) {\\n        uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(address(asset));\\n        if (oraclePriceMantissa == 0) {\\n            revert PriceError(address(asset));\\n        }\\n        return oraclePriceMantissa;\\n    }\\n\\n    /**\\n     * @dev Return collateral factor for a market\\n     * @param asset Address for asset\\n     * @return Collateral factor as exponential\\n     */\\n    function _getCollateralFactor(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\\n    }\\n\\n    /**\\n     * @dev Retrieves liquidation threshold for a market as an exponential\\n     * @param asset Address for asset to liquidation threshold\\n     * @return Liquidation threshold as exponential\\n     */\\n    function _getLiquidationThreshold(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].liquidationThresholdMantissa });\\n    }\\n\\n    /**\\n     * @dev Returns supply and borrow balances of user in vToken, reverts on failure\\n     * @param vToken Market to query\\n     * @param user Account address\\n     * @return vTokenBalance Balance of vTokens, the same as vToken.balanceOf(user)\\n     * @return borrowBalance Borrowed amount, including the interest\\n     * @return exchangeRateMantissa Stored exchange rate\\n     */\\n    function _safeGetAccountSnapshot(\\n        VToken vToken,\\n        address user\\n    ) internal view returns (uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) {\\n        uint256 err;\\n        (err, vTokenBalance, borrowBalance, exchangeRateMantissa) = vToken.getAccountSnapshot(user);\\n        if (err != 0) {\\n            revert SnapshotError(address(vToken), user);\\n        }\\n        return (vTokenBalance, borrowBalance, exchangeRateMantissa);\\n    }\\n\\n    /// @notice Reverts if the call is not from expectedSender\\n    /// @param expectedSender Expected transaction sender\\n    function _checkSenderIs(address expectedSender) internal view {\\n        if (msg.sender != expectedSender) {\\n            revert UnexpectedSender(expectedSender, msg.sender);\\n        }\\n    }\\n\\n    /// @notice Reverts if a certain action is paused on a market\\n    /// @param market Market to check\\n    /// @param action Action to check\\n    function _checkActionPauseState(address market, Action action) private view {\\n        if (actionPaused(market, action)) {\\n            revert ActionPaused(market, action);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xef1ca0adc3ce1ff540279d424953087771b4a07470caac99777fafd2ceea38a9\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract.\\n */\\ninterface ComptrollerInterface {\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\\n\\n    function exitMarket(address vToken) external returns (uint256);\\n\\n    /*** Policy Hooks ***/\\n\\n    function preMintHook(address vToken, address minter, uint256 mintAmount) external;\\n\\n    function preRedeemHook(address vToken, address redeemer, uint256 redeemTokens) external;\\n\\n    function preBorrowHook(address vToken, address borrower, uint256 borrowAmount) external;\\n\\n    function preRepayHook(address vToken, address borrower) external;\\n\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external;\\n\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address vTokenBorrowed,\\n        address liquidator,\\n        address borrower\\n    ) external;\\n\\n    function preTransferHook(address vToken, address src, address dst, uint256 transferTokens) external;\\n\\n    function isComptroller() external view returns (bool);\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 repayAmount\\n    ) external view returns (uint256, uint256);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n}\\n\\n/**\\n * @title ComptrollerViewInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract, including only some util view functions.\\n */\\ninterface ComptrollerViewInterface {\\n    function markets(address) external view returns (bool, uint256);\\n\\n    function oracle() external view returns (ResilientOracleInterface);\\n\\n    function getAssetsIn(address) external view returns (VToken[] memory);\\n\\n    function closeFactorMantissa() external view returns (uint256);\\n\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\n\\n    function minLiquidatableCollateral() external view returns (uint256);\\n\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n\\n    function borrowCaps(address) external view returns (uint256);\\n\\n    function supplyCaps(address) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x44c67531518072db11bf6eafe29499073724346a7855579b09a9da049742d879\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerStorage\\n * @author Venus\\n * @notice Storage layout for the `Comptroller` contract.\\n */\\ncontract ComptrollerStorage {\\n    struct LiquidationOrder {\\n        VToken vTokenCollateral;\\n        VToken vTokenBorrowed;\\n        uint256 repayAmount;\\n    }\\n\\n    struct AccountLiquiditySnapshot {\\n        uint256 totalCollateral;\\n        uint256 weightedCollateral;\\n        uint256 borrows;\\n        uint256 effects;\\n        uint256 liquidity;\\n        uint256 shortfall;\\n    }\\n\\n    struct RewardSpeeds {\\n        address rewardToken;\\n        uint256 supplySpeed;\\n        uint256 borrowSpeed;\\n    }\\n\\n    struct Market {\\n        // Whether or not this market is listed\\n        bool isListed;\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint256 collateralFactorMantissa;\\n        //  Multiplier representing the collateralization after which the borrow is eligible\\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\\n        uint256 liquidationThresholdMantissa;\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n    }\\n\\n    enum Action {\\n        MINT,\\n        REDEEM,\\n        BORROW,\\n        REPAY,\\n        SEIZE,\\n        LIQUIDATE,\\n        TRANSFER,\\n        ENTER_MARKET,\\n        EXIT_MARKET\\n    }\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    ResilientOracleInterface public oracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint256 public closeFactorMantissa;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\"\\n     */\\n    mapping(address => VToken[]) public accountAssets;\\n\\n    /**\\n     * @notice Official mapping of vTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n    /// @notice A list of all markets\\n    VToken[] public allMarkets;\\n\\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which restricts borrowing.\\n    mapping(address => uint256) public borrowCaps;\\n\\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\\n    uint256 public minLiquidatableCollateral;\\n\\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting not allowed\\n    mapping(address => uint256) public supplyCaps;\\n\\n    /// @notice True if a certain action is paused on a certain market\\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\\n\\n    // List of Reward Distributors added\\n    RewardsDistributor[] internal rewardsDistributors;\\n\\n    // Used to check if rewards distributor is added\\n    mapping(address => bool) internal rewardsDistributorExists;\\n\\n    uint256 internal constant NO_ERROR = 0;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint256 internal constant MIN_CLOSE_FACTOR_MANTISSA = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint256 internal constant MAX_CLOSE_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    // No collateralFactorMantissa may exceed this value\\n    uint256 internal constant MAX_COLLATERAL_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x23a035905b74bfbc8840b76690490a67b8861b2025f109fb5ac9fac13be909d3\",\"license\":\"BSD-3-Clause\"},\"contracts/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title TokenErrorReporter\\n * @author Venus\\n * @notice Errors that can be thrown by the `VToken` contract.\\n */\\ncontract TokenErrorReporter {\\n    uint256 public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferNotAllowed();\\n\\n    error MintFreshnessCheck();\\n\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowFreshnessCheck();\\n\\n    error HealBorrowUnauthorized();\\n    error ForceLiquidateBorrowUnauthorized();\\n\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error ProtocolSeizeShareTooBig();\\n\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelFreshCheck();\\n}\\n\",\"keccak256\":\"0x3f8ec4e18bca1fdf8619966f4f6e095e205517a78f8c741b87fe82125754f96f\",\"license\":\"BSD-3-Clause\"},\"contracts/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { EXP_SCALE as EXP_SCALE_, MANTISSA_ONE as MANTISSA_ONE_ } from \\\"./lib/constants.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    struct Double {\\n        uint256 mantissa;\\n    }\\n\\n    uint256 internal constant EXP_SCALE = EXP_SCALE_;\\n    uint256 internal constant DOUBLE_SCALE = 1e36;\\n    uint256 internal constant HALF_EXP_SCALE = EXP_SCALE / 2;\\n    uint256 internal constant MANTISSA_ONE = MANTISSA_ONE_;\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * EXP_SCALE}) = 15\\n     */\\n    function truncate(Exp memory exp) internal pure returns (uint256) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / EXP_SCALE;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint256 scalar, uint256 addend) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n        require(n <= type(uint224).max, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / EXP_SCALE });\\n    }\\n\\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / DOUBLE_SCALE });\\n    }\\n\\n    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / DOUBLE_SCALE;\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(mul_(a.mantissa, EXP_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a.mantissa, DOUBLE_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, DOUBLE_SCALE), b.mantissa);\\n    }\\n\\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a, DOUBLE_SCALE), b) });\\n    }\\n}\\n\",\"keccak256\":\"0x1f17b8e3fdd89657d488250140f6d6abeb04f2b822467139687487f9c1dbe397\",\"license\":\"BSD-3-Clause\"},\"contracts/IPancakeswapV2Router.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\ninterface IPancakeswapV2Router {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\",\"keccak256\":\"0x7e4d140bd2a5671389ad7a3975b65d05a4f750daf6a61c16139d123d9782b96e\",\"license\":\"BSD-3-Clause\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title Compound's InterestRateModel Interface\\n * @author Compound\\n */\\nabstract contract InterestRateModel {\\n    /**\\n     * @notice Calculates the current borrow interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getBorrowRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Calculates the current supply interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param reserveFactorMantissa The current reserve factor the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getSupplyRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 reserveFactorMantissa,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\\n     * @return Always true\\n     */\\n    function isInterestRateModel() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x60ea8b0b70165acc3cf0f1e92f8dcea93ef5ddc2b8b99172799594aeec7c22b5\",\"license\":\"BSD-3-Clause\"},\"contracts/MaxLoopsLimitHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title MaxLoopsLimitHelper\\n * @author Venus\\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\\n */\\nabstract contract MaxLoopsLimitHelper {\\n    // Limit for the loops to avoid the DOS\\n    uint256 public maxLoopsLimit;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when max loops limit is set\\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\\n\\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function _setMaxLoopsLimit(uint256 limit) internal {\\n        require(limit > maxLoopsLimit, \\\"Comptroller: Invalid maxLoopsLimit\\\");\\n\\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\\n        maxLoopsLimit = limit;\\n\\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\\n    }\\n\\n    /**\\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\\n     * @param len Length of the loops iterate\\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\\n     */\\n    function _ensureMaxLoops(uint256 len) internal view {\\n        if (len > maxLoopsLimit) {\\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98c97af128677629375ca93e8d8ca3f337a4abf9304a0a4ddaea9d96cc554c3b\",\"license\":\"BSD-3-Clause\"},\"contracts/Pool/PoolRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { PoolRegistryInterface } from \\\"./PoolRegistryInterface.sol\\\";\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"../lib/validators.sol\\\";\\n\\n/**\\n * @title PoolRegistry\\n * @author Venus\\n * @notice The Isolated Pools architecture centers around the `PoolRegistry` contract. The `PoolRegistry` maintains a directory of isolated lending\\n * pools and can perform actions like creating and registering new pools, adding new markets to existing pools, setting and updating the pool's required\\n * metadata, and providing the getter methods to get information on the pools.\\n *\\n * Isolated lending has three main components: PoolRegistry, pools, and markets. The PoolRegistry is responsible for managing pools.\\n * It can create new pools, update pool metadata and manage markets within pools. PoolRegistry contains getter methods to get the details of\\n * any existing pool like `getVTokenForAsset` and `getPoolsSupportedByAsset`. It also contains methods for updating pool metadata (`updatePoolMetadata`)\\n * and setting pool name (`setPoolName`).\\n *\\n * The directory of pools is managed through two mappings: `_poolByComptroller` which is a hashmap with the comptroller address as the key and `VenusPool` as\\n * the value and `_poolsByID` which is an array of comptroller addresses. Individual pools can be accessed by calling `getPoolByComptroller` with the pool's\\n * comptroller address. `_poolsByID` is used to iterate through all of the pools.\\n *\\n * PoolRegistry also contains a map of asset addresses called `_supportedPools` that maps to an array of assets suppored by each pool. This array of pools by\\n * asset is retrieved by calling `getPoolsSupportedByAsset`.\\n *\\n * PoolRegistry registers new isolated pools in the directory with the `createRegistryPool` method. Isolated pools are composed of independent markets with\\n * specific assets and custom risk management configurations according to their markets.\\n */\\ncontract PoolRegistry is Ownable2StepUpgradeable, AccessControlledV8, PoolRegistryInterface {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    struct AddMarketInput {\\n        VToken vToken;\\n        uint256 collateralFactor;\\n        uint256 liquidationThreshold;\\n        uint256 initialSupply;\\n        address vTokenReceiver;\\n        uint256 supplyCap;\\n        uint256 borrowCap;\\n    }\\n\\n    uint256 internal constant MAX_POOL_NAME_LENGTH = 100;\\n\\n    /**\\n     * @notice Maps pool's comptroller address to metadata.\\n     */\\n    mapping(address => VenusPoolMetaData) public metadata;\\n\\n    /**\\n     * @dev Maps pool ID to pool's comptroller address\\n     */\\n    mapping(uint256 => address) private _poolsByID;\\n\\n    /**\\n     * @dev Total number of pools created.\\n     */\\n    uint256 private _numberOfPools;\\n\\n    /**\\n     * @dev Maps comptroller address to Venus pool Index.\\n     */\\n    mapping(address => VenusPool) private _poolByComptroller;\\n\\n    /**\\n     * @dev Maps pool's comptroller address to asset to vToken.\\n     */\\n    mapping(address => mapping(address => address)) private _vTokens;\\n\\n    /**\\n     * @dev Maps asset to list of supported pools.\\n     */\\n    mapping(address => address[]) private _supportedPools;\\n\\n    /**\\n     * @notice Emitted when a new Venus pool is added to the directory.\\n     */\\n    event PoolRegistered(address indexed comptroller, VenusPool pool);\\n\\n    /**\\n     * @notice Emitted when a pool name is set.\\n     */\\n    event PoolNameSet(address indexed comptroller, string oldName, string newName);\\n\\n    /**\\n     * @notice Emitted when a pool metadata is updated.\\n     */\\n    event PoolMetadataUpdated(\\n        address indexed comptroller,\\n        VenusPoolMetaData oldMetadata,\\n        VenusPoolMetaData newMetadata\\n    );\\n\\n    /**\\n     * @notice Emitted when a Market is added to the pool.\\n     */\\n    event MarketAdded(address indexed comptroller, address indexed vTokenAddress);\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\n        // to set the state variables.\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initializes the deployer to owner\\n     * @param accessControlManager_ AccessControlManager contract address\\n     */\\n    function initialize(address accessControlManager_) external initializer {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Adds a new Venus pool to the directory\\n     * @dev Price oracle must be configured before adding a pool\\n     * @param name The name of the pool\\n     * @param comptroller Pool's Comptroller contract\\n     * @param closeFactor The pool's close factor (scaled by 1e18)\\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18)\\n     * @param minLiquidatableCollateral Minimal collateral for regular (non-batch) liquidations flow\\n     * @return index The index of the registered Venus pool\\n     * @custom:error ZeroAddressNotAllowed is thrown when Comptroller address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when price oracle address is zero\\n     */\\n    function addPool(\\n        string calldata name,\\n        Comptroller comptroller,\\n        uint256 closeFactor,\\n        uint256 liquidationIncentive,\\n        uint256 minLiquidatableCollateral\\n    ) external virtual returns (uint256 index) {\\n        _checkAccessAllowed(\\\"addPool(string,address,uint256,uint256,uint256)\\\");\\n        // Input validation\\n        ensureNonzeroAddress(address(comptroller));\\n        ensureNonzeroAddress(address(comptroller.oracle()));\\n\\n        uint256 poolId = _registerPool(name, address(comptroller));\\n\\n        // Set Venus pool parameters\\n        comptroller.setCloseFactor(closeFactor);\\n        comptroller.setLiquidationIncentive(liquidationIncentive);\\n        comptroller.setMinLiquidatableCollateral(minLiquidatableCollateral);\\n\\n        return poolId;\\n    }\\n\\n    /**\\n     * @notice Add a market to an existing pool and then mint to provide initial supply\\n     * @param input The structure describing the parameters for adding a market to a pool\\n     * @custom:error ZeroAddressNotAllowed is thrown when vToken address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when vTokenReceiver address is zero\\n     */\\n    function addMarket(AddMarketInput memory input) external {\\n        _checkAccessAllowed(\\\"addMarket(AddMarketInput)\\\");\\n        ensureNonzeroAddress(address(input.vToken));\\n        ensureNonzeroAddress(input.vTokenReceiver);\\n        require(input.initialSupply > 0, \\\"PoolRegistry: initialSupply is zero\\\");\\n\\n        VToken vToken = input.vToken;\\n        address vTokenAddress = address(vToken);\\n        address comptrollerAddress = address(vToken.comptroller());\\n        Comptroller comptroller = Comptroller(comptrollerAddress);\\n        address underlyingAddress = vToken.underlying();\\n        IERC20Upgradeable underlying = IERC20Upgradeable(underlyingAddress);\\n\\n        require(_poolByComptroller[comptrollerAddress].creator != address(0), \\\"PoolRegistry: Pool not registered\\\");\\n        // solhint-disable-next-line reason-string\\n        require(\\n            _vTokens[comptrollerAddress][underlyingAddress] == address(0),\\n            \\\"PoolRegistry: Market already added for asset comptroller combination\\\"\\n        );\\n\\n        comptroller.supportMarket(vToken);\\n        comptroller.setCollateralFactor(vToken, input.collateralFactor, input.liquidationThreshold);\\n\\n        uint256[] memory newSupplyCaps = new uint256[](1);\\n        uint256[] memory newBorrowCaps = new uint256[](1);\\n        VToken[] memory vTokens = new VToken[](1);\\n\\n        newSupplyCaps[0] = input.supplyCap;\\n        newBorrowCaps[0] = input.borrowCap;\\n        vTokens[0] = vToken;\\n\\n        comptroller.setMarketSupplyCaps(vTokens, newSupplyCaps);\\n        comptroller.setMarketBorrowCaps(vTokens, newBorrowCaps);\\n\\n        _vTokens[comptrollerAddress][underlyingAddress] = vTokenAddress;\\n        _supportedPools[underlyingAddress].push(comptrollerAddress);\\n\\n        uint256 amountToSupply = _transferIn(underlying, msg.sender, input.initialSupply);\\n        underlying.approve(vTokenAddress, 0);\\n        underlying.approve(vTokenAddress, amountToSupply);\\n        vToken.mintBehalf(input.vTokenReceiver, amountToSupply);\\n\\n        emit MarketAdded(comptrollerAddress, vTokenAddress);\\n    }\\n\\n    /**\\n     * @notice Modify existing Venus pool name\\n     * @param comptroller Pool's Comptroller\\n     * @param name New pool name\\n     */\\n    function setPoolName(address comptroller, string calldata name) external {\\n        _checkAccessAllowed(\\\"setPoolName(address,string)\\\");\\n        _ensureValidName(name);\\n        VenusPool storage pool = _poolByComptroller[comptroller];\\n        string memory oldName = pool.name;\\n        pool.name = name;\\n        emit PoolNameSet(comptroller, oldName, name);\\n    }\\n\\n    /**\\n     * @notice Update metadata of an existing pool\\n     * @param comptroller Pool's Comptroller\\n     * @param metadata_ New pool metadata\\n     */\\n    function updatePoolMetadata(address comptroller, VenusPoolMetaData calldata metadata_) external {\\n        _checkAccessAllowed(\\\"updatePoolMetadata(address,VenusPoolMetaData)\\\");\\n        VenusPoolMetaData memory oldMetadata = metadata[comptroller];\\n        metadata[comptroller] = metadata_;\\n        emit PoolMetadataUpdated(comptroller, oldMetadata, metadata_);\\n    }\\n\\n    /**\\n     * @notice Returns arrays of all Venus pools' data\\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive\\n     * @return A list of all pools within PoolRegistry, with details for each pool\\n     */\\n    function getAllPools() external view override returns (VenusPool[] memory) {\\n        uint256 numberOfPools_ = _numberOfPools; // storage load to save gas\\n        VenusPool[] memory _pools = new VenusPool[](numberOfPools_);\\n        for (uint256 i = 1; i <= numberOfPools_; ++i) {\\n            address comptroller = _poolsByID[i];\\n            _pools[i - 1] = (_poolByComptroller[comptroller]);\\n        }\\n        return _pools;\\n    }\\n\\n    /**\\n     * @param comptroller The comptroller proxy address associated to the pool\\n     * @return  Returns Venus pool\\n     */\\n    function getPoolByComptroller(address comptroller) external view override returns (VenusPool memory) {\\n        return _poolByComptroller[comptroller];\\n    }\\n\\n    /**\\n     * @param comptroller comptroller of Venus pool\\n     * @return Returns Metadata of Venus pool\\n     */\\n    function getVenusPoolMetadata(address comptroller) external view override returns (VenusPoolMetaData memory) {\\n        return metadata[comptroller];\\n    }\\n\\n    function getVTokenForAsset(address comptroller, address asset) external view override returns (address) {\\n        return _vTokens[comptroller][asset];\\n    }\\n\\n    function getPoolsSupportedByAsset(address asset) external view override returns (address[] memory) {\\n        return _supportedPools[asset];\\n    }\\n\\n    /**\\n     * @dev Adds a new Venus pool to the directory (without checking msg.sender).\\n     * @param name The name of the pool\\n     * @param comptroller The pool's Comptroller proxy contract address\\n     * @return The index of the registered Venus pool\\n     */\\n    function _registerPool(string calldata name, address comptroller) internal returns (uint256) {\\n        VenusPool storage storedPool = _poolByComptroller[comptroller];\\n\\n        require(storedPool.creator == address(0), \\\"PoolRegistry: Pool already exists in the directory.\\\");\\n        _ensureValidName(name);\\n\\n        ++_numberOfPools;\\n        uint256 numberOfPools_ = _numberOfPools; // cache on stack to save storage read gas\\n\\n        VenusPool memory pool = VenusPool(name, msg.sender, comptroller, block.number, block.timestamp);\\n\\n        _poolsByID[numberOfPools_] = comptroller;\\n        _poolByComptroller[comptroller] = pool;\\n\\n        emit PoolRegistered(comptroller, pool);\\n        return numberOfPools_;\\n    }\\n\\n    function _transferIn(IERC20Upgradeable token, address from, uint256 amount) internal returns (uint256) {\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n        token.safeTransferFrom(from, address(this), amount);\\n        uint256 balanceAfter = token.balanceOf(address(this));\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    function _ensureValidName(string calldata name) internal pure {\\n        require(bytes(name).length <= MAX_POOL_NAME_LENGTH, \\\"Pool's name is too large\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x425c5d620fab58b88132a2b00a5d20789fae4f79bd7795d00861be7b3625d4dc\",\"license\":\"BSD-3-Clause\"},\"contracts/Pool/PoolRegistryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title PoolRegistryInterface\\n * @author Venus\\n * @notice Interface implemented by `PoolRegistry`.\\n */\\ninterface PoolRegistryInterface {\\n    /**\\n     * @notice Struct for a Venus interest rate pool.\\n     */\\n    struct VenusPool {\\n        string name;\\n        address creator;\\n        address comptroller;\\n        uint256 blockPosted;\\n        uint256 timestampPosted;\\n    }\\n\\n    /**\\n     * @notice Struct for a Venus interest rate pool metadata.\\n     */\\n    struct VenusPoolMetaData {\\n        string category;\\n        string logoURL;\\n        string description;\\n    }\\n\\n    /// @notice Get all pools in PoolRegistry\\n    function getAllPools() external view returns (VenusPool[] memory);\\n\\n    /// @notice Get a pool by comptroller address\\n    function getPoolByComptroller(address comptroller) external view returns (VenusPool memory);\\n\\n    /// @notice Get the address of the VToken contract in the Pool where the underlying token is the provided asset\\n    function getVTokenForAsset(address comptroller, address asset) external view returns (address);\\n\\n    /// @notice Get the addresss of the Pools supported that include a market for the provided asset\\n    function getPoolsSupportedByAsset(address asset) external view returns (address[] memory);\\n\\n    /// @notice Get the metadata of a Pool by comptroller address\\n    function getVenusPoolMetadata(address comptroller) external view returns (VenusPoolMetaData memory);\\n}\\n\",\"keccak256\":\"0x7e8ccd190ef019a3f8c3fcb67ed3eadd7bed32b263f88566870d138cd95ae312\",\"license\":\"BSD-3-Clause\"},\"contracts/Rewards/RewardsDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"../MaxLoopsLimitHelper.sol\\\";\\n\\n/**\\n * @title `RewardsDistributor`\\n * @author Venus\\n * @notice Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol.\\n * Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward\\n * token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool.\\n * Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward\\n * token to be released each block for borrowers and suppliers, which is distributed based on a user\\u2019s percentage of the borrows or supplies\\n * respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting\\n * their contributor reward token speed, which similarly allocates a fixed amount of reward token per block.\\n *\\n * The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed\\n * automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized\\n * entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.\\n */\\ncontract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, AccessControlledV8, MaxLoopsLimitHelper {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    struct RewardToken {\\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\\n        uint224 index;\\n        // The block number the index was last updated at\\n        uint32 block;\\n        // The block number at which to stop rewards\\n        uint32 lastRewardingBlock;\\n    }\\n\\n    /// @notice The initial REWARD TOKEN index for a market\\n    uint224 public constant INITIAL_INDEX = 1e36;\\n\\n    /// @notice The REWARD TOKEN market supply state for each market\\n    mapping(address => RewardToken) public rewardTokenSupplyState;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenSupplierIndex;\\n\\n    /// @notice The REWARD TOKEN accrued but not yet transferred to each user\\n    mapping(address => uint256) public rewardTokenAccrued;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding borrow market (per block)\\n    mapping(address => uint256) public rewardTokenBorrowSpeeds;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding supply market (per block)\\n    mapping(address => uint256) public rewardTokenSupplySpeeds;\\n\\n    /// @notice The REWARD TOKEN market borrow state for each market\\n    mapping(address => RewardToken) public rewardTokenBorrowState;\\n\\n    /// @notice The portion of REWARD TOKEN that each contributor receives per block\\n    mapping(address => uint256) public rewardTokenContributorSpeeds;\\n\\n    /// @notice Last block at which a contributor's REWARD TOKEN rewards have been allocated\\n    mapping(address => uint256) public lastContributorBlock;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenBorrowerIndex;\\n\\n    Comptroller private comptroller;\\n\\n    IERC20Upgradeable public rewardToken;\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a supplier\\n    event DistributedSupplierRewardToken(\\n        VToken indexed vToken,\\n        address indexed supplier,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenSupplyIndex\\n    );\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a borrower\\n    event DistributedBorrowerRewardToken(\\n        VToken indexed vToken,\\n        address indexed borrower,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenBorrowIndex\\n    );\\n\\n    /// @notice Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when REWARD TOKEN is granted by admin\\n    event RewardTokenGranted(address indexed recipient, uint256 amount);\\n\\n    /// @notice Emitted when a new REWARD TOKEN speed is set for a contributor\\n    event ContributorRewardTokenSpeedUpdated(address indexed contributor, uint256 newSpeed);\\n\\n    /// @notice Emitted when a market is initialized\\n    event MarketInitialized(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token supply index is updated\\n    event RewardTokenSupplyIndexUpdated(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token borrow index is updated\\n    event RewardTokenBorrowIndexUpdated(address indexed vToken, Exp marketBorrowIndex);\\n\\n    /// @notice Emitted when a reward for contributor is updated\\n    event ContributorRewardsUpdated(address indexed contributor, uint256 rewardAccrued);\\n\\n    /// @notice Emitted when a reward token last rewarding block for supply is updated\\n    event SupplyLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    /// @notice Emitted when a reward token last rewarding block for borrow is updated\\n    event BorrowLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    modifier onlyComptroller() {\\n        require(address(comptroller) == msg.sender, \\\"Only comptroller can call this function\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice RewardsDistributor initializer\\n     * @dev Initializes the deployer to owner\\n     * @param comptroller_ Comptroller to attach the reward distributor to\\n     * @param rewardToken_ Reward token to distribute\\n     * @param loopsLimit_ Maximum number of iterations for the loops in this contract\\n     * @param accessControlManager_ AccessControlManager contract address\\n     */\\n    function initialize(\\n        Comptroller comptroller_,\\n        IERC20Upgradeable rewardToken_,\\n        uint256 loopsLimit_,\\n        address accessControlManager_\\n    ) external initializer {\\n        comptroller = comptroller_;\\n        rewardToken = rewardToken_;\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n\\n        _setMaxLoopsLimit(loopsLimit_);\\n    }\\n\\n    function initializeMarket(address vToken) external onlyComptroller {\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n\\n        /*\\n         * Update market state indices\\n         */\\n        if (supplyState.index == 0) {\\n            // Initialize supply state index with default value\\n            supplyState.index = INITIAL_INDEX;\\n        }\\n\\n        if (borrowState.index == 0) {\\n            // Initialize borrow state index with default value\\n            borrowState.index = INITIAL_INDEX;\\n        }\\n\\n        /*\\n         * Update market state block numbers\\n         */\\n        supplyState.block = borrowState.block = blockNumber;\\n\\n        emit MarketInitialized(vToken);\\n    }\\n\\n    /*** Reward Token Distribution ***/\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them\\n     *         Borrowers will begin to accrue after the first interaction with the protocol.\\n     * @dev This function should only be called when the user has a borrow position in the market\\n     *      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)\\n     *      We avoid an external call to check if they are in the market to save gas because this function is called in many places\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function distributeBorrowerRewardToken(\\n        address vToken,\\n        address borrower,\\n        Exp memory marketBorrowIndex\\n    ) external onlyComptroller {\\n        _distributeBorrowerRewardToken(vToken, borrower, marketBorrowIndex);\\n    }\\n\\n    function updateRewardTokenSupplyIndex(address vToken) external onlyComptroller {\\n        _updateRewardTokenSupplyIndex(vToken);\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the recipient\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all\\n     * @param recipient The address of the recipient to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     */\\n    function grantRewardToken(address recipient, uint256 amount) external onlyOwner {\\n        uint256 amountLeft = _grantRewardToken(recipient, amount);\\n        require(amountLeft == 0, \\\"insufficient rewardToken for grant\\\");\\n        emit RewardTokenGranted(recipient, amount);\\n    }\\n\\n    function updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) external onlyComptroller {\\n        _updateRewardTokenBorrowIndex(vToken, marketBorrowIndex);\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN borrow and supply speeds for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN speed to update\\n     * @param supplySpeeds New supply-side REWARD TOKEN speed for the corresponding market\\n     * @param borrowSpeeds New borrow-side REWARD TOKEN speed for the corresponding market\\n     */\\n    function setRewardTokenSpeeds(\\n        VToken[] memory vTokens,\\n        uint256[] memory supplySpeeds,\\n        uint256[] memory borrowSpeeds\\n    ) external {\\n        _checkAccessAllowed(\\\"setRewardTokenSpeeds(address[],uint256[],uint256[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \\\"invalid setRewardTokenSpeeds\\\");\\n\\n        for (uint256 i; i < numTokens; ++i) {\\n            _setRewardTokenSpeed(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN last rewarding block to update\\n     * @param supplyLastRewardingBlocks New supply-side REWARD TOKEN last rewarding block for the corresponding market\\n     * @param borrowLastRewardingBlocks New borrow-side REWARD TOKEN last rewarding block for the corresponding market\\n     */\\n    function setLastRewardingBlocks(\\n        VToken[] calldata vTokens,\\n        uint32[] calldata supplyLastRewardingBlocks,\\n        uint32[] calldata borrowLastRewardingBlocks\\n    ) external {\\n        _checkAccessAllowed(\\\"setLastRewardingBlock(address[],uint32[],uint32[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(\\n            numTokens == supplyLastRewardingBlocks.length && numTokens == borrowLastRewardingBlocks.length,\\n            \\\"RewardsDistributor::setLastRewardingBlocks invalid input\\\"\\n        );\\n\\n        for (uint256 i; i < numTokens; ) {\\n            _setLastRewardingBlock(vTokens[i], supplyLastRewardingBlocks[i], borrowLastRewardingBlocks[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single contributor\\n     * @param contributor The contributor whose REWARD TOKEN speed to update\\n     * @param rewardTokenSpeed New REWARD TOKEN speed for contributor\\n     */\\n    function setContributorRewardTokenSpeed(address contributor, uint256 rewardTokenSpeed) external onlyOwner {\\n        // note that REWARD TOKEN speed could be set to 0 to halt liquidity rewards for a contributor\\n        updateContributorRewards(contributor);\\n        if (rewardTokenSpeed == 0) {\\n            // release storage\\n            delete lastContributorBlock[contributor];\\n        } else {\\n            lastContributorBlock[contributor] = getBlockNumber();\\n        }\\n        rewardTokenContributorSpeeds[contributor] = rewardTokenSpeed;\\n\\n        emit ContributorRewardTokenSpeedUpdated(contributor, rewardTokenSpeed);\\n    }\\n\\n    function distributeSupplierRewardToken(address vToken, address supplier) external onlyComptroller {\\n        _distributeSupplierRewardToken(vToken, supplier);\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in all markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     */\\n    function claimRewardToken(address holder) external {\\n        return claimRewardToken(holder, comptroller.getAllMarkets());\\n    }\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Calculate additional accrued REWARD TOKEN for a contributor since last accrual\\n     * @param contributor The address to calculate contributor rewards for\\n     */\\n    function updateContributorRewards(address contributor) public {\\n        uint256 rewardTokenSpeed = rewardTokenContributorSpeeds[contributor];\\n        uint256 blockNumber = getBlockNumber();\\n        uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\n        if (deltaBlocks > 0 && rewardTokenSpeed > 0) {\\n            uint256 newAccrued = mul_(deltaBlocks, rewardTokenSpeed);\\n            uint256 contributorAccrued = add_(rewardTokenAccrued[contributor], newAccrued);\\n\\n            rewardTokenAccrued[contributor] = contributorAccrued;\\n            lastContributorBlock[contributor] = blockNumber;\\n\\n            emit ContributorRewardsUpdated(contributor, rewardTokenAccrued[contributor]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in the specified markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     * @param vTokens The list of markets to claim REWARD TOKEN in\\n     */\\n    function claimRewardToken(address holder, VToken[] memory vTokens) public {\\n        uint256 vTokensCount = vTokens.length;\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            VToken vToken = vTokens[i];\\n            require(comptroller.isMarketListed(vToken), \\\"market must be listed\\\");\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n            _distributeBorrowerRewardToken(address(vToken), holder, borrowIndex);\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n            _distributeSupplierRewardToken(address(vToken), holder);\\n        }\\n        rewardTokenAccrued[holder] = _grantRewardToken(holder, rewardTokenAccrued[holder]);\\n    }\\n\\n    function getBlockNumber() public view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for a single market.\\n     * @param vToken market's whose reward token last rewarding block to be updated\\n     * @param supplyLastRewardingBlock New supply-side REWARD TOKEN last rewarding block for market\\n     * @param borrowLastRewardingBlock New borrow-side REWARD TOKEN last rewarding block for market\\n     */\\n    function _setLastRewardingBlock(\\n        VToken vToken,\\n        uint32 supplyLastRewardingBlock,\\n        uint32 borrowLastRewardingBlock\\n    ) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        uint256 blockNumber = getBlockNumber();\\n\\n        require(supplyLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n        require(borrowLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n\\n        uint32 currentSupplyLastRewardingBlock = rewardTokenSupplyState[address(vToken)].lastRewardingBlock;\\n        uint32 currentBorrowLastRewardingBlock = rewardTokenBorrowState[address(vToken)].lastRewardingBlock;\\n\\n        require(\\n            currentSupplyLastRewardingBlock == 0 || currentSupplyLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n        require(\\n            currentBorrowLastRewardingBlock == 0 || currentBorrowLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n\\n        if (currentSupplyLastRewardingBlock != supplyLastRewardingBlock) {\\n            rewardTokenSupplyState[address(vToken)].lastRewardingBlock = supplyLastRewardingBlock;\\n            emit SupplyLastRewardingBlockUpdated(address(vToken), supplyLastRewardingBlock);\\n        }\\n\\n        if (currentBorrowLastRewardingBlock != borrowLastRewardingBlock) {\\n            rewardTokenBorrowState[address(vToken)].lastRewardingBlock = borrowLastRewardingBlock;\\n            emit BorrowLastRewardingBlockUpdated(address(vToken), borrowLastRewardingBlock);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single market.\\n     * @param vToken market's whose reward token rate to be updated\\n     * @param supplySpeed New supply-side REWARD TOKEN speed for market\\n     * @param borrowSpeed New borrow-side REWARD TOKEN speed for market\\n     */\\n    function _setRewardTokenSpeed(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        if (rewardTokenSupplySpeeds[address(vToken)] != supplySpeed) {\\n            // Supply speed updated so let's update supply state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n\\n            // Update speed and emit event\\n            rewardTokenSupplySpeeds[address(vToken)] = supplySpeed;\\n            emit RewardTokenSupplySpeedUpdated(vToken, supplySpeed);\\n        }\\n\\n        if (rewardTokenBorrowSpeeds[address(vToken)] != borrowSpeed) {\\n            // Borrow speed updated so let's update borrow state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n\\n            // Update speed and emit event\\n            rewardTokenBorrowSpeeds[address(vToken)] = borrowSpeed;\\n            emit RewardTokenBorrowSpeedUpdated(vToken, borrowSpeed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate REWARD TOKEN accrued by a supplier and possibly transfer it to them.\\n     * @param vToken The market in which the supplier is interacting\\n     * @param supplier The address of the supplier to distribute REWARD TOKEN to\\n     */\\n    function _distributeSupplierRewardToken(address vToken, address supplier) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplyIndex = supplyState.index;\\n        uint256 supplierIndex = rewardTokenSupplierIndex[vToken][supplier];\\n\\n        // Update supplier's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenSupplierIndex[vToken][supplier] = supplyIndex;\\n\\n        if (supplierIndex == 0 && supplyIndex >= INITIAL_INDEX) {\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\\n            // set for the market.\\n            supplierIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per vToken accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\\n\\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerVToken\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\n\\n        uint256 supplierAccrued = add_(rewardTokenAccrued[supplier], supplierDelta);\\n        rewardTokenAccrued[supplier] = supplierAccrued;\\n\\n        emit DistributedSupplierRewardToken(VToken(vToken), supplier, supplierDelta, supplierAccrued, supplyIndex);\\n    }\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them.\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function _distributeBorrowerRewardToken(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowIndex = borrowState.index;\\n        uint256 borrowerIndex = rewardTokenBorrowerIndex[vToken][borrower];\\n\\n        // Update borrowers's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenBorrowerIndex[vToken][borrower] = borrowIndex;\\n\\n        if (borrowerIndex == 0 && borrowIndex >= INITIAL_INDEX) {\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\\n            // set for the market.\\n            borrowerIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per borrowed unit accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\\n\\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerBorrowedUnit\\n        if (borrowerAmount != 0) {\\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n\\n            uint256 borrowerAccrued = add_(rewardTokenAccrued[borrower], borrowerDelta);\\n            rewardTokenAccrued[borrower] = borrowerAccrued;\\n\\n            emit DistributedBorrowerRewardToken(VToken(vToken), borrower, borrowerDelta, borrowerAccrued, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the user.\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\\n     * @param user The address of the user to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     * @return The amount of REWARD TOKEN which was NOT transferred to the user\\n     */\\n    function _grantRewardToken(address user, uint256 amount) internal returns (uint256) {\\n        uint256 rewardTokenRemaining = rewardToken.balanceOf(address(this));\\n        if (amount > 0 && amount <= rewardTokenRemaining) {\\n            rewardToken.safeTransfer(user, amount);\\n            return 0;\\n        }\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the supply index\\n     * @param vToken The market whose supply index to update\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenSupplyIndex(address vToken) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplySpeed = rewardTokenSupplySpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (supplyState.lastRewardingBlock > 0 && blockNumber > supplyState.lastRewardingBlock) {\\n            blockNumber = supplyState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(supplyState.block));\\n\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\n            uint256 supplyTokens = VToken(vToken).totalSupply();\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, supplySpeed);\\n            Double memory ratio = supplyTokens > 0\\n                ? fraction(accruedSinceUpdate, supplyTokens)\\n                : Double({ mantissa: 0 });\\n            supplyState.index = safe224(\\n                add_(Double({ mantissa: supplyState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            supplyState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            supplyState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenSupplyIndexUpdated(vToken);\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the borrow index\\n     * @param vToken The market whose borrow index to update\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowSpeed = rewardTokenBorrowSpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (borrowState.lastRewardingBlock > 0 && blockNumber > borrowState.lastRewardingBlock) {\\n            blockNumber = borrowState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(borrowState.block));\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, borrowSpeed);\\n            Double memory ratio = borrowAmount > 0\\n                ? fraction(accruedSinceUpdate, borrowAmount)\\n                : Double({ mantissa: 0 });\\n            borrowState.index = safe224(\\n                add_(Double({ mantissa: borrowState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            borrowState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            borrowState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenBorrowIndexUpdated(vToken, marketBorrowIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x598aad1a12d6a895f82a8b619000099efe53994fe89522b41adaa68819fac652\",\"license\":\"BSD-3-Clause\"},\"contracts/RiskFund/IProtocolShareReserve.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title IProtocolShareReserve\\n * @author Venus\\n * @notice Interface implemented by `ProtocolShareReserve`.\\n */\\ninterface IProtocolShareReserve {\\n    function updateAssetsState(address comptroller, address asset) external;\\n}\\n\",\"keccak256\":\"0x45bf43fe09973ebfe0b5d3e81f966d7521b88c118d6ff64c289c500a62a7d564\",\"license\":\"BSD-3-Clause\"},\"contracts/RiskFund/IRiskFund.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title IRiskFund\\n * @author Venus\\n * @notice Interface implemented by `RiskFund`.\\n */\\ninterface IRiskFund {\\n    function swapPoolsAssets(\\n        address[] calldata markets,\\n        uint256[] calldata amountsOutMin,\\n        address[][] calldata paths,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function transferReserveForAuction(address comptroller, uint256 amount) external returns (uint256);\\n\\n    function updateAssetsState(address comptroller, address asset) external;\\n\\n    function convertibleBaseAsset() external view returns (address);\\n\\n    function getPoolsBaseAssetReserves(address comptroller) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xa519791948d96fb81143cdd9db0a2b753a39f1f9ca4e8c68b92997e2095f241a\",\"license\":\"BSD-3-Clause\"},\"contracts/RiskFund/ReserveHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport { ensureNonzeroAddress } from \\\"../lib/validators.sol\\\";\\nimport { ComptrollerInterface } from \\\"../ComptrollerInterface.sol\\\";\\nimport { PoolRegistryInterface } from \\\"../Pool/PoolRegistryInterface.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { PoolRegistry } from \\\"../Pool/PoolRegistry.sol\\\";\\n\\ncontract ReserveHelpers is Ownable2StepUpgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 private constant NOT_ENTERED = 1;\\n\\n    uint256 private constant ENTERED = 2;\\n\\n    // Address of the core pool's comptroller\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable CORE_POOL_COMPTROLLER;\\n\\n    // Address of the VBNB\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable VBNB;\\n\\n    // Address of the native wrapped token\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable NATIVE_WRAPPED;\\n\\n    // Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools).\\n    mapping(address => uint256) public assetsReserves;\\n\\n    // Store the asset's reserve per pool in the ProtocolShareReserve.\\n    // Comptroller(pool) -> Asset -> amount\\n    mapping(address => mapping(address => uint256)) internal _poolsAssetsReserves;\\n\\n    // Address of pool registry contract\\n    address public poolRegistry;\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    uint256 internal status;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     */\\n    uint256[46] private __gap;\\n\\n    /// @notice Event emitted after the update of the assets reserves.\\n    /// @param comptroller Pool's Comptroller address\\n    /// @param asset Token address\\n    /// @param amount An amount by which the reserves have increased\\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\\n\\n    /// @notice event emitted on sweep token success\\n    event SweepToken(address indexed token, address indexed to, uint256 amount);\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(status != ENTERED, \\\"re-entered\\\");\\n        status = ENTERED;\\n        _;\\n        status = NOT_ENTERED;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address corePoolComptroller_, address vbnb_, address nativeWrapped_) {\\n        ensureNonzeroAddress(corePoolComptroller_);\\n        ensureNonzeroAddress(vbnb_);\\n        ensureNonzeroAddress(nativeWrapped_);\\n        \\n        CORE_POOL_COMPTROLLER = corePoolComptroller_;\\n        VBNB = vbnb_;\\n        NATIVE_WRAPPED = nativeWrapped_;\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental BEP-20 transfers to this contract. Tokens are sent to the address `to`, provided in input\\n     * @param _token The address of the BEP-20 token to sweep\\n     * @param _to Recipient of the output tokens.\\n     * @custom:error ZeroAddressNotAllowed is thrown when asset address is zero\\n     * @custom:access Only Owner\\n     */\\n    function sweepToken(address _token, address _to) external onlyOwner nonReentrant {\\n        ensureNonzeroAddress(_to);\\n        uint256 balanceDfference_;\\n        uint256 balance_ = IERC20Upgradeable(_token).balanceOf(address(this));\\n\\n        require(balance_ > assetsReserves[_token], \\\"ReserveHelpers: Zero surplus tokens\\\");\\n        unchecked {\\n            balanceDfference_ = balance_ - assetsReserves[_token];\\n        }\\n\\n        emit SweepToken(_token, _to, balanceDfference_);\\n        IERC20Upgradeable(_token).safeTransfer(_to, balanceDfference_);\\n    }\\n\\n    /**\\n     * @notice Get the Amount of the asset in the risk fund for the specific pool.\\n     * @param comptroller  Comptroller address(pool).\\n     * @param asset Asset address.\\n     * @return Asset's reserve in risk fund.\\n     * @custom:error ZeroAddressNotAllowed is thrown when asset address is zero\\n     */\\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\\n        ensureNonzeroAddress(asset);\\n        require(ComptrollerInterface(comptroller).isComptroller(), \\\"ReserveHelpers: Comptroller address invalid\\\");\\n        return _poolsAssetsReserves[comptroller][asset];\\n    }\\n\\n    /**\\n     * @notice Update the reserve of the asset for the specific pool after transferring to risk fund\\n     * and transferring funds to the protocol share reserve\\n     * @param comptroller  Comptroller address(pool).\\n     * @param asset Asset address.\\n     * @custom:error ZeroAddressNotAllowed is thrown when asset address is zero\\n     */\\n    function updateAssetsState(address comptroller, address asset) public virtual {\\n        ensureNonzeroAddress(asset);\\n        require(ComptrollerInterface(comptroller).isComptroller(), \\\"ReserveHelpers: Comptroller address invalid\\\");\\n        address poolRegistry_ = poolRegistry;\\n        require(poolRegistry_ != address(0), \\\"ReserveHelpers: Pool Registry address is not set\\\");\\n        require(ensureAssetListed(comptroller, asset), \\\"ReserveHelpers: The pool doesn't support the asset\\\");\\n\\n        uint256 currentBalance = IERC20Upgradeable(asset).balanceOf(address(this));\\n        uint256 assetReserve = assetsReserves[asset];\\n        if (currentBalance > assetReserve) {\\n            uint256 balanceDifference;\\n            unchecked {\\n                balanceDifference = currentBalance - assetReserve;\\n            }\\n            assetsReserves[asset] += balanceDifference;\\n            _poolsAssetsReserves[comptroller][asset] += balanceDifference;\\n            emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\\n        }\\n    }\\n\\n    function isAssetListedInCore(address tokenAddress) internal view returns (bool isAssetListed) {\\n        VToken[] memory coreMarkets = ComptrollerInterface(CORE_POOL_COMPTROLLER).getAllMarkets();\\n\\n        for (uint256 i; i < coreMarkets.length; ++i) {\\n            isAssetListed = (VBNB == address(coreMarkets[i]))\\n                ? (tokenAddress == NATIVE_WRAPPED)\\n                : (coreMarkets[i].underlying() == tokenAddress);\\n\\n            if (isAssetListed) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice This function checks for the given asset is listed or not\\n    /// @param comptroller Address of the comptroller\\n    /// @param asset Address of the asset\\n    function ensureAssetListed(address comptroller, address asset) internal view returns (bool) {\\n        if (comptroller == CORE_POOL_COMPTROLLER) {\\n            return isAssetListedInCore(asset);\\n        }\\n\\n        return PoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0);\\n    }\\n}\\n\",\"keccak256\":\"0xf30155bbbb7251eb8445c7d282427ed0040d015fe34efcb5ec61bc92a289b0cc\",\"license\":\"BSD-3-Clause\"},\"contracts/RiskFund/RiskFund.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\nimport { ComptrollerInterface } from \\\"../ComptrollerInterface.sol\\\";\\nimport { IRiskFund } from \\\"./IRiskFund.sol\\\";\\nimport { ReserveHelpers } from \\\"./ReserveHelpers.sol\\\";\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { ComptrollerViewInterface } from \\\"../ComptrollerInterface.sol\\\";\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\nimport { PoolRegistry } from \\\"../Pool/PoolRegistry.sol\\\";\\nimport { IPancakeswapV2Router } from \\\"../IPancakeswapV2Router.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"../MaxLoopsLimitHelper.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"../lib/validators.sol\\\";\\nimport { ApproveOrRevert } from \\\"../lib/ApproveOrRevert.sol\\\";\\n\\n/**\\n * @title RiskFund\\n * @author Venus\\n * @notice Contract with basic features to track/hold different assets for different Comptrollers.\\n * @dev This contract does not support BNB.\\n */\\ncontract RiskFund is AccessControlledV8, ExponentialNoError, ReserveHelpers, MaxLoopsLimitHelper, IRiskFund {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using ApproveOrRevert for IERC20Upgradeable;\\n\\n    address public convertibleBaseAsset;\\n    address public shortfall;\\n    address public pancakeSwapRouter;\\n    uint256 public minAmountToConvert;\\n\\n    /// @notice Emitted when pool registry address is updated\\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\\n\\n    /// @notice Emitted when shortfall contract address is updated\\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\\n\\n    /// @notice Emitted when convertible base asset is updated\\n    event ConvertibleBaseAssetUpdated(address indexed oldConvertibleBaseAsset, address indexed newConvertibleBaseAsset);\\n\\n    /// @notice Emitted when PancakeSwap router contract address is updated\\n    event PancakeSwapRouterUpdated(address indexed oldPancakeSwapRouter, address indexed newPancakeSwapRouter);\\n\\n    /// @notice Emitted when minimum amount to convert is updated\\n    event MinAmountToConvertUpdated(uint256 oldMinAmountToConvert, uint256 newMinAmountToConvert);\\n\\n    /// @notice Emitted when pools assets are swapped\\n    event SwappedPoolsAssets(address[] markets, uint256[] amountsOutMin, uint256 totalAmount);\\n\\n    /// @notice Emitted when reserves are transferred for auction\\n    event TransferredReserveForAuction(address indexed comptroller, uint256 amount);\\n\\n    /// @dev Note that the contract is upgradeable. Use initialize() or reinitializers\\n    ///      to set the state variables.\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        address corePoolComptroller_,\\n        address vbnb_,\\n        address nativeWrapped_\\n    ) ReserveHelpers(corePoolComptroller_, vbnb_, nativeWrapped_) {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initializes the deployer to owner.\\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\\n     * @param minAmountToConvert_ Minimum amount assets must be worth to convert into base asset\\n     * @param convertibleBaseAsset_ Address of the base asset\\n     * @param accessControlManager_ Address of the access control contract\\n     * @param loopsLimit_ Limit for the loops in the contract to avoid DOS\\n     * @custom:error ZeroAddressNotAllowed is thrown when PCS router address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when convertible base asset address is zero\\n     */\\n    function initialize(\\n        address pancakeSwapRouter_,\\n        uint256 minAmountToConvert_,\\n        address convertibleBaseAsset_,\\n        address accessControlManager_,\\n        uint256 loopsLimit_\\n    ) external initializer {\\n        ensureNonzeroAddress(pancakeSwapRouter_);\\n        ensureNonzeroAddress(convertibleBaseAsset_);\\n        require(minAmountToConvert_ > 0, \\\"Risk Fund: Invalid min amount to convert\\\");\\n        require(loopsLimit_ > 0, \\\"Risk Fund: Loops limit can not be zero\\\");\\n\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n\\n        pancakeSwapRouter = pancakeSwapRouter_;\\n        minAmountToConvert = minAmountToConvert_;\\n        convertibleBaseAsset = convertibleBaseAsset_;\\n\\n        _setMaxLoopsLimit(loopsLimit_);\\n    }\\n\\n    /**\\n     * @notice Pool registry setter\\n     * @param poolRegistry_ Address of the pool registry\\n     * @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\\n     */\\n    function setPoolRegistry(address poolRegistry_) external onlyOwner {\\n        ensureNonzeroAddress(poolRegistry_);\\n        address oldPoolRegistry = poolRegistry;\\n        poolRegistry = poolRegistry_;\\n        emit PoolRegistryUpdated(oldPoolRegistry, poolRegistry_);\\n    }\\n\\n    /**\\n     * @notice Shortfall contract address setter\\n     * @param shortfallContractAddress_ Address of the auction contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     */\\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\\n        ensureNonzeroAddress(shortfallContractAddress_);\\n\\n        address oldShortfallContractAddress = shortfall;\\n        shortfall = shortfallContractAddress_;\\n        emit ShortfallContractUpdated(oldShortfallContractAddress, shortfallContractAddress_);\\n    }\\n\\n    /**\\n     * @notice PancakeSwap router address setter\\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\\n     * @custom:error ZeroAddressNotAllowed is thrown when PCS router address is zero\\n     */\\n    function setPancakeSwapRouter(address pancakeSwapRouter_) external onlyOwner {\\n        ensureNonzeroAddress(pancakeSwapRouter_);\\n        address oldPancakeSwapRouter = pancakeSwapRouter;\\n        pancakeSwapRouter = pancakeSwapRouter_;\\n        emit PancakeSwapRouterUpdated(oldPancakeSwapRouter, pancakeSwapRouter_);\\n    }\\n\\n    /**\\n     * @notice Min amount to convert setter\\n     * @param minAmountToConvert_ Min amount to convert.\\n     */\\n    function setMinAmountToConvert(uint256 minAmountToConvert_) external {\\n        _checkAccessAllowed(\\\"setMinAmountToConvert(uint256)\\\");\\n        require(minAmountToConvert_ > 0, \\\"Risk Fund: Invalid min amount to convert\\\");\\n        uint256 oldMinAmountToConvert = minAmountToConvert;\\n        minAmountToConvert = minAmountToConvert_;\\n        emit MinAmountToConvertUpdated(oldMinAmountToConvert, minAmountToConvert_);\\n    }\\n\\n    /**\\n     * @notice Sets a new convertible base asset\\n     * @param _convertibleBaseAsset Address for new convertible base asset.\\n     */\\n    function setConvertibleBaseAsset(address _convertibleBaseAsset) external {\\n        _checkAccessAllowed(\\\"setConvertibleBaseAsset(address)\\\");\\n        require(_convertibleBaseAsset != address(0), \\\"Risk Fund: new convertible base asset address invalid\\\");\\n\\n        address oldConvertibleBaseAsset = convertibleBaseAsset;\\n        convertibleBaseAsset = _convertibleBaseAsset;\\n\\n        emit ConvertibleBaseAssetUpdated(oldConvertibleBaseAsset, _convertibleBaseAsset);\\n    }\\n\\n    /**\\n     * @notice Swap array of pool assets into base asset's tokens of at least a minimum amount\\n     * @param markets Array of vTokens whose assets to swap for base asset\\n     * @param amountsOutMin Minimum amount to receive for swap\\n     * @param paths A path consisting of PCS token pairs for each swap\\n     * @param deadline Deadline for the swap\\n     * @return Number of swapped tokens\\n     * @custom:error ZeroAddressNotAllowed is thrown if PoolRegistry contract address is not configured\\n     */\\n    function swapPoolsAssets(\\n        address[] calldata markets,\\n        uint256[] calldata amountsOutMin,\\n        address[][] calldata paths,\\n        uint256 deadline\\n    ) external override nonReentrant returns (uint256) {\\n        _checkAccessAllowed(\\\"swapPoolsAssets(address[],uint256[],address[][],uint256)\\\");\\n        require(deadline >= block.timestamp, \\\"Risk fund: deadline passed\\\");\\n        address poolRegistry_ = poolRegistry;\\n        ensureNonzeroAddress(poolRegistry_);\\n        require(markets.length == amountsOutMin.length, \\\"Risk fund: markets and amountsOutMin are unequal lengths\\\");\\n        require(markets.length == paths.length, \\\"Risk fund: markets and paths are unequal lengths\\\");\\n\\n        uint256 totalAmount;\\n        uint256 marketsCount = markets.length;\\n\\n        _ensureMaxLoops(marketsCount);\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            address comptroller = address(VToken(markets[i]).comptroller());\\n\\n            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry_).getPoolByComptroller(comptroller);\\n            require(pool.comptroller == comptroller, \\\"comptroller doesn't exist pool registry\\\");\\n            require(Comptroller(comptroller).isMarketListed(VToken(markets[i])), \\\"market is not listed\\\");\\n\\n            uint256 swappedTokens = _swapAsset(VToken(markets[i]), comptroller, amountsOutMin[i], paths[i]);\\n            _poolsAssetsReserves[comptroller][convertibleBaseAsset] += swappedTokens;\\n            assetsReserves[convertibleBaseAsset] += swappedTokens;\\n            totalAmount = totalAmount + swappedTokens;\\n        }\\n\\n        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\\n\\n        return totalAmount;\\n    }\\n\\n    /**\\n     * @notice Transfer tokens for auction.\\n     * @param comptroller Comptroller of the pool.\\n     * @param amount Amount to be transferred to auction contract.\\n     * @return Number reserved tokens.\\n     */\\n    function transferReserveForAuction(\\n        address comptroller,\\n        uint256 amount\\n    ) external override nonReentrant returns (uint256) {\\n        address shortfall_ = shortfall;\\n        require(msg.sender == shortfall_, \\\"Risk fund: Only callable by Shortfall contract\\\");\\n        require(\\n            amount <= _poolsAssetsReserves[comptroller][convertibleBaseAsset],\\n            \\\"Risk Fund: Insufficient pool reserve.\\\"\\n        );\\n        unchecked {\\n            _poolsAssetsReserves[comptroller][convertibleBaseAsset] =\\n                _poolsAssetsReserves[comptroller][convertibleBaseAsset] -\\n                amount;\\n        }\\n        unchecked {\\n            assetsReserves[convertibleBaseAsset] = assetsReserves[convertibleBaseAsset] - amount;\\n        }\\n\\n        emit TransferredReserveForAuction(comptroller, amount);\\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(shortfall_, amount);\\n\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Get the Amount of the Base asset in the risk fund for the specific pool.\\n     * @param comptroller  Comptroller address(pool).\\n     * @return Base Asset's reserve in risk fund.\\n     */\\n    function getPoolsBaseAssetReserves(address comptroller) external view returns (uint256) {\\n        require(ComptrollerInterface(comptroller).isComptroller(), \\\"Risk Fund: Comptroller address invalid\\\");\\n        return _poolsAssetsReserves[comptroller][convertibleBaseAsset];\\n    }\\n\\n    /**\\n     * @notice Update the reserve of the asset for the specific pool after transferring to risk fund.\\n     * @param comptroller  Comptroller address(pool).\\n     * @param asset Asset address.\\n     */\\n    function updateAssetsState(address comptroller, address asset) public override(IRiskFund, ReserveHelpers) {\\n        super.updateAssetsState(comptroller, asset);\\n    }\\n\\n    /**\\n     * @dev Swap single asset to base asset.\\n     * @param vToken VToken\\n     * @param comptroller Comptroller address\\n     * @param amountOutMin Minimum amount to receive for swap\\n     * @param path A path for the swap consisting of PCS token pairs\\n     * @return Number of swapped tokens.\\n     */\\n    function _swapAsset(\\n        VToken vToken,\\n        address comptroller,\\n        uint256 amountOutMin,\\n        address[] calldata path\\n    ) internal returns (uint256) {\\n        require(amountOutMin != 0, \\\"RiskFund: amountOutMin must be greater than 0 to swap vToken\\\");\\n        uint256 totalAmount;\\n\\n        address underlyingAsset = vToken.underlying();\\n        address convertibleBaseAsset_ = convertibleBaseAsset;\\n        uint256 balanceOfUnderlyingAsset = _poolsAssetsReserves[comptroller][underlyingAsset];\\n\\n        if (balanceOfUnderlyingAsset == 0) {\\n            return 0;\\n        }\\n\\n        ResilientOracleInterface oracle = ComptrollerViewInterface(comptroller).oracle();\\n        oracle.updateAssetPrice(convertibleBaseAsset_);\\n        Exp memory baseAssetPrice = Exp({ mantissa: oracle.getPrice(convertibleBaseAsset_) });\\n        uint256 amountOutMinInUsd = mul_ScalarTruncate(baseAssetPrice, amountOutMin);\\n\\n        require(amountOutMinInUsd >= minAmountToConvert, \\\"RiskFund: minAmountToConvert violated\\\");\\n\\n        assetsReserves[underlyingAsset] -= balanceOfUnderlyingAsset;\\n        _poolsAssetsReserves[comptroller][underlyingAsset] -= balanceOfUnderlyingAsset;\\n\\n        if (underlyingAsset != convertibleBaseAsset_) {\\n            require(path[0] == underlyingAsset, \\\"RiskFund: swap path must start with the underlying asset\\\");\\n            require(\\n                path[path.length - 1] == convertibleBaseAsset_,\\n                \\\"RiskFund: finally path must be convertible base asset\\\"\\n            );\\n            address pancakeSwapRouter_ = pancakeSwapRouter;\\n            IERC20Upgradeable(underlyingAsset).approveOrRevert(pancakeSwapRouter_, 0);\\n            IERC20Upgradeable(underlyingAsset).approveOrRevert(pancakeSwapRouter_, balanceOfUnderlyingAsset);\\n            uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter_).swapExactTokensForTokens(\\n                balanceOfUnderlyingAsset,\\n                amountOutMin,\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n            totalAmount = amounts[path.length - 1];\\n        } else {\\n            totalAmount = balanceOfUnderlyingAsset;\\n        }\\n\\n        return totalAmount;\\n    }\\n}\\n\",\"keccak256\":\"0x918526b067c834935f5dd0788139e1a73c64cbf6f8b7d6fd43242eaa93aa7f37\",\"license\":\"BSD-3-Clause\"},\"contracts/VToken.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { VTokenInterface } from \\\"./VTokenInterfaces.sol\\\";\\nimport { ComptrollerInterface, ComptrollerViewInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { TokenErrorReporter } from \\\"./ErrorReporter.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { IProtocolShareReserve } from \\\"./RiskFund/IProtocolShareReserve.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title VToken\\n * @author Venus\\n * @notice Each asset that is supported by a pool is integrated through an instance of the `VToken` contract. As outlined in the protocol overview,\\n * each isolated pool creates its own `vToken` corresponding to an asset. Within a given pool, each included `vToken` is referred to as a market of\\n * the pool. The main actions a user regularly interacts with in a market are:\\n\\n- mint/redeem of vTokens;\\n- transfer of vTokens;\\n- borrow/repay a loan on an underlying asset;\\n- liquidate a borrow or liquidate/heal an account.\\n\\n * A user supplies the underlying asset to a pool by minting `vTokens`, where the corresponding `vToken` amount is determined by the `exchangeRate`.\\n * The `exchangeRate` will change over time, dependent on a number of factors, some of which accrue interest. Additionally, once users have minted\\n * `vToken` in a pool, they can borrow any asset in the isolated pool by using their `vToken` as collateral. In order to borrow an asset or use a `vToken`\\n * as collateral, the user must be entered into each corresponding market (else, the `vToken` will not be considered collateral for a borrow). Note that\\n * a user may borrow up to a portion of their collateral determined by the market\\u2019s collateral factor. However, if their borrowed amount exceeds an amount\\n * calculated using the market\\u2019s corresponding liquidation threshold, the borrow is eligible for liquidation. When a user repays a borrow, they must also\\n * pay off interest accrued on the borrow.\\n * \\n * The Venus protocol includes unique mechanisms for healing an account and liquidating an account. These actions are performed in the `Comptroller`\\n * and consider all borrows and collateral for which a given account is entered within a market. These functions may only be called on an account with a\\n * total collateral amount that is no larger than a universal `minLiquidatableCollateral` value, which is used for all markets within a `Comptroller`.\\n * Both functions settle all of an account\\u2019s borrows, but `healAccount()` may add `badDebt` to a vToken. For more detail, see the description of\\n * `healAccount()` and `liquidateAccount()` in the `Comptroller` summary section below.\\n */\\ncontract VToken is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    VTokenInterface,\\n    ExponentialNoError,\\n    TokenErrorReporter\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 internal constant DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA = 5e16; // 5%\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\n        // to set the state variables.\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     * @custom:error ZeroAddressNotAllowed is thrown when admin address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     */\\n    function initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) external initializer {\\n        ensureNonzeroAddress(admin_);\\n\\n        // Initialize the market\\n        _initialize(\\n            underlying_,\\n            comptroller_,\\n            interestRateModel_,\\n            initialExchangeRateMantissa_,\\n            name_,\\n            symbol_,\\n            decimals_,\\n            admin_,\\n            accessControlManager_,\\n            riskManagement,\\n            reserveFactorMantissa_\\n        );\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param addedValue The number of additional tokens spender can transfer\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 newAllowance = transferAllowances[src][spender];\\n        newAllowance += addedValue;\\n        transferAllowances[src][spender] = newAllowance;\\n\\n        emit Approval(src, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decreases approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param subtractedValue The number of tokens to remove from total approval\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 currentAllowance = transferAllowances[src][spender];\\n        require(currentAllowance >= subtractedValue, \\\"decreased allowance below zero\\\");\\n        unchecked {\\n            currentAllowance -= subtractedValue;\\n        }\\n\\n        transferAllowances[src][spender] = currentAllowance;\\n\\n        emit Approval(src, spender, currentAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return amount The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return totalBorrows The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, msg.sender, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param minter User whom the supply will be attributed to\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when minter address is zero\\n     */\\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        ensureNonzeroAddress(minter);\\n\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, minter, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of vTokens to redeem into underlying\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, redeemTokens, 0);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     */\\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, 0, redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender borrows assets from the protocol to their own address\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Borrow event; may emit AccrueInterest\\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _borrowFresh(msg.sender, borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Not restricted\\n     */\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external override returns (uint256) {\\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice sets protocol share accumulated from liquidations\\n     * @dev must be equal or less than liquidation incentive - 1\\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\\n     * @custom:event Emits NewProtocolSeizeShare event on success\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\\n        _checkAccessAllowed(\\\"setProtocolSeizeShare(uint256)\\\");\\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\\n        if (newProtocolSeizeShareMantissa_ + MANTISSA_ONE > liquidationIncentive) {\\n            revert ProtocolSeizeShareTooBig();\\n        }\\n\\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\\n    }\\n\\n    /**\\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n     * @dev Admin function to accrue interest and set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\\n        _checkAccessAllowed(\\\"setReserveFactor(uint256)\\\");\\n\\n        accrueInterest();\\n        _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\\n     * @custom:access Not restricted\\n     */\\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\\n        accrueInterest();\\n        _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount of underlying token to add as reserves\\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function addReserves(uint256 addAmount) external override nonReentrant {\\n        accrueInterest();\\n        _addReservesFresh(addAmount);\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external override {\\n        _checkAccessAllowed(\\\"setInterestRateModel(address)\\\");\\n\\n        accrueInterest();\\n        _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\\n     *   \\\"forgiving\\\" the borrower. Healing is a situation that should rarely happen. However, some pools\\n     *   may list risky assets or be configured improperly \\u2013 we want to still handle such cases gracefully.\\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\\n     * @dev This function does not call any Comptroller hooks (like \\\"healAllowed\\\"), because we assume\\n     *   the Comptroller does all the necessary checks before calling this function.\\n     * @param payer account who repays the debt\\n     * @param borrower account to heal\\n     * @param repayAmount amount to repay\\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:access Only Comptroller\\n     */\\n    function healBorrow(address payer, address borrower, uint256 repayAmount) external override nonReentrant {\\n        if (repayAmount != 0) {\\n            comptroller.preRepayHook(address(this), borrower);\\n        }\\n\\n        if (msg.sender != address(comptroller)) {\\n            revert HealBorrowUnauthorized();\\n        }\\n\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 totalBorrowsNew = totalBorrows;\\n\\n        uint256 actualRepayAmount;\\n        if (repayAmount != 0) {\\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\\n            emit RepayBorrow(\\n                payer,\\n                borrower,\\n                actualRepayAmount,\\n                accountBorrowsPrev - actualRepayAmount,\\n                totalBorrowsNew\\n            );\\n        }\\n\\n        // The transaction will fail if trying to repay too much\\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\\n        if (badDebtDelta != 0) {\\n            uint256 badDebtOld = badDebt;\\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\\n            badDebt = badDebtNew;\\n\\n            // We treat healing as \\\"repayment\\\", where vToken is the payer\\n            emit RepayBorrow(address(this), borrower, badDebtDelta, 0, totalBorrowsNew);\\n            emit BadDebtIncreased(borrower, badDebtDelta, badDebtOld, badDebtNew);\\n        }\\n\\n        accountBorrows[borrower].principal = 0;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        emit HealBorrow(payer, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\\n     *  the close factor check. The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Only Comptroller\\n     */\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        if (msg.sender != address(comptroller)) {\\n            revert ForceLiquidateBorrowUnauthorized();\\n        }\\n        _liquidateBorrow(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another vToken during the process of liquidation.\\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     * @custom:event Emits Transfer, ReservesAdded events\\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:access Not restricted\\n     */\\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override nonReentrant {\\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Updates bad debt\\n     * @dev Called only when bad debt is recovered from auction\\n     * @param recoveredAmount_ The amount of bad debt recovered\\n     * @custom:event Emits BadDebtRecovered event\\n     * @custom:access Only Shortfall contract\\n     */\\n    function badDebtRecovered(uint256 recoveredAmount_) external {\\n        require(msg.sender == shortfall, \\\"only shortfall contract can update bad debt\\\");\\n        require(recoveredAmount_ <= badDebt, \\\"more than bad debt recovered from auction\\\");\\n\\n        uint256 badDebtOld = badDebt;\\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\\n        badDebt = badDebtNew;\\n\\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\\n    }\\n\\n    /**\\n     * @notice Sets protocol share reserve contract address\\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\\n        _setProtocolShareReserve(protocolShareReserve_);\\n    }\\n\\n    /**\\n     * @notice Sets shortfall contract address\\n     * @param shortfall_ The address of the shortfall contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setShortfallContract(address shortfall_) external onlyOwner {\\n        _setShortfallContract(shortfall_);\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     * @custom:access Only Governance\\n     */\\n    function sweepToken(IERC20Upgradeable token) external override {\\n        require(msg.sender == owner(), \\\"VToken::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"VToken::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.safeTransfer(owner(), balance);\\n\\n        emit SweepToken(address(token));\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return amount The number of tokens allowed to be spent (type(uint256).max means infinite)\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return amount The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return vTokenBalance User's balance of vTokens\\n     * @return borrowBalance Amount owed in terms of underlying\\n     * @return exchangeRate Stored exchange rate\\n     */\\n    function getAccountSnapshot(\\n        address account\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 error, uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRate)\\n    {\\n        return (NO_ERROR, accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this vToken in the underlying asset\\n     * @return cash The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() external view override returns (uint256) {\\n        return _getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this vToken\\n     * @return rate The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external view override returns (uint256) {\\n        return interestRateModel.getBorrowRate(_getCashPrior(), totalBorrows, totalReserves, badDebt);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this v\\n     * @return rate The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external view override returns (uint256) {\\n        return\\n            interestRateModel.getSupplyRate(\\n                _getCashPrior(),\\n                totalBorrows,\\n                totalReserves,\\n                reserveFactorMantissa,\\n                badDebt\\n            );\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceStored(address account) external view override returns (uint256) {\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() external view override returns (uint256) {\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     * @return Always NO_ERROR\\n     * @custom:event Emits AccrueInterest event on success\\n     * @custom:access Not restricted\\n     */\\n    function accrueInterest() public virtual override returns (uint256) {\\n        /* Remember the initial block number */\\n        uint256 currentBlockNumber = _getBlockNumber();\\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint256 cashPrior = _getCashPrior();\\n        uint256 borrowsPrior = totalBorrows;\\n        uint256 reservesPrior = totalReserves;\\n        uint256 borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior, badDebt);\\n        require(borrowRateMantissa <= MAX_BORROW_RATE_MANTISSA, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\\n            Exp({ mantissa: reserveFactorMantissa }),\\n            interestAccumulated,\\n            reservesPrior\\n        );\\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives vTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param payer The address of the account which is sending the assets for supply\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function _mintFresh(address payer, address minter, uint256 mintAmount) internal {\\n        /* Fail if mint not allowed */\\n        comptroller.preMintHook(address(this), minter, mintAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `_doTransferIn` for the minter and the mintAmount.\\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint256 actualMintAmount = _doTransferIn(payer, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        uint256 balanceAfter = accountTokens[minter] + mintTokens;\\n        accountTokens[minter] = balanceAfter;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens, balanceAfter);\\n        emit Transfer(address(0), minter, mintTokens);\\n    }\\n\\n    /**\\n     * @notice User redeems vTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function _redeemFresh(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn) internal {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             */\\n            redeemTokens = redeemTokensIn;\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n\\n            uint256 _redeemAmount = mul_(redeemTokens, exchangeRate);\\n            if (_redeemAmount != 0 && _redeemAmount != redeemAmountIn) redeemTokens++; // round up\\n        }\\n\\n        // redeemAmount = exchangeRate * redeemTokens\\n        redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokens);\\n\\n        // Revert if amount is zero\\n        if (redeemAmount == 0) {\\n            revert(\\\"redeemAmount is zero\\\");\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        comptroller.preRedeemHook(address(this), redeemer, redeemTokens);\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (_getCashPrior() - totalReserves < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        uint256 balanceAfter = accountTokens[redeemer] - redeemTokens;\\n        accountTokens[redeemer] = balanceAfter;\\n\\n        /*\\n         * We invoke _doTransferOut for the redeemer and the redeemAmount.\\n         *  On success, the vToken has redeemAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(redeemer, redeemAmount);\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens, balanceAfter);\\n    }\\n\\n    /**\\n     * @notice Users borrow assets from the protocol to their own address\\n     * @param borrower User who borrows the assets\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     */\\n    function _borrowFresh(address borrower, uint256 borrowAmount) internal {\\n        /* Fail if borrow not allowed */\\n        comptroller.preBorrowHook(address(this), borrower, borrowAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (_getCashPrior() - totalReserves < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke _doTransferOut for the borrower and the borrowAmount.\\n         *  On success, the vToken borrowAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or type(uint256).max for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function _repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\\n        /* Fail if repayBorrow not allowed */\\n        comptroller.preRepayHook(address(this), borrower);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n\\n        uint256 repayAmountFinal = repayAmount >= accountBorrowsPrev ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call _doTransferIn for the payer and the repayAmount\\n         *  On success, the vToken holds an additional repayAmount of cash.\\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint256 actualRepayAmount = _doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint256 error = vTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // _liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrowFresh(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal {\\n        /* Fail if liquidate not allowed */\\n        comptroller.preLiquidateHook(\\n            address(this),\\n            address(vTokenCollateral),\\n            borrower,\\n            repayAmount,\\n            skipLiquidityCheck\\n        );\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify vTokenCollateral market's block number equals current block number */\\n        if (vTokenCollateral.accrualBlockNumber() != _getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = type(uint256).max */\\n        if (repayAmount == type(uint256).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint256 actualRepayAmount = _repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\\n            address(this),\\n            address(vTokenCollateral),\\n            actualRepayAmount\\n        );\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, call _seize internally to avoid re-entrancy, otherwise make an external call\\n        if (address(vTokenCollateral) == address(this)) {\\n            _seize(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            vTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another VToken.\\n     *  It's absolutely critical to use msg.sender as the seizer vToken and not a parameter.\\n     * @param seizerContract The contract seizing the collateral (either borrowed vToken or Comptroller)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     */\\n    function _seize(address seizerContract, address liquidator, address borrower, uint256 seizeTokens) internal {\\n        /* Fail if seize not allowed */\\n        comptroller.preSeizeHook(address(this), seizerContract, liquidator, borrower);\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint256 liquidationIncentiveMantissa = ComptrollerViewInterface(address(comptroller))\\n            .liquidationIncentiveMantissa();\\n        uint256 numerator = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\\n        uint256 protocolSeizeTokens = div_(numerator, Exp({ mantissa: liquidationIncentiveMantissa }));\\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n        uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalReserves = totalReservesNew;\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n    }\\n\\n    function _setComptroller(ComptrollerInterface newComptroller) internal {\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n    }\\n\\n    /**\\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n     * @dev Admin function to set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     */\\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal {\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \\u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > MAX_RESERVE_FACTOR_MANTISSA) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return actualAddAmount The actual amount added, excluding the potential token fees\\n     */\\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256) {\\n        // totalReserves + actualAddAmount\\n        uint256 totalReservesNew;\\n        uint256 actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\\n        totalReservesNew = totalReserves + actualAddAmount;\\n        totalReserves = totalReservesNew;\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        return actualAddAmount;\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to the protocol reserve contract\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     */\\n    function _reduceReservesFresh(uint256 reduceAmount) internal {\\n        // totalReserves - reduceAmount\\n        uint256 totalReservesNew;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (_getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \\u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\n        _doTransferOut(protocolShareReserve, reduceAmount);\\n\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(address(comptroller), underlying);\\n\\n        emit ReservesReduced(protocolShareReserve, reduceAmount, totalReservesNew);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal {\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     * @param from Sender of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     * @return Actual amount received\\n     */\\n    function _doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n        token.safeTransferFrom(from, address(this), amount);\\n        uint256 balanceAfter = token.balanceOf(address(this));\\n        // Return the amount that was *actually* transferred\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    /**\\n     * @dev Just a regular ERC-20 transfer, reverts on failure\\n     * @param to Receiver of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     */\\n    function _doTransferOut(address to, uint256 amount) internal virtual {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        token.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     */\\n    function _transferTokens(address spender, address src, address dst, uint256 tokens) internal {\\n        /* Fail if transfer not allowed */\\n        comptroller.preTransferHook(address(this), src, dst, tokens);\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint256 startingAllowance;\\n        if (spender == src) {\\n            startingAllowance = type(uint256).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint256 allowanceNew = startingAllowance - tokens;\\n        uint256 srcTokensNew = accountTokens[src] - tokens;\\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint256).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n    }\\n\\n    /**\\n     * @notice Initialize the money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     */\\n    function _initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        _setComptroller(comptroller_);\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = _getBlockNumber();\\n        borrowIndex = MANTISSA_ONE;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        _setInterestRateModelFresh(interestRateModel_);\\n\\n        _setReserveFactorFresh(reserveFactorMantissa_);\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        _setShortfallContract(riskManagement.shortfall);\\n        _setProtocolShareReserve(riskManagement.protocolShareReserve);\\n        protocolSeizeShareMantissa = DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA;\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        IERC20Upgradeable(underlying).totalSupply();\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n        _transferOwnership(admin_);\\n    }\\n\\n    function _setShortfallContract(address shortfall_) internal {\\n        ensureNonzeroAddress(shortfall_);\\n        address oldShortfall = shortfall;\\n        shortfall = shortfall_;\\n        emit NewShortfallContract(oldShortfall, shortfall_);\\n    }\\n\\n    function _setProtocolShareReserve(address payable protocolShareReserve_) internal {\\n        ensureNonzeroAddress(protocolShareReserve_);\\n        address oldProtocolShareReserve = address(protocolShareReserve);\\n        protocolShareReserve = protocolShareReserve_;\\n        emit NewProtocolShareReserve(oldProtocolShareReserve, address(protocolShareReserve_));\\n    }\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function _getCashPrior() internal view virtual returns (uint256) {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     * @return Current block number\\n     */\\n    function _getBlockNumber() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance the calculated balance\\n     */\\n    function _borrowBalanceStored(address account) internal view returns (uint256) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function _exchangeRateStored() internal view virtual returns (uint256) {\\n        uint256 _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        }\\n        /*\\n         * Otherwise:\\n         *  exchangeRate = (totalCash + totalBorrows + badDebt - totalReserves) / totalSupply\\n         */\\n        uint256 totalCash = _getCashPrior();\\n        uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows + badDebt - totalReserves;\\n        uint256 exchangeRate = (cashPlusBorrowsMinusReserves * EXP_SCALE) / _totalSupply;\\n\\n        return exchangeRate;\\n    }\\n}\\n\",\"keccak256\":\"0xcda9eb71f6ceb8a4c3bfbc1c42d72e2f0523d30f6d3252fbd90819e953640fe5\",\"license\":\"BSD-3-Clause\"},\"contracts/VTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\n\\n/**\\n * @title VTokenStorage\\n * @author Venus\\n * @notice Storage layout used by the `VToken` contract\\n */\\n// solhint-disable-next-line max-states-count\\ncontract VTokenStorage {\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint256 principal;\\n        uint256 interestIndex;\\n    }\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice Underlying asset for this VToken\\n     */\\n    address public underlying;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Protocol share Reserve contract address\\n     */\\n    address payable public protocolShareReserve;\\n\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint256 internal constant MAX_BORROW_RATE_MANTISSA = 0.0005e16;\\n\\n    // Maximum fraction of interest that can be set aside for reserves\\n    uint256 internal constant MAX_RESERVE_FACTOR_MANTISSA = 1e18;\\n\\n    /**\\n     * @notice Contract which oversees inter-vToken operations\\n     */\\n    ComptrollerInterface public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    // Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\\n    uint256 internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint256 public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint256 public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint256 public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint256 public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint256 public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint256 public totalSupply;\\n\\n    /**\\n     * @notice Total bad debt of the market\\n     */\\n    uint256 public badDebt;\\n\\n    // Official record of token balances for each account\\n    mapping(address => uint256) internal accountTokens;\\n\\n    // Approved token transfer amounts on behalf of others\\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint256 public protocolSeizeShareMantissa;\\n\\n    /**\\n     * @notice Storage of Shortfall contract address\\n     */\\n    address public shortfall;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\\n/**\\n * @title VTokenInterface\\n * @author Venus\\n * @notice Interface implemented by the `VToken` contract\\n */\\nabstract contract VTokenInterface is VTokenStorage {\\n    struct RiskManagementInit {\\n        address shortfall;\\n        address payable protocolShareReserve;\\n    }\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address indexed minter, uint256 mintAmount, uint256 mintTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address indexed borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(\\n        address indexed payer,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when bad debt is accumulated on a market\\n     * @param borrower borrower to \\\"forgive\\\"\\n     * @param badDebtDelta amount of new bad debt recorded\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtIncreased(address indexed borrower, uint256 badDebtDelta, uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when bad debt is recovered via an auction\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtRecovered(uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        address indexed vTokenCollateral,\\n        uint256 seizeTokens\\n    );\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(ComptrollerInterface indexed oldComptroller, ComptrollerInterface indexed newComptroller);\\n\\n    /**\\n     * @notice Event emitted when shortfall contract address is changed\\n     */\\n    event NewShortfallContract(address indexed oldShortfall, address indexed newShortfall);\\n\\n    /**\\n     * @notice Event emitted when protocol share reserve contract address is changed\\n     */\\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(\\n        InterestRateModel indexed oldInterestRateModel,\\n        InterestRateModel indexed newInterestRateModel\\n    );\\n\\n    /**\\n     * @notice Event emitted when protocol seize share is changed\\n     */\\n    event NewProtocolSeizeShare(uint256 oldProtocolSeizeShareMantissa, uint256 newProtocolSeizeShareMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address indexed benefactor, uint256 addAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address indexed admin, uint256 reduceAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Event emitted when healing the borrow\\n     */\\n    event HealBorrow(address indexed payer, address indexed borrower, uint256 repayAmount);\\n\\n    /**\\n     * @notice Event emitted when tokens are swept\\n     */\\n    event SweepToken(address indexed token);\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint256 mintAmount) external virtual returns (uint256);\\n\\n    function mintBehalf(address minter, uint256 mintAllowed) external virtual returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external virtual returns (uint256);\\n\\n    function healBorrow(address payer, address borrower, uint256 repayAmount) external virtual;\\n\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipCloseFactorCheck\\n    ) external virtual;\\n\\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external virtual;\\n\\n    function transfer(address dst, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 amount) external virtual returns (bool);\\n\\n    function accrueInterest() external virtual returns (uint256);\\n\\n    function sweepToken(IERC20Upgradeable token) external virtual;\\n\\n    /*** Admin Functions ***/\\n\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external virtual;\\n\\n    function reduceReserves(uint256 reduceAmount) external virtual;\\n\\n    function exchangeRateCurrent() external virtual returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\\n\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external virtual;\\n\\n    function addReserves(uint256 addAmount) external virtual;\\n\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool);\\n\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) external view virtual returns (uint256);\\n\\n    function getAccountSnapshot(address account) external view virtual returns (uint256, uint256, uint256, uint256);\\n\\n    function borrowRatePerBlock() external view virtual returns (uint256);\\n\\n    function supplyRatePerBlock() external view virtual returns (uint256);\\n\\n    function borrowBalanceStored(address account) external view virtual returns (uint256);\\n\\n    function exchangeRateStored() external view virtual returns (uint256);\\n\\n    function getCash() external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is a VToken contract (for inspection)\\n     * @return Always true\\n     */\\n    function isVToken() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x2947e95eb97a3a45f90ec36d4fd5a4cbb9409319f6ad000e950550055a3f2324\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/ApproveOrRevert.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nlibrary ApproveOrRevert {\\n    /// @notice Thrown if a contract is unable to approve a transfer\\n    error ApproveFailed();\\n\\n    /// @notice Approves a transfer, ensuring that it is successful. This function supports non-compliant\\n    /// tokens like the ones that don't return a boolean value on success. Thus, such approve call supports\\n    /// three different kinds of tokens:\\n    ///   * Compliant tokens that revert on failure\\n    ///   * Compliant tokens that return false on failure\\n    ///   * Non-compliant tokens that don't return a value\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param spender The spender contract address\\n    /// @param amount The value of the transfer\\n    function approveOrRevert(IERC20Upgradeable token, address spender, uint256 amount) internal {\\n        bytes memory callData = abi.encodeCall(token.approve, (spender, amount));\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory result) = address(token).call(callData);\\n\\n        if (!success || (result.length != 0 && !abi.decode(result, (bool)))) {\\n            revert ApproveFailed();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9bbc31c80a4c537ddfd06cbd03a412ba64842a708381fbc4bf2e33ef56c92b4d\",\"license\":\"MIT\"},\"contracts/lib/constants.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @dev The approximate number of blocks per year that is assumed by the interest rate model\\nuint256 constant BLOCKS_PER_YEAR = 10_512_000;\\n\\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\\nuint256 constant EXP_SCALE = 1e18;\\n\\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\\nuint256 constant MANTISSA_ONE = EXP_SCALE;\\n\",\"keccak256\":\"0x04cd899695ea593a2529cb6a1a04c2a34bff0c1516bd70a5f638ae7a850cad8b\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/validators.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\\nerror ZeroAddressNotAllowed();\\n\\n/// @notice Checks if the provided address is nonzero, reverts otherwise\\n/// @param address_ Address to check\\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\\nfunction ensureNonzeroAddress(address address_) pure {\\n    if (address_ == address(0)) {\\n        revert ZeroAddressNotAllowed();\\n    }\\n}\\n\",\"keccak256\":\"0x909eb76841ebd57d8f53686b76b1a09da7bbbbcddb29510c41674d5aa84c713e\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b50604051620032b8380380620032b883398101604081905262000034916200018c565b828282620000428362000083565b6200004d8262000083565b620000588162000083565b6001600160a01b0392831660805290821660a0521660c0526200007a620000ae565b505050620001d6565b6001600160a01b038116620000ab576040516342bcdf7f60e11b815260040160405180910390fd5b50565b600054610100900460ff16156200011b5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff908116146200016d576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b80516001600160a01b03811681146200018757600080fd5b919050565b600080600060608486031215620001a257600080fd5b620001ad846200016f565b9250620001bd602085016200016f565b9150620001cd604085016200016f565b90509250925092565b60805160a05160c05161309662000222600039600081816102bf015261258601526000818161029801526124c3015260008181610437015281816122df015261240c01526130966000f3fe608060405234801561001057600080fd5b50600436106101da5760003560e01c806377d4937f11610104578063afcff50f116100a2578063e30c397811610071578063e30c39781461040e578063f2fde38b1461041f578063fa7b81a014610432578063fe3da9841461045957600080fd5b8063afcff50f146103cd578063b4a0bdf3146103e0578063be26317e146103f1578063c8ecc0d3146103fa57600080fd5b806380d45a2d116100de57806380d45a2d146103835780638da5cb5b14610396578063a69bd19e146103a7578063aac59a75146103ba57600080fd5b806377d4937f1461035557806379ba5097146103685780637b77cd6a1461037057600080fd5b80633421fc521161017c5780635f30e37b1161014b5780635f30e37b146103145780636fb0527514610327578063715018a61461033a578063746460a91461034257600080fd5b80633421fc5214610293578063362b6795146102ba578063439b5517146102e15780634dd9584a1461030157600080fd5b806324558995116101b85780632455899514610246578063258836fe1461025a5780632a1d05471461026d5780632e6881411461028057600080fd5b80630a9837c5146101df5780630e32cb861461020557806319b1faef1461021a575b600080fd5b6101f26101ed366004612779565b610463565b6040519081526020015b60405180910390f35b6102186102133660046127a5565b610632565b005b61012e5461022e906001600160a01b031681565b6040516001600160a01b0390911681526020016101fc565b61012f5461022e906001600160a01b031681565b6102186102683660046127c2565b610646565b61021861027b3660046127fb565b6107d7565b61021861028e3660046127a5565b6109c8565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f26102ef3660046127a5565b60c96020526000908152604090205481565b61021861030f3660046127a5565b610acd565b6101f26103223660046128a2565b610b31565b6101f26103353660046127c2565b611085565b61021861113b565b610218610350366004612945565b61114f565b6102186103633660046127a5565b6111f4565b610218611258565b61021861037e3660046127a5565b6112cf565b610218610391366004612945565b611332565b6033546001600160a01b031661022e565b6101f26103b53660046127a5565b611343565b6102186103c83660046127c2565b61142f565b60cb5461022e906001600160a01b031681565b6097546001600160a01b031661022e565b6101f260fb5481565b61012d5461022e906001600160a01b031681565b6065546001600160a01b031661022e565b61021861042d3660046127a5565b61143d565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f26101305481565b6000600260cc54036104905760405162461bcd60e51b81526004016104879061295e565b60405180910390fd5b600260cc5561012e546001600160a01b03163381146105085760405162461bcd60e51b815260206004820152602e60248201527f5269736b2066756e643a204f6e6c792063616c6c61626c652062792053686f7260448201526d1d19985b1b0818dbdb9d1c9858dd60921b6064820152608401610487565b6001600160a01b03808516600090815260ca6020908152604080832061012d549094168352929052205483111561058f5760405162461bcd60e51b815260206004820152602560248201527f5269736b2046756e643a20496e73756666696369656e7420706f6f6c2072657360448201526432b93b329760d91b6064820152608401610487565b6001600160a01b03808516600081815260ca6020908152604080832061012d80548716855290835281842080548a9003905554909416825260c990528290208054869003905590517fc8d0a37ed16dfaa43514df00e18f478b60d5cc7b4bfc687103948b9020f737fd906106069086815260200190565b60405180910390a261012d54610626906001600160a01b031682856114ae565b5050600160cc55919050565b61063a611505565b6106438161155f565b50565b61064e611505565b600260cc54036106705760405162461bcd60e51b81526004016104879061295e565b600260cc5561067e8161161d565b6040516370a0823160e01b815230600482015260009081906001600160a01b038516906370a0823190602401602060405180830381865afa1580156106c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106eb9190612982565b6001600160a01b038516600090815260c9602052604090205490915081116107615760405162461bcd60e51b815260206004820152602360248201527f5265736572766548656c706572733a205a65726f20737572706c757320746f6b604482015262656e7360e81b6064820152608401610487565b6001600160a01b03848116600081815260c960209081526040918290205491519185038083529550928616927f6d25be279134f4ecaa4770aff0c3d916d9e7c5ef37b65ed95dbdba411f5d54d5910160405180910390a36107cc6001600160a01b03851684846114ae565b5050600160cc555050565b600054610100900460ff16158080156107f75750600054600160ff909116105b806108115750303b158015610811575060005460ff166001145b6108745760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610487565b6000805460ff191660011790558015610897576000805461ff0019166101001790555b6108a08661161d565b6108a98461161d565b600085116108c95760405162461bcd60e51b81526004016104879061299b565b600082116109285760405162461bcd60e51b815260206004820152602660248201527f5269736b2046756e643a204c6f6f7073206c696d69742063616e206e6f74206260448201526565207a65726f60d01b6064820152608401610487565b610930611644565b61093983611673565b61012f80546001600160a01b038089166001600160a01b03199283161790925561013087905561012d80549287169290911691909117905561097a8261169a565b80156109c0576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050565b610a066040518060400160405280602081526020017f736574436f6e7665727469626c65426173654173736574286164647265737329815250611734565b6001600160a01b038116610a7a5760405162461bcd60e51b815260206004820152603560248201527f5269736b2046756e643a206e657720636f6e7665727469626c65206261736520604482015274185cdcd95d081859191c995cdcc81a5b9d985b1a59605a1b6064820152608401610487565b61012d80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f5fa61583da12070720613fefdd68cc6c0e464a71e009742526bd2b2e0ac62cd290600090a35050565b610ad5611505565b610ade8161161d565b61012f80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fd37b9d138f53ea58d7e50292588239a46efa8f523966febf4066da96defc77fd90600090a35050565b6000600260cc5403610b555760405162461bcd60e51b81526004016104879061295e565b600260cc81905550610b7e60405180606001604052806038815260200161302960389139611734565b42821015610bce5760405162461bcd60e51b815260206004820152601a60248201527f5269736b2066756e643a20646561646c696e65207061737365640000000000006044820152606401610487565b60cb546001600160a01b0316610be38161161d565b878614610c585760405162461bcd60e51b815260206004820152603860248201527f5269736b2066756e643a206d61726b65747320616e6420616d6f756e74734f7560448201527f744d696e2061726520756e657175616c206c656e6774687300000000000000006064820152608401610487565b878414610cc05760405162461bcd60e51b815260206004820152603060248201527f5269736b2066756e643a206d61726b65747320616e642070617468732061726560448201526f20756e657175616c206c656e6774687360801b6064820152608401610487565b600088610ccc816117ce565b60005b818110156110325760008c8c83818110610ceb57610ceb6129e3565b9050602002016020810190610d0091906127a5565b6001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6191906129f9565b604051637aee632d60e01b81526001600160a01b038083166004830152919250600091871690637aee632d90602401600060405180830381865afa158015610dad573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610dd59190810190612ac6565b9050816001600160a01b031681604001516001600160a01b031614610e4c5760405162461bcd60e51b815260206004820152602760248201527f636f6d7074726f6c6c657220646f65736e277420657869737420706f6f6c20726044820152666567697374727960c81b6064820152608401610487565b816001600160a01b0316633d98a1e58f8f86818110610e6d57610e6d6129e3565b9050602002016020810190610e8291906127a5565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610ec6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eea9190612bbc565b610f2d5760405162461bcd60e51b81526020600482015260146024820152731b585c9ad95d081a5cc81b9bdd081b1a5cdd195960621b6044820152606401610487565b6000610f9c8f8f86818110610f4457610f446129e3565b9050602002016020810190610f5991906127a5565b848f8f88818110610f6c57610f6c6129e3565b905060200201358e8e89818110610f8557610f856129e3565b9050602002810190610f979190612bde565b6117ff565b6001600160a01b03808516600090815260ca6020908152604080832061012d54909416835292905290812080549293508392909190610fdc908490612c3e565b909155505061012d546001600160a01b0316600090815260c960205260408120805483929061100c908490612c3e565b9091555061101c90508187612c3e565b95505050508061102b90612c56565b9050610ccf565b507fb17530966b045b50d4975e7f05048ca00d7335780c24f1c465165a4b94b2d37d8b8b8b8b8660405161106a959493929190612cb8565b60405180910390a150600160cc559998505050505050505050565b60006110908261161d565b826001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110f19190612bbc565b61110d5760405162461bcd60e51b815260040161048790612d13565b506001600160a01b03808316600090815260ca60209081526040808320938516835292905220545b92915050565b611143611505565b61114d6000611da2565b565b61118d6040518060400160405280601e81526020017f7365744d696e416d6f756e74546f436f6e766572742875696e74323536290000815250611734565b600081116111ad5760405162461bcd60e51b81526004016104879061299b565b61013080549082905560408051828152602081018490527fada67d0d38fa20c8ae6a5c17cb9d60b0fe7f2d4e4f27ac9ee55e54ac88de9d8d91015b60405180910390a15050565b6111fc611505565b6112058161161d565b61012e80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fb6e5fcf02f7fbb8acfbaa3bac4fd5abf9ff51e3f2e8884b5498927179b211b2890600090a35050565b60655433906001600160a01b031681146112c65760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610487565b61064381611da2565b6112d7611505565b6112e08161161d565b60cb80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fa87b964d321035d2165e484ff4b722dd6eae30606c0b98887d2ed1a34e594bfe90600090a35050565b61133a611505565b6106438161169a565b6000816001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa158015611382573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a69190612bbc565b6114015760405162461bcd60e51b815260206004820152602660248201527f5269736b2046756e643a20436f6d7074726f6c6c6572206164647265737320696044820152651b9d985b1a5960d21b6064820152608401610487565b506001600160a01b03908116600090815260ca6020908152604080832061012d549094168352929052205490565b6114398282611dbb565b5050565b611445611505565b606580546001600160a01b0383166001600160a01b031990911681179091556114766033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052611500908490612078565b505050565b6033546001600160a01b0316331461114d5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610487565b6001600160a01b0381166115c35760405162461bcd60e51b815260206004820152602560248201527f696e76616c696420616365737320636f6e74726f6c206d616e61676572206164604482015264647265737360d81b6064820152608401610487565b609780546001600160a01b038381166001600160a01b031983168117909355604080519190921680825260208201939093527f66fd58e82f7b31a2a5c30e0888f3093efe4e111b00cd2b0c31fe014601293aa091016111e8565b6001600160a01b038116610643576040516342bcdf7f60e11b815260040160405180910390fd5b600054610100900460ff1661166b5760405162461bcd60e51b815260040161048790612d5e565b61114d61214d565b600054610100900460ff1661063a5760405162461bcd60e51b815260040161048790612d5e565b60fb5481116116f65760405162461bcd60e51b815260206004820152602260248201527f436f6d7074726f6c6c65723a20496e76616c6964206d61784c6f6f70734c696d6044820152611a5d60f21b6064820152608401610487565b60fb80549082905560408051828152602081018490527fc2d09fef144f7c8a86f71ea459f8fc17f675768eb1ae369cbd77fb31d467aafa91016111e8565b6097546040516318c5e8ab60e01b81526000916001600160a01b0316906318c5e8ab906117679033908690600401612dd5565b602060405180830381865afa158015611784573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a89190612bbc565b90508061143957333083604051634a3fa29360e01b815260040161048793929190612df9565b60fb548111156106435760fb5460405163792bfb1b60e11b8152600481019190915260248101829052604401610487565b6000836000036118775760405162461bcd60e51b815260206004820152603c60248201527f5269736b46756e643a20616d6f756e744f75744d696e206d757374206265206760448201527f726561746572207468616e203020746f20737761702076546f6b656e000000006064820152608401610487565b600080876001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156118b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118dc91906129f9565b61012d546001600160a01b03898116600090815260ca60209081526040808320848716845290915281205493945091169190819003611922576000945050505050611d99565b6000896001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611962573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061198691906129f9565b60405163b62cad6960e01b81526001600160a01b0385811660048301529192509082169063b62cad6990602401600060405180830381600087803b1580156119cd57600080fd5b505af11580156119e1573d6000803e3d6000fd5b50506040805160208101918290526341976e0960e01b9091526001600160a01b03868116602483015260009350909150819084166341976e0960448301602060405180830381865afa158015611a3b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a5f9190612982565b905290506000611a6f828c61217d565b905061013054811015611ad25760405162461bcd60e51b815260206004820152602560248201527f5269736b46756e643a206d696e416d6f756e74546f436f6e766572742076696f6044820152641b185d195960da1b6064820152608401610487565b6001600160a01b038616600090815260c9602052604081208054869290611afa908490612e25565b90915550506001600160a01b03808d16600090815260ca60209081526040808320938a1683529290529081208054869290611b36908490612e25565b90915550506001600160a01b0386811690861614611d8b57856001600160a01b03168a8a6000818110611b6b57611b6b6129e3565b9050602002016020810190611b8091906127a5565b6001600160a01b031614611bfc5760405162461bcd60e51b815260206004820152603860248201527f5269736b46756e643a20737761702070617468206d757374207374617274207760448201527f6974682074686520756e6465726c79696e6720617373657400000000000000006064820152608401610487565b6001600160a01b0385168a8a611c13600182612e25565b818110611c2257611c226129e3565b9050602002016020810190611c3791906127a5565b6001600160a01b031614611cab5760405162461bcd60e51b815260206004820152603560248201527f5269736b46756e643a2066696e616c6c792070617468206d75737420626520636044820152741bdb9d995c9d1a589b194818985cd948185cdcd95d605a1b6064820152608401610487565b61012f546001600160a01b0390811690611cc990881682600061219d565b611cdd6001600160a01b038816828761219d565b6000816001600160a01b03166338ed1739878f8f8f30426040518763ffffffff1660e01b8152600401611d1596959493929190612e3c565b6000604051808303816000875af1158015611d34573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d5c9190810190612e9e565b905080611d6a60018d612e25565b81518110611d7a57611d7a6129e3565b602002602001015198505050611d8f565b8396505b5094955050505050505b95945050505050565b606580546001600160a01b031916905561064381612289565b611dc48161161d565b816001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa158015611e01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e259190612bbc565b611e415760405162461bcd60e51b815260040161048790612d13565b60cb546001600160a01b031680611eb35760405162461bcd60e51b815260206004820152603060248201527f5265736572766548656c706572733a20506f6f6c20526567697374727920616460448201526f191c995cdcc81a5cc81b9bdd081cd95d60821b6064820152608401610487565b611ebd83836122db565b611f245760405162461bcd60e51b815260206004820152603260248201527f5265736572766548656c706572733a2054686520706f6f6c20646f65736e2774604482015271081cdd5c1c1bdc9d081d1a1948185cdcd95d60721b6064820152608401610487565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015611f6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8f9190612982565b6001600160a01b038416600090815260c9602052604090205490915080821115612071576001600160a01b038416600090815260c960205260408120805483850392839291611fdf908490612c3e565b90915550506001600160a01b03808716600090815260ca602090815260408083209389168352929052908120805483929061201b908490612c3e565b92505081905550846001600160a01b0316866001600160a01b03167fc39e3e80c0219fde334a8cb5d8468b628482e23388b6e809c90cb00c63c8ce388360405161206791815260200190565b60405180910390a3505b5050505050565b60006120cd826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166123af9092919063ffffffff16565b90508051600014806120ee5750808060200190518101906120ee9190612bbc565b6115005760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610487565b600054610100900460ff166121745760405162461bcd60e51b815260040161048790612d5e565b61114d33611da2565b60008061218a84846123be565b9050612195816123ef565b949350505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663095ea7b360e01b1790529151909160009182918716906121fb908590612f29565b6000604051808303816000865af19150503d8060008114612238576040519150601f19603f3d011682016040523d82523d6000602084013e61223d565b606091505b509150915081158061226b575080511580159061226b5750808060200190518101906122699190612bbc565b155b156109c057604051633e3f8f7360e01b815260040160405180910390fd5b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b0316036123265761231f82612407565b9050611135565b60cb5460405163266e0a7f60e01b81526001600160a01b0385811660048301528481166024830152600092169063266e0a7f90604401602060405180830381865afa158015612379573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061239d91906129f9565b6001600160a01b031614159392505050565b606061219584846000856125d8565b60408051602081019091526000815260405180602001604052806123e68560000151856126b3565b90529392505050565b805160009061113590670de0b6b3a764000090612f45565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015612468573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124909190810190612f67565b905060005b81518110156125d1578181815181106124b0576124b06129e3565b60200260200101516001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461258457836001600160a01b031682828151811061250c5761250c6129e3565b60200260200101516001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa158015612551573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061257591906129f9565b6001600160a01b0316146125ba565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b0316145b9250826125d1576125ca81612c56565b9050612495565b5050919050565b6060824710156126395760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610487565b600080866001600160a01b031685876040516126559190612f29565b60006040518083038185875af1925050503d8060008114612692576040519150601f19603f3d011682016040523d82523d6000602084013e612697565b606091505b50915091506126a8878383876126c6565b979650505050505050565b60006126bf8284612ff6565b9392505050565b6060831561273557825160000361272e576001600160a01b0385163b61272e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610487565b5081612195565b612195838381511561274a5781518083602001fd5b8060405162461bcd60e51b81526004016104879190613015565b6001600160a01b038116811461064357600080fd5b6000806040838503121561278c57600080fd5b823561279781612764565b946020939093013593505050565b6000602082840312156127b757600080fd5b81356126bf81612764565b600080604083850312156127d557600080fd5b82356127e081612764565b915060208301356127f081612764565b809150509250929050565b600080600080600060a0868803121561281357600080fd5b853561281e81612764565b945060208601359350604086013561283581612764565b9250606086013561284581612764565b949793965091946080013592915050565b60008083601f84011261286857600080fd5b50813567ffffffffffffffff81111561288057600080fd5b6020830191508360208260051b850101111561289b57600080fd5b9250929050565b60008060008060008060006080888a0312156128bd57600080fd5b873567ffffffffffffffff808211156128d557600080fd5b6128e18b838c01612856565b909950975060208a01359150808211156128fa57600080fd5b6129068b838c01612856565b909750955060408a013591508082111561291f57600080fd5b5061292c8a828b01612856565b989b979a50959894979596606090950135949350505050565b60006020828403121561295757600080fd5b5035919050565b6020808252600a90820152691c994b595b9d195c995960b21b604082015260600190565b60006020828403121561299457600080fd5b5051919050565b60208082526028908201527f5269736b2046756e643a20496e76616c6964206d696e20616d6f756e7420746f6040820152670818dbdb9d995c9d60c21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612a0b57600080fd5b81516126bf81612764565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715612a4f57612a4f612a16565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715612a7e57612a7e612a16565b604052919050565b60005b83811015612aa1578181015183820152602001612a89565b83811115612ab0576000848401525b50505050565b8051612ac181612764565b919050565b60006020808385031215612ad957600080fd5b825167ffffffffffffffff80821115612af157600080fd5b9084019060a08287031215612b0557600080fd5b612b0d612a2c565b825182811115612b1c57600080fd5b8301601f81018813612b2d57600080fd5b805183811115612b3f57612b3f612a16565b612b51601f8201601f19168701612a55565b93508084528886828401011115612b6757600080fd5b612b7681878601888501612a86565b5050818152612b86848401612ab6565b84820152612b9660408401612ab6565b604082015260608301516060820152608083015160808201528094505050505092915050565b600060208284031215612bce57600080fd5b815180151581146126bf57600080fd5b6000808335601e19843603018112612bf557600080fd5b83018035915067ffffffffffffffff821115612c1057600080fd5b6020019150600581901b360382131561289b57600080fd5b634e487b7160e01b600052601160045260246000fd5b60008219821115612c5157612c51612c28565b500190565b600060018201612c6857612c68612c28565b5060010190565b8183526000602080850194508260005b85811015612cad578135612c9281612764565b6001600160a01b031687529582019590820190600101612c7f565b509495945050505050565b606081526000612ccc606083018789612c6f565b82810360208401528481526001600160fb1b03851115612ceb57600080fd5b8460051b80876020840137600091016020019081526040929092019290925295945050505050565b6020808252602b908201527f5265736572766548656c706572733a20436f6d7074726f6c6c6572206164647260408201526a195cdcc81a5b9d985b1a5960aa1b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60008151808452612dc1816020860160208601612a86565b601f01601f19169290920160200192915050565b6001600160a01b038316815260406020820181905260009061219590830184612da9565b6001600160a01b03848116825283166020820152606060408201819052600090611d9990830184612da9565b600082821015612e3757612e37612c28565b500390565b86815285602082015260a060408201526000612e5c60a083018688612c6f565b6001600160a01b039490941660608301525060800152949350505050565b600067ffffffffffffffff821115612e9457612e94612a16565b5060051b60200190565b60006020808385031215612eb157600080fd5b825167ffffffffffffffff811115612ec857600080fd5b8301601f81018513612ed957600080fd5b8051612eec612ee782612e7a565b612a55565b81815260059190911b82018301908381019087831115612f0b57600080fd5b928401925b828410156126a857835182529284019290840190612f10565b60008251612f3b818460208701612a86565b9190910192915050565b600082612f6257634e487b7160e01b600052601260045260246000fd5b500490565b60006020808385031215612f7a57600080fd5b825167ffffffffffffffff811115612f9157600080fd5b8301601f81018513612fa257600080fd5b8051612fb0612ee782612e7a565b81815260059190911b82018301908381019087831115612fcf57600080fd5b928401925b828410156126a8578351612fe781612764565b82529284019290840190612fd4565b600081600019048311821515161561301057613010612c28565b500290565b6020815260006126bf6020830184612da956fe73776170506f6f6c7341737365747328616464726573735b5d2c75696e743235365b5d2c616464726573735b5d5b5d2c75696e7432353629a2646970667358221220c967afe4ee07c007702bfe8b40ad090042c372456a0a152775ad412949fc6bc564736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101da5760003560e01c806377d4937f11610104578063afcff50f116100a2578063e30c397811610071578063e30c39781461040e578063f2fde38b1461041f578063fa7b81a014610432578063fe3da9841461045957600080fd5b8063afcff50f146103cd578063b4a0bdf3146103e0578063be26317e146103f1578063c8ecc0d3146103fa57600080fd5b806380d45a2d116100de57806380d45a2d146103835780638da5cb5b14610396578063a69bd19e146103a7578063aac59a75146103ba57600080fd5b806377d4937f1461035557806379ba5097146103685780637b77cd6a1461037057600080fd5b80633421fc521161017c5780635f30e37b1161014b5780635f30e37b146103145780636fb0527514610327578063715018a61461033a578063746460a91461034257600080fd5b80633421fc5214610293578063362b6795146102ba578063439b5517146102e15780634dd9584a1461030157600080fd5b806324558995116101b85780632455899514610246578063258836fe1461025a5780632a1d05471461026d5780632e6881411461028057600080fd5b80630a9837c5146101df5780630e32cb861461020557806319b1faef1461021a575b600080fd5b6101f26101ed366004612779565b610463565b6040519081526020015b60405180910390f35b6102186102133660046127a5565b610632565b005b61012e5461022e906001600160a01b031681565b6040516001600160a01b0390911681526020016101fc565b61012f5461022e906001600160a01b031681565b6102186102683660046127c2565b610646565b61021861027b3660046127fb565b6107d7565b61021861028e3660046127a5565b6109c8565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f26102ef3660046127a5565b60c96020526000908152604090205481565b61021861030f3660046127a5565b610acd565b6101f26103223660046128a2565b610b31565b6101f26103353660046127c2565b611085565b61021861113b565b610218610350366004612945565b61114f565b6102186103633660046127a5565b6111f4565b610218611258565b61021861037e3660046127a5565b6112cf565b610218610391366004612945565b611332565b6033546001600160a01b031661022e565b6101f26103b53660046127a5565b611343565b6102186103c83660046127c2565b61142f565b60cb5461022e906001600160a01b031681565b6097546001600160a01b031661022e565b6101f260fb5481565b61012d5461022e906001600160a01b031681565b6065546001600160a01b031661022e565b61021861042d3660046127a5565b61143d565b61022e7f000000000000000000000000000000000000000000000000000000000000000081565b6101f26101305481565b6000600260cc54036104905760405162461bcd60e51b81526004016104879061295e565b60405180910390fd5b600260cc5561012e546001600160a01b03163381146105085760405162461bcd60e51b815260206004820152602e60248201527f5269736b2066756e643a204f6e6c792063616c6c61626c652062792053686f7260448201526d1d19985b1b0818dbdb9d1c9858dd60921b6064820152608401610487565b6001600160a01b03808516600090815260ca6020908152604080832061012d549094168352929052205483111561058f5760405162461bcd60e51b815260206004820152602560248201527f5269736b2046756e643a20496e73756666696369656e7420706f6f6c2072657360448201526432b93b329760d91b6064820152608401610487565b6001600160a01b03808516600081815260ca6020908152604080832061012d80548716855290835281842080548a9003905554909416825260c990528290208054869003905590517fc8d0a37ed16dfaa43514df00e18f478b60d5cc7b4bfc687103948b9020f737fd906106069086815260200190565b60405180910390a261012d54610626906001600160a01b031682856114ae565b5050600160cc55919050565b61063a611505565b6106438161155f565b50565b61064e611505565b600260cc54036106705760405162461bcd60e51b81526004016104879061295e565b600260cc5561067e8161161d565b6040516370a0823160e01b815230600482015260009081906001600160a01b038516906370a0823190602401602060405180830381865afa1580156106c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106eb9190612982565b6001600160a01b038516600090815260c9602052604090205490915081116107615760405162461bcd60e51b815260206004820152602360248201527f5265736572766548656c706572733a205a65726f20737572706c757320746f6b604482015262656e7360e81b6064820152608401610487565b6001600160a01b03848116600081815260c960209081526040918290205491519185038083529550928616927f6d25be279134f4ecaa4770aff0c3d916d9e7c5ef37b65ed95dbdba411f5d54d5910160405180910390a36107cc6001600160a01b03851684846114ae565b5050600160cc555050565b600054610100900460ff16158080156107f75750600054600160ff909116105b806108115750303b158015610811575060005460ff166001145b6108745760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610487565b6000805460ff191660011790558015610897576000805461ff0019166101001790555b6108a08661161d565b6108a98461161d565b600085116108c95760405162461bcd60e51b81526004016104879061299b565b600082116109285760405162461bcd60e51b815260206004820152602660248201527f5269736b2046756e643a204c6f6f7073206c696d69742063616e206e6f74206260448201526565207a65726f60d01b6064820152608401610487565b610930611644565b61093983611673565b61012f80546001600160a01b038089166001600160a01b03199283161790925561013087905561012d80549287169290911691909117905561097a8261169a565b80156109c0576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050565b610a066040518060400160405280602081526020017f736574436f6e7665727469626c65426173654173736574286164647265737329815250611734565b6001600160a01b038116610a7a5760405162461bcd60e51b815260206004820152603560248201527f5269736b2046756e643a206e657720636f6e7665727469626c65206261736520604482015274185cdcd95d081859191c995cdcc81a5b9d985b1a59605a1b6064820152608401610487565b61012d80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f5fa61583da12070720613fefdd68cc6c0e464a71e009742526bd2b2e0ac62cd290600090a35050565b610ad5611505565b610ade8161161d565b61012f80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fd37b9d138f53ea58d7e50292588239a46efa8f523966febf4066da96defc77fd90600090a35050565b6000600260cc5403610b555760405162461bcd60e51b81526004016104879061295e565b600260cc81905550610b7e60405180606001604052806038815260200161302960389139611734565b42821015610bce5760405162461bcd60e51b815260206004820152601a60248201527f5269736b2066756e643a20646561646c696e65207061737365640000000000006044820152606401610487565b60cb546001600160a01b0316610be38161161d565b878614610c585760405162461bcd60e51b815260206004820152603860248201527f5269736b2066756e643a206d61726b65747320616e6420616d6f756e74734f7560448201527f744d696e2061726520756e657175616c206c656e6774687300000000000000006064820152608401610487565b878414610cc05760405162461bcd60e51b815260206004820152603060248201527f5269736b2066756e643a206d61726b65747320616e642070617468732061726560448201526f20756e657175616c206c656e6774687360801b6064820152608401610487565b600088610ccc816117ce565b60005b818110156110325760008c8c83818110610ceb57610ceb6129e3565b9050602002016020810190610d0091906127a5565b6001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6191906129f9565b604051637aee632d60e01b81526001600160a01b038083166004830152919250600091871690637aee632d90602401600060405180830381865afa158015610dad573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610dd59190810190612ac6565b9050816001600160a01b031681604001516001600160a01b031614610e4c5760405162461bcd60e51b815260206004820152602760248201527f636f6d7074726f6c6c657220646f65736e277420657869737420706f6f6c20726044820152666567697374727960c81b6064820152608401610487565b816001600160a01b0316633d98a1e58f8f86818110610e6d57610e6d6129e3565b9050602002016020810190610e8291906127a5565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610ec6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eea9190612bbc565b610f2d5760405162461bcd60e51b81526020600482015260146024820152731b585c9ad95d081a5cc81b9bdd081b1a5cdd195960621b6044820152606401610487565b6000610f9c8f8f86818110610f4457610f446129e3565b9050602002016020810190610f5991906127a5565b848f8f88818110610f6c57610f6c6129e3565b905060200201358e8e89818110610f8557610f856129e3565b9050602002810190610f979190612bde565b6117ff565b6001600160a01b03808516600090815260ca6020908152604080832061012d54909416835292905290812080549293508392909190610fdc908490612c3e565b909155505061012d546001600160a01b0316600090815260c960205260408120805483929061100c908490612c3e565b9091555061101c90508187612c3e565b95505050508061102b90612c56565b9050610ccf565b507fb17530966b045b50d4975e7f05048ca00d7335780c24f1c465165a4b94b2d37d8b8b8b8b8660405161106a959493929190612cb8565b60405180910390a150600160cc559998505050505050505050565b60006110908261161d565b826001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110f19190612bbc565b61110d5760405162461bcd60e51b815260040161048790612d13565b506001600160a01b03808316600090815260ca60209081526040808320938516835292905220545b92915050565b611143611505565b61114d6000611da2565b565b61118d6040518060400160405280601e81526020017f7365744d696e416d6f756e74546f436f6e766572742875696e74323536290000815250611734565b600081116111ad5760405162461bcd60e51b81526004016104879061299b565b61013080549082905560408051828152602081018490527fada67d0d38fa20c8ae6a5c17cb9d60b0fe7f2d4e4f27ac9ee55e54ac88de9d8d91015b60405180910390a15050565b6111fc611505565b6112058161161d565b61012e80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fb6e5fcf02f7fbb8acfbaa3bac4fd5abf9ff51e3f2e8884b5498927179b211b2890600090a35050565b60655433906001600160a01b031681146112c65760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610487565b61064381611da2565b6112d7611505565b6112e08161161d565b60cb80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fa87b964d321035d2165e484ff4b722dd6eae30606c0b98887d2ed1a34e594bfe90600090a35050565b61133a611505565b6106438161169a565b6000816001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa158015611382573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a69190612bbc565b6114015760405162461bcd60e51b815260206004820152602660248201527f5269736b2046756e643a20436f6d7074726f6c6c6572206164647265737320696044820152651b9d985b1a5960d21b6064820152608401610487565b506001600160a01b03908116600090815260ca6020908152604080832061012d549094168352929052205490565b6114398282611dbb565b5050565b611445611505565b606580546001600160a01b0383166001600160a01b031990911681179091556114766033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052611500908490612078565b505050565b6033546001600160a01b0316331461114d5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610487565b6001600160a01b0381166115c35760405162461bcd60e51b815260206004820152602560248201527f696e76616c696420616365737320636f6e74726f6c206d616e61676572206164604482015264647265737360d81b6064820152608401610487565b609780546001600160a01b038381166001600160a01b031983168117909355604080519190921680825260208201939093527f66fd58e82f7b31a2a5c30e0888f3093efe4e111b00cd2b0c31fe014601293aa091016111e8565b6001600160a01b038116610643576040516342bcdf7f60e11b815260040160405180910390fd5b600054610100900460ff1661166b5760405162461bcd60e51b815260040161048790612d5e565b61114d61214d565b600054610100900460ff1661063a5760405162461bcd60e51b815260040161048790612d5e565b60fb5481116116f65760405162461bcd60e51b815260206004820152602260248201527f436f6d7074726f6c6c65723a20496e76616c6964206d61784c6f6f70734c696d6044820152611a5d60f21b6064820152608401610487565b60fb80549082905560408051828152602081018490527fc2d09fef144f7c8a86f71ea459f8fc17f675768eb1ae369cbd77fb31d467aafa91016111e8565b6097546040516318c5e8ab60e01b81526000916001600160a01b0316906318c5e8ab906117679033908690600401612dd5565b602060405180830381865afa158015611784573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a89190612bbc565b90508061143957333083604051634a3fa29360e01b815260040161048793929190612df9565b60fb548111156106435760fb5460405163792bfb1b60e11b8152600481019190915260248101829052604401610487565b6000836000036118775760405162461bcd60e51b815260206004820152603c60248201527f5269736b46756e643a20616d6f756e744f75744d696e206d757374206265206760448201527f726561746572207468616e203020746f20737761702076546f6b656e000000006064820152608401610487565b600080876001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156118b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118dc91906129f9565b61012d546001600160a01b03898116600090815260ca60209081526040808320848716845290915281205493945091169190819003611922576000945050505050611d99565b6000896001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611962573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061198691906129f9565b60405163b62cad6960e01b81526001600160a01b0385811660048301529192509082169063b62cad6990602401600060405180830381600087803b1580156119cd57600080fd5b505af11580156119e1573d6000803e3d6000fd5b50506040805160208101918290526341976e0960e01b9091526001600160a01b03868116602483015260009350909150819084166341976e0960448301602060405180830381865afa158015611a3b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a5f9190612982565b905290506000611a6f828c61217d565b905061013054811015611ad25760405162461bcd60e51b815260206004820152602560248201527f5269736b46756e643a206d696e416d6f756e74546f436f6e766572742076696f6044820152641b185d195960da1b6064820152608401610487565b6001600160a01b038616600090815260c9602052604081208054869290611afa908490612e25565b90915550506001600160a01b03808d16600090815260ca60209081526040808320938a1683529290529081208054869290611b36908490612e25565b90915550506001600160a01b0386811690861614611d8b57856001600160a01b03168a8a6000818110611b6b57611b6b6129e3565b9050602002016020810190611b8091906127a5565b6001600160a01b031614611bfc5760405162461bcd60e51b815260206004820152603860248201527f5269736b46756e643a20737761702070617468206d757374207374617274207760448201527f6974682074686520756e6465726c79696e6720617373657400000000000000006064820152608401610487565b6001600160a01b0385168a8a611c13600182612e25565b818110611c2257611c226129e3565b9050602002016020810190611c3791906127a5565b6001600160a01b031614611cab5760405162461bcd60e51b815260206004820152603560248201527f5269736b46756e643a2066696e616c6c792070617468206d75737420626520636044820152741bdb9d995c9d1a589b194818985cd948185cdcd95d605a1b6064820152608401610487565b61012f546001600160a01b0390811690611cc990881682600061219d565b611cdd6001600160a01b038816828761219d565b6000816001600160a01b03166338ed1739878f8f8f30426040518763ffffffff1660e01b8152600401611d1596959493929190612e3c565b6000604051808303816000875af1158015611d34573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d5c9190810190612e9e565b905080611d6a60018d612e25565b81518110611d7a57611d7a6129e3565b602002602001015198505050611d8f565b8396505b5094955050505050505b95945050505050565b606580546001600160a01b031916905561064381612289565b611dc48161161d565b816001600160a01b0316627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa158015611e01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e259190612bbc565b611e415760405162461bcd60e51b815260040161048790612d13565b60cb546001600160a01b031680611eb35760405162461bcd60e51b815260206004820152603060248201527f5265736572766548656c706572733a20506f6f6c20526567697374727920616460448201526f191c995cdcc81a5cc81b9bdd081cd95d60821b6064820152608401610487565b611ebd83836122db565b611f245760405162461bcd60e51b815260206004820152603260248201527f5265736572766548656c706572733a2054686520706f6f6c20646f65736e2774604482015271081cdd5c1c1bdc9d081d1a1948185cdcd95d60721b6064820152608401610487565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015611f6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8f9190612982565b6001600160a01b038416600090815260c9602052604090205490915080821115612071576001600160a01b038416600090815260c960205260408120805483850392839291611fdf908490612c3e565b90915550506001600160a01b03808716600090815260ca602090815260408083209389168352929052908120805483929061201b908490612c3e565b92505081905550846001600160a01b0316866001600160a01b03167fc39e3e80c0219fde334a8cb5d8468b628482e23388b6e809c90cb00c63c8ce388360405161206791815260200190565b60405180910390a3505b5050505050565b60006120cd826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166123af9092919063ffffffff16565b90508051600014806120ee5750808060200190518101906120ee9190612bbc565b6115005760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610487565b600054610100900460ff166121745760405162461bcd60e51b815260040161048790612d5e565b61114d33611da2565b60008061218a84846123be565b9050612195816123ef565b949350505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663095ea7b360e01b1790529151909160009182918716906121fb908590612f29565b6000604051808303816000865af19150503d8060008114612238576040519150601f19603f3d011682016040523d82523d6000602084013e61223d565b606091505b509150915081158061226b575080511580159061226b5750808060200190518101906122699190612bbc565b155b156109c057604051633e3f8f7360e01b815260040160405180910390fd5b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b0316036123265761231f82612407565b9050611135565b60cb5460405163266e0a7f60e01b81526001600160a01b0385811660048301528481166024830152600092169063266e0a7f90604401602060405180830381865afa158015612379573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061239d91906129f9565b6001600160a01b031614159392505050565b606061219584846000856125d8565b60408051602081019091526000815260405180602001604052806123e68560000151856126b3565b90529392505050565b805160009061113590670de0b6b3a764000090612f45565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015612468573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124909190810190612f67565b905060005b81518110156125d1578181815181106124b0576124b06129e3565b60200260200101516001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461258457836001600160a01b031682828151811061250c5761250c6129e3565b60200260200101516001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa158015612551573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061257591906129f9565b6001600160a01b0316146125ba565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b0316145b9250826125d1576125ca81612c56565b9050612495565b5050919050565b6060824710156126395760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610487565b600080866001600160a01b031685876040516126559190612f29565b60006040518083038185875af1925050503d8060008114612692576040519150601f19603f3d011682016040523d82523d6000602084013e612697565b606091505b50915091506126a8878383876126c6565b979650505050505050565b60006126bf8284612ff6565b9392505050565b6060831561273557825160000361272e576001600160a01b0385163b61272e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610487565b5081612195565b612195838381511561274a5781518083602001fd5b8060405162461bcd60e51b81526004016104879190613015565b6001600160a01b038116811461064357600080fd5b6000806040838503121561278c57600080fd5b823561279781612764565b946020939093013593505050565b6000602082840312156127b757600080fd5b81356126bf81612764565b600080604083850312156127d557600080fd5b82356127e081612764565b915060208301356127f081612764565b809150509250929050565b600080600080600060a0868803121561281357600080fd5b853561281e81612764565b945060208601359350604086013561283581612764565b9250606086013561284581612764565b949793965091946080013592915050565b60008083601f84011261286857600080fd5b50813567ffffffffffffffff81111561288057600080fd5b6020830191508360208260051b850101111561289b57600080fd5b9250929050565b60008060008060008060006080888a0312156128bd57600080fd5b873567ffffffffffffffff808211156128d557600080fd5b6128e18b838c01612856565b909950975060208a01359150808211156128fa57600080fd5b6129068b838c01612856565b909750955060408a013591508082111561291f57600080fd5b5061292c8a828b01612856565b989b979a50959894979596606090950135949350505050565b60006020828403121561295757600080fd5b5035919050565b6020808252600a90820152691c994b595b9d195c995960b21b604082015260600190565b60006020828403121561299457600080fd5b5051919050565b60208082526028908201527f5269736b2046756e643a20496e76616c6964206d696e20616d6f756e7420746f6040820152670818dbdb9d995c9d60c21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215612a0b57600080fd5b81516126bf81612764565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715612a4f57612a4f612a16565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715612a7e57612a7e612a16565b604052919050565b60005b83811015612aa1578181015183820152602001612a89565b83811115612ab0576000848401525b50505050565b8051612ac181612764565b919050565b60006020808385031215612ad957600080fd5b825167ffffffffffffffff80821115612af157600080fd5b9084019060a08287031215612b0557600080fd5b612b0d612a2c565b825182811115612b1c57600080fd5b8301601f81018813612b2d57600080fd5b805183811115612b3f57612b3f612a16565b612b51601f8201601f19168701612a55565b93508084528886828401011115612b6757600080fd5b612b7681878601888501612a86565b5050818152612b86848401612ab6565b84820152612b9660408401612ab6565b604082015260608301516060820152608083015160808201528094505050505092915050565b600060208284031215612bce57600080fd5b815180151581146126bf57600080fd5b6000808335601e19843603018112612bf557600080fd5b83018035915067ffffffffffffffff821115612c1057600080fd5b6020019150600581901b360382131561289b57600080fd5b634e487b7160e01b600052601160045260246000fd5b60008219821115612c5157612c51612c28565b500190565b600060018201612c6857612c68612c28565b5060010190565b8183526000602080850194508260005b85811015612cad578135612c9281612764565b6001600160a01b031687529582019590820190600101612c7f565b509495945050505050565b606081526000612ccc606083018789612c6f565b82810360208401528481526001600160fb1b03851115612ceb57600080fd5b8460051b80876020840137600091016020019081526040929092019290925295945050505050565b6020808252602b908201527f5265736572766548656c706572733a20436f6d7074726f6c6c6572206164647260408201526a195cdcc81a5b9d985b1a5960aa1b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60008151808452612dc1816020860160208601612a86565b601f01601f19169290920160200192915050565b6001600160a01b038316815260406020820181905260009061219590830184612da9565b6001600160a01b03848116825283166020820152606060408201819052600090611d9990830184612da9565b600082821015612e3757612e37612c28565b500390565b86815285602082015260a060408201526000612e5c60a083018688612c6f565b6001600160a01b039490941660608301525060800152949350505050565b600067ffffffffffffffff821115612e9457612e94612a16565b5060051b60200190565b60006020808385031215612eb157600080fd5b825167ffffffffffffffff811115612ec857600080fd5b8301601f81018513612ed957600080fd5b8051612eec612ee782612e7a565b612a55565b81815260059190911b82018301908381019087831115612f0b57600080fd5b928401925b828410156126a857835182529284019290840190612f10565b60008251612f3b818460208701612a86565b9190910192915050565b600082612f6257634e487b7160e01b600052601260045260246000fd5b500490565b60006020808385031215612f7a57600080fd5b825167ffffffffffffffff811115612f9157600080fd5b8301601f81018513612fa257600080fd5b8051612fb0612ee782612e7a565b81815260059190911b82018301908381019087831115612fcf57600080fd5b928401925b828410156126a8578351612fe781612764565b82529284019290840190612fd4565b600081600019048311821515161561301057613010612c28565b500290565b6020815260006126bf6020830184612da956fe73776170506f6f6c7341737365747328616464726573735b5d2c75696e743235365b5d2c616464726573735b5d5b5d2c75696e7432353629a2646970667358221220c967afe4ee07c007702bfe8b40ad090042c372456a0a152775ad412949fc6bc564736f6c634300080d0033",
  "devdoc": {
    "author": "Venus",
    "details": "This contract does not support BNB.",
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor",
        "details": "Note that the contract is upgradeable. Use initialize() or reinitializers      to set the state variables."
      },
      "getPoolAssetReserve(address,address)": {
        "custom:error": "ZeroAddressNotAllowed is thrown when asset address is zero",
        "params": {
          "asset": "Asset address.",
          "comptroller": "Comptroller address(pool)."
        },
        "returns": {
          "_0": "Asset's reserve in risk fund."
        }
      },
      "getPoolsBaseAssetReserves(address)": {
        "params": {
          "comptroller": "Comptroller address(pool)."
        },
        "returns": {
          "_0": "Base Asset's reserve in risk fund."
        }
      },
      "initialize(address,uint256,address,address,uint256)": {
        "custom:error": "ZeroAddressNotAllowed is thrown when PCS router address is zeroZeroAddressNotAllowed is thrown when convertible base asset address is zero",
        "params": {
          "accessControlManager_": "Address of the access control contract",
          "convertibleBaseAsset_": "Address of the base asset",
          "loopsLimit_": "Limit for the loops in the contract to avoid DOS",
          "minAmountToConvert_": "Minimum amount assets must be worth to convert into base asset",
          "pancakeSwapRouter_": "Address of the PancakeSwap router"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "setAccessControlManager(address)": {
        "custom:access": "Only Governance",
        "custom:event": "Emits NewAccessControlManager event",
        "details": "Admin function to set address of AccessControlManager",
        "params": {
          "accessControlManager_": "The new address of the AccessControlManager"
        }
      },
      "setConvertibleBaseAsset(address)": {
        "params": {
          "_convertibleBaseAsset": "Address for new convertible base asset."
        }
      },
      "setMaxLoopsLimit(uint256)": {
        "params": {
          "limit": "Limit for the max loops can execute at a time"
        }
      },
      "setMinAmountToConvert(uint256)": {
        "params": {
          "minAmountToConvert_": "Min amount to convert."
        }
      },
      "setPancakeSwapRouter(address)": {
        "custom:error": "ZeroAddressNotAllowed is thrown when PCS router address is zero",
        "params": {
          "pancakeSwapRouter_": "Address of the PancakeSwap router"
        }
      },
      "setPoolRegistry(address)": {
        "custom:error": "ZeroAddressNotAllowed is thrown when pool registry address is zero",
        "params": {
          "poolRegistry_": "Address of the pool registry"
        }
      },
      "setShortfallContractAddress(address)": {
        "custom:error": "ZeroAddressNotAllowed is thrown when shortfall contract address is zero",
        "params": {
          "shortfallContractAddress_": "Address of the auction contract"
        }
      },
      "swapPoolsAssets(address[],uint256[],address[][],uint256)": {
        "custom:error": "ZeroAddressNotAllowed is thrown if PoolRegistry contract address is not configured",
        "params": {
          "amountsOutMin": "Minimum amount to receive for swap",
          "deadline": "Deadline for the swap",
          "markets": "Array of vTokens whose assets to swap for base asset",
          "paths": "A path consisting of PCS token pairs for each swap"
        },
        "returns": {
          "_0": "Number of swapped tokens"
        }
      },
      "sweepToken(address,address)": {
        "custom:access": "Only Owner",
        "custom:error": "ZeroAddressNotAllowed is thrown when asset address is zero",
        "params": {
          "_to": "Recipient of the output tokens.",
          "_token": "The address of the BEP-20 token to sweep"
        }
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
      },
      "transferReserveForAuction(address,uint256)": {
        "params": {
          "amount": "Amount to be transferred to auction contract.",
          "comptroller": "Comptroller of the pool."
        },
        "returns": {
          "_0": "Number reserved tokens."
        }
      },
      "updateAssetsState(address,address)": {
        "params": {
          "asset": "Asset address.",
          "comptroller": "Comptroller address(pool)."
        }
      }
    },
    "title": "RiskFund",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ApproveFailed()": [
        {
          "notice": "Thrown if a contract is unable to approve a transfer"
        }
      ],
      "MaxLoopsLimitExceeded(uint256,uint256)": [
        {
          "notice": "Thrown an error on maxLoopsLimit exceeds for any loop"
        }
      ],
      "Unauthorized(address,address,string)": [
        {
          "notice": "Thrown when the action is prohibited by AccessControlManager"
        }
      ],
      "ZeroAddressNotAllowed()": [
        {
          "notice": "Thrown if the supplied address is a zero address where it is not allowed"
        }
      ]
    },
    "events": {
      "AssetsReservesUpdated(address,address,uint256)": {
        "notice": "Event emitted after the update of the assets reserves."
      },
      "ConvertibleBaseAssetUpdated(address,address)": {
        "notice": "Emitted when convertible base asset is updated"
      },
      "MaxLoopsLimitUpdated(uint256,uint256)": {
        "notice": "Emitted when max loops limit is set"
      },
      "MinAmountToConvertUpdated(uint256,uint256)": {
        "notice": "Emitted when minimum amount to convert is updated"
      },
      "NewAccessControlManager(address,address)": {
        "notice": "Emitted when access control manager contract address is changed"
      },
      "PancakeSwapRouterUpdated(address,address)": {
        "notice": "Emitted when PancakeSwap router contract address is updated"
      },
      "PoolRegistryUpdated(address,address)": {
        "notice": "Emitted when pool registry address is updated"
      },
      "ShortfallContractUpdated(address,address)": {
        "notice": "Emitted when shortfall contract address is updated"
      },
      "SwappedPoolsAssets(address[],uint256[],uint256)": {
        "notice": "Emitted when pools assets are swapped"
      },
      "SweepToken(address,address,uint256)": {
        "notice": "event emitted on sweep token success"
      },
      "TransferredReserveForAuction(address,uint256)": {
        "notice": "Emitted when reserves are transferred for auction"
      }
    },
    "kind": "user",
    "methods": {
      "accessControlManager()": {
        "notice": "Returns the address of the access control manager contract"
      },
      "getPoolAssetReserve(address,address)": {
        "notice": "Get the Amount of the asset in the risk fund for the specific pool."
      },
      "getPoolsBaseAssetReserves(address)": {
        "notice": "Get the Amount of the Base asset in the risk fund for the specific pool."
      },
      "initialize(address,uint256,address,address,uint256)": {
        "notice": "Initializes the deployer to owner."
      },
      "setAccessControlManager(address)": {
        "notice": "Sets the address of AccessControlManager"
      },
      "setConvertibleBaseAsset(address)": {
        "notice": "Sets a new convertible base asset"
      },
      "setMaxLoopsLimit(uint256)": {
        "notice": "Set the limit for the loops can iterate to avoid the DOS"
      },
      "setMinAmountToConvert(uint256)": {
        "notice": "Min amount to convert setter"
      },
      "setPancakeSwapRouter(address)": {
        "notice": "PancakeSwap router address setter"
      },
      "setPoolRegistry(address)": {
        "notice": "Pool registry setter"
      },
      "setShortfallContractAddress(address)": {
        "notice": "Shortfall contract address setter"
      },
      "swapPoolsAssets(address[],uint256[],address[][],uint256)": {
        "notice": "Swap array of pool assets into base asset's tokens of at least a minimum amount"
      },
      "sweepToken(address,address)": {
        "notice": "A public function to sweep accidental BEP-20 transfers to this contract. Tokens are sent to the address `to`, provided in input"
      },
      "transferReserveForAuction(address,uint256)": {
        "notice": "Transfer tokens for auction."
      },
      "updateAssetsState(address,address)": {
        "notice": "Update the reserve of the asset for the specific pool after transferring to risk fund."
      }
    },
    "notice": "Contract with basic features to track/hold different assets for different Comptrollers.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 244,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 247,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1267,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 116,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 236,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 25,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "101",
        "type": "t_address"
      },
      {
        "astId": 104,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 1355,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_accessControlManager",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(IAccessControlManagerV8)1539"
      },
      {
        "astId": 1360,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 8855,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "assetsReserves",
        "offset": 0,
        "slot": "201",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 8861,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "_poolsAssetsReserves",
        "offset": 0,
        "slot": "202",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 8863,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "poolRegistry",
        "offset": 0,
        "slot": "203",
        "type": "t_address"
      },
      {
        "astId": 8866,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "status",
        "offset": 0,
        "slot": "204",
        "type": "t_uint256"
      },
      {
        "astId": 8871,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "205",
        "type": "t_array(t_uint256)46_storage"
      },
      {
        "astId": 6064,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "maxLoopsLimit",
        "offset": 0,
        "slot": "251",
        "type": "t_uint256"
      },
      {
        "astId": 6069,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "__gap",
        "offset": 0,
        "slot": "252",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 9284,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "convertibleBaseAsset",
        "offset": 0,
        "slot": "301",
        "type": "t_address"
      },
      {
        "astId": 9286,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "shortfall",
        "offset": 0,
        "slot": "302",
        "type": "t_address"
      },
      {
        "astId": 9288,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "pancakeSwapRouter",
        "offset": 0,
        "slot": "303",
        "type": "t_address"
      },
      {
        "astId": 9290,
        "contract": "contracts/RiskFund/RiskFund.sol:RiskFund",
        "label": "minAmountToConvert",
        "offset": 0,
        "slot": "304",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)46_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[46]",
        "numberOfBytes": "1472"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IAccessControlManagerV8)1539": {
        "encoding": "inplace",
        "label": "contract IAccessControlManagerV8",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}
